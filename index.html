<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Viking Run</title>
  <!-- MediaPipe Face Landmarker for Eye/Gaze Tracking + rPPG -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js"></script>
  <style>
    :root{
      /* Apple Design System Colors - HIGH CONTRAST & READABLE */
      --bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --bg-dark: #1a1a2e;
      --surface: #ffffff;
      --surface-elevated: #ffffff;
      --surface-dark: rgba(30, 30, 46, 0.95);
      --text: #000000;
      --text-secondary: #333333;
      --text-tertiary: #666666;
      --text-light: #ffffff;
      --separator: rgba(0, 0, 0, 0.2);
      --accent: #007aff;
      --accent-hover: #0051d5;
      --accent-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --shadow: rgba(0, 0, 0, 0.2);
      --shadow-lg: rgba(0, 0, 0, 0.3);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      background-attachment: fixed;
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
      overflow: hidden;
      user-select: none;
      -webkit-font-smoothing: antialiased;
    }

    .wrap{ 
      height: 100%; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      padding: 24px; 
    }
    
    .shell{
      width: min(1200px, calc(100vw - 48px));
      height: min(800px, calc(100vh - 48px));
      border-radius: 24px;
      background: var(--surface);
      border: none;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(0, 0, 0, 0.05);
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(40px);
    }

    .topbar{ 
      position: absolute; 
      left: 20px; 
      right: 20px; 
      top: 16px; 
      height: 56px; 
      display: flex; 
      align-items: center; 
      justify-content: space-between; 
      z-index: 100; 
      pointer-events: none; 
    }
    
    .leftpack, .rightpack{ 
      display: flex; 
      align-items: center; 
      gap: 12px; 
      pointer-events: auto; 
    }
    
    .title{ 
      padding: 6px 12px; 
      border-radius: 8px; 
      background: transparent;
    }
    
    .title strong{ 
      font-weight: 600; 
      font-size: 17px;
      letter-spacing: -0.4px;
      color: var(--text);
    }
    
    .pill{ 
      font-size: 11px; 
      padding: 4px 8px; 
      border-radius: 6px; 
      background: var(--surface-elevated);
      color: var(--text-secondary);
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }
    
    .scorecard{ 
      display: flex; 
      align-items: center; 
      gap: 24px; 
      padding: 0;
      background: transparent;
      border: none;
    }
    
    .stat{ 
      display: flex;
      flex-direction: column;
      gap: 2px; 
      min-width: 70px; 
    }
    
    .stat .k{ 
      font-size: 10px; 
      color: var(--text-secondary); 
      text-transform: uppercase; 
      font-weight: 500; 
      letter-spacing: 0.5px;
    }
    
    .stat .v{ 
      font-size: 22px; 
      font-weight: 700; 
      line-height: 1; 
      color: #007aff;
      letter-spacing: -0.5px;
    }

    .btn{ 
      border: none; 
      background: var(--surface-elevated);
      color: var(--accent); 
      padding: 8px 16px; 
      border-radius: 8px; 
      cursor: pointer; 
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); 
      font-weight: 500; 
      font-size: 13px; 
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;
      min-width: 80px;
      text-align: center;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      height: 36px;
    }
    
    .btn:hover{ 
      background: var(--surface-elevated);
      opacity: 0.8;
    }
    
    .btn.primary{ 
      background: var(--accent);
      color: #ffffff;
      font-weight: 600;
    }
    
    .btn.primary:hover {
      background: var(--accent-hover);
    }

    .hudline{ 
      position: absolute; 
      left: 20px; 
      right: 20px; 
      bottom: 20px; 
      display: flex; 
      justify-content: center; 
      z-index: 100; 
      pointer-events: none; 
    }
    
    .hint{ 
      max-width: 700px; 
      padding: 14px 24px; 
      border-radius: 12px; 
      background: #ffffff;
      border: 2px solid rgba(0, 0, 0, 0.2);
      color: #000000; 
      font-size: 13px; 
      font-weight: 600;
      text-align: center; 
      pointer-events: auto;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
    }
    
    kbd{ 
      background: #000000; 
      border-radius: 4px; 
      padding: 3px 8px; 
      color: #ffffff; 
      border: 1px solid #000000; 
      margin: 0 3px; 
      font-weight: 700;
      font-size: 12px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .canvas{ 
      position: absolute; 
      inset: 0; 
      width: 100%; 
      height: 100%; 
      display: block; 
      cursor: crosshair; 
    }
    
    .overlay{ 
      position: absolute; 
      inset: 0; 
      display: grid; 
      place-items: center; 
      pointer-events: none; 
      z-index: 200; 
      background: rgba(0, 0, 0, 0.7); 
      backdrop-filter: blur(20px);
      visibility: visible;
      opacity: 1;
    }
    
    .card{ 
      pointer-events: auto; 
      width: min(480px, 90%); 
      border-radius: 24px; 
      padding: 40px; 
      background: #ffffff;
      backdrop-filter: blur(40px);
      border: 1px solid rgba(0, 0, 0, 0.1);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
      text-align: center;
    }
    
    .card h1{ 
      font-size: 36px; 
      margin: 0 0 16px; 
      font-weight: 800;
      letter-spacing: -1px;
      color: #000000;
    }
    
    .card p{ 
      margin: 0 0 28px; 
      color: #333333; 
      line-height: 1.5; 
      font-size: 15px;
    }
    
    .eye-tracking-indicator {
      position: absolute;
      top: 70px;
      left: 20px;
      padding: 8px 14px;
      border-radius: 8px;
      background: rgba(0, 122, 255, 0.9);
      color: white;
      font-size: 12px;
      font-weight: 600;
      z-index: 150;
      display: none;
      align-items: center;
      gap: 8px;
    }
    
    .eye-tracking-indicator.active {
      display: flex;
    }
    
    .eye-tracking-indicator .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #4ade80;
      animation: pulse 1s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
    }
    
    .bpm-display {
      position: absolute;
      top: 110px;
      left: 20px;
      padding: 10px 16px;
      border-radius: 10px;
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.9), rgba(185, 28, 28, 0.9));
      color: white;
      font-size: 14px;
      font-weight: 700;
      z-index: 150;
      display: none;
      align-items: center;
      gap: 8px;
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
    }
    
    .bpm-display.active {
      display: flex;
    }
    
    .bpm-display .heart-icon {
      font-size: 18px;
      animation: heartbeat 1s ease-in-out infinite;
    }
    
    .bpm-display #bpmValue {
      font-size: 20px;
      font-weight: 800;
      min-width: 36px;
      text-align: center;
    }
    
    .bpm-display .bpm-label {
      font-size: 11px;
      opacity: 0.9;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    @keyframes heartbeat {
      0%, 100% { transform: scale(1); }
      15% { transform: scale(1.15); }
      30% { transform: scale(1); }
      45% { transform: scale(1.1); }
      60% { transform: scale(1); }
    }
    
    .calibration-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 500;
      display: none;
      place-items: center;
    }
    
    .calibration-overlay.active {
      display: grid;
    }
    
    .calibration-card {
      background: #ffffff;
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      max-width: 500px;
    }
    
    .calibration-card h2 {
      color: #000;
      margin-bottom: 20px;
      font-size: 24px;
    }
    
    .calibration-card p {
      color: #333;
      margin-bottom: 24px;
      line-height: 1.6;
    }
    
    .calibration-points {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 20px;
      margin: 30px 0;
    }
    
    .calibration-point {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #007aff;
      cursor: pointer;
      transition: all 0.2s;
      margin: 0 auto;
    }
    
    .calibration-point:hover {
      transform: scale(1.2);
      background: #0051d5;
    }
    
    .calibration-point.clicked {
      background: #4ade80;
    }
    
    .gaze-cursor {
      position: fixed;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: rgba(255, 107, 107, 0.6);
      border: 3px solid rgba(255, 107, 107, 0.9);
      pointer-events: none;
      z-index: 9999;
      transform: translate(-50%, -50%);
      display: none;
      transition: left 0.05s, top 0.05s;
    }
    
    .gaze-cursor.active {
      display: block;
    }

    .lives-display {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-left: 12px;
      display: flex;
      gap: 6px;
      align-items: center;
      padding: 10px 16px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.08);
      z-index: 150;
      pointer-events: none;
    }

    .highscore-modal {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 300;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(20px);
      place-items: center;
    }

    .highscore-modal.active {
      display: grid;
    }

    .highscore-card {
      width: min(600px, 90%);
      max-height: 80vh;
      overflow-y: auto;
      padding: 32px;
      border-radius: 18px;
      background: var(--surface);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .highscore-tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 24px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .highscore-tab {
      padding: 10px 16px;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-weight: 500;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.15s;
      font-size: 13px;
    }

    .highscore-tab.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }

    .highscore-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .highscore-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .highscore-item.rank-1 {
      background: var(--accent-subtle);
      border-color: rgba(255, 215, 0, 0.2);
    }

    .highscore-rank {
      font-size: 18px;
      font-weight: 600;
      color: var(--accent);
      min-width: 35px;
    }

    .highscore-score {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
    }

    .highscore-date {
      font-size: 11px;
      color: var(--text-secondary);
    }
  </style>
</head>

<body>
  <!-- Eye Tracking Gaze Cursor -->
  <div class="gaze-cursor" id="gazeCursor"></div>
  
  <div class="wrap">
    <div class="shell" id="shell">
      <canvas class="canvas" id="c"></canvas>
      
      <!-- Eye Tracking Indicator -->
      <div class="eye-tracking-indicator" id="eyeTrackingIndicator">
        <div class="dot"></div>
        <span>Eye Tracking Active</span>
      </div>
      
      <!-- Heart Rate (BPM) Display -->
      <div class="bpm-display" id="bpmDisplay">
        <span class="heart-icon">‚ù§Ô∏è</span>
        <span id="bpmValue">--</span>
        <span class="bpm-label">BPM</span>
      </div>
      
      <!-- Gaze Zone Indicator - shows what zone you're looking at -->
      <div id="gazeZoneIndicator" style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); padding:20px 40px; border-radius:12px; font-size:24px; font-weight:bold; color:white; z-index:1000; display:none; pointer-events:none;"></div>
      
      <!-- Calibration Overlay -->
      <div class="calibration-overlay" id="calibrationOverlay">
        <div class="calibration-card">
          <h2>üëÅÔ∏è Eye Tracking Calibration</h2>
          <p style="margin-bottom: 16px;"><strong>How it works:</strong> Look at each blue dot and click it.<br>This trains the eye tracker on your gaze patterns.</p>
          <div style="background: #f0f9ff; padding: 12px; border-radius: 8px; margin-bottom: 20px;">
            <p style="margin: 0; font-size: 14px; color: #0369a1;">
              <strong>üëÜ TIP:</strong> Keep your head still and move only your eyes.<br>
              Good lighting helps accuracy!
            </p>
          </div>
          <div class="calibration-points" id="calibrationPoints">
            <div class="calibration-point" data-pos="1"></div>
            <div class="calibration-point" data-pos="2"></div>
            <div class="calibration-point" data-pos="3"></div>
            <div class="calibration-point" data-pos="4"></div>
            <div class="calibration-point" data-pos="5"></div>
            <div class="calibration-point" data-pos="6"></div>
            <div class="calibration-point" data-pos="7"></div>
            <div class="calibration-point" data-pos="8"></div>
            <div class="calibration-point" data-pos="9"></div>
          </div>
          <p id="calibrationStatus" style="font-weight: 600;">Click all 9 points to calibrate (0/9)</p>
          <div style="background: #ecfdf5; padding: 12px; border-radius: 8px; margin-top: 16px;">
            <p style="margin: 0; font-size: 13px; color: #047857;">
              <strong>During gameplay:</strong><br>
              üëÄ Look UP = Viking JUMPS<br>
              üëÄ Look DOWN = Viking DUCKS<br>
              Press <kbd style="background:#000;color:#fff;padding:2px 6px;border-radius:4px;">E</kbd> to toggle eye tracking
            </p>
          </div>
          <button class="btn primary" id="finishCalibrationBtn" style="margin-top: 24px; padding: 14px 32px; font-size: 15px;">Start Playing with Eye Tracking</button>
        </div>
      </div>

      <div class="topbar">
        <div class="leftpack">
          <div class="title"><strong>Viking Run</strong> <span class="pill" id="statePill">Ready</span></div>
          <div class="scorecard">
            <div class="stat"><div class="k">Score</div><div class="v" id="scoreV">0</div></div>
            <div class="stat"><div class="k">Mead</div><div class="v" id="meadV">0</div></div>
            <div class="stat" id="multiplierStat" style="display: none;"><div class="k">Multiplier</div><div class="v" id="multiplierV">1x</div></div>
          </div>
        </div>
        <div class="rightpack">
          <div class="lives-display" id="livesDisplay">
            <span style="font-size: 20px;">‚ù§Ô∏è</span>
            <span id="livesCount" style="font-size: 18px; font-weight: 700; color: #ef4444;">3</span>
          </div>
          <button class="btn" id="pauseBtn">Pause</button>
          <button class="btn" id="soundBtn">Sound: On</button>
          <button class="btn primary" id="restartBtn">Restart</button>
        </div>
      </div>


      <div class="hudline">
        <div class="hint" id="hint">
          <kbd>Space</kbd> Jump | <kbd>Down</kbd> Duck | <kbd>üëÅÔ∏è</kbd> Eye Track | Jump ON enemies to stomp them!
        </div>
      </div>

      <div class="overlay" id="overlay">
        <div class="card">
          <h1 id="overlayTitle">Viking Run</h1>
          <p id="overlayText" style="white-space: pre-line;">Jump on platforms, avoid enemies, collect powerups, and survive.</p>
          <div style="display: flex; flex-direction: column; align-items: center; gap: 12px; width: 100%; max-width: 280px; margin: 20px auto 0;">
            <button class="btn primary" id="startBtn" style="padding: 14px 32px; font-size: 15px; width: 100%; height: 48px;">Start Game</button>
            <button class="btn" id="eyeTrackBtn" style="padding: 12px 24px; font-size: 14px; width: 100%; height: 44px;">üëÅÔ∏è Enable Eye Tracking</button>
            <button class="btn" id="highscoreBtn" style="padding: 12px 24px; font-size: 14px; width: 100%; height: 44px;">High Scores</button>
          </div>
        </div>
      </div>

      <div class="highscore-modal" id="highscoreModal">
        <div class="highscore-card">
          <h2 style="margin-bottom: 24px; font-size: 24px; font-weight: 600; color: var(--text);">High Scores</h2>
          <div class="highscore-tabs">
            <button class="highscore-tab active" data-period="alltime">All Time</button>
            <button class="highscore-tab" data-period="yearly">Yearly</button>
            <button class="highscore-tab" data-period="monthly">Monthly</button>
            <button class="highscore-tab" data-period="weekly">Weekly</button>
            <button class="highscore-tab" data-period="daily">Daily</button>
          </div>
          <div class="highscore-list" id="highscoreList"></div>
          <button class="btn" id="closeHighscoreBtn" style="margin-top: 24px; width: 100%;">Close</button>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  const $ = (id) => document.getElementById(id);
  const rand = (a, b) => a + Math.random() * (b - a);
  const pick = (arr) => arr[(Math.random() * arr.length) | 0];

  const canvas = $("c");
  const shell = $("shell");
  const scoreV = $("scoreV");
  const meadV = $("meadV");
  const statePill = $("statePill");
  const overlay = $("overlay");
  const startBtn = $("startBtn");
  const pauseBtn = $("pauseBtn");
  const restartBtn = $("restartBtn");
  const soundBtn = $("soundBtn");

  let W, H, DPR, ctx;
  const resize = () => {
    const rect = shell.getBoundingClientRect();
    DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    W = Math.floor(rect.width); H = Math.floor(rect.height);
    canvas.width = Math.floor(W * DPR); canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + "px"; canvas.style.height = H + "px";
    ctx = canvas.getContext("2d");
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  };
  window.addEventListener("resize", resize);
  resize(); // Initialize immediately

  let AC = null;
  const beep = (type, freq, dur, gain = 0.2) => {
    if (!OPT.sound) return;
    if (!AC) AC = new (window.AudioContext || window.webkitAudioContext)();
    const o = AC.createOscillator(), g = AC.createGain();
    o.type = type; o.frequency.setValueAtTime(freq, AC.currentTime);
    g.gain.setValueAtTime(gain, AC.currentTime); g.gain.exponentialRampToValueAtTime(0.01, AC.currentTime + dur);
    o.connect(g); g.connect(AC.destination);
    o.start(); o.stop(AC.currentTime + dur);
  };
  
  // ===== AUTHENTIC VIKING SOUND EFFECTS =====
  // Inspired by Vikings TV series - using advanced synthesis techniques
  
  // Helper: Create white noise buffer
  const createNoiseBuffer = (duration) => {
    const bufferSize = AC.sampleRate * duration;
    const buffer = AC.createBuffer(1, bufferSize, AC.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      data[i] = Math.random() * 2 - 1;
    }
    return buffer;
  };
  
  // Helper: Create formant filter for voice sounds
  const createFormant = (freq, q, gain) => {
    const filter = AC.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = freq;
    filter.Q.value = q;
    const gn = AC.createGain();
    gn.gain.value = gain;
    filter.connect(gn);
    return { filter, gain: gn };
  };
  
  const playSFX = (sfxType) => {
    if (!OPT.sound) return;
    if (!AC) AC = new (window.AudioContext || window.webkitAudioContext)();
    
    const now = AC.currentTime;
    
    switch(sfxType) {
      case 'jump': {
        // Leather armor creak + cloth whoosh
        const noise = AC.createBufferSource();
        noise.buffer = createNoiseBuffer(0.2);
        const filter = AC.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(1500, now);
        filter.frequency.exponentialRampToValueAtTime(3000, now + 0.1);
        filter.Q.value = 1;
        const gain = AC.createGain();
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(AC.destination);
        noise.start(now);
        break;
      }
      case 'powerup': {
        // Ancient Nordic rune activation - mystical shimmer
        const notes = [293.7, 349.2, 440, 523.3]; // D4, F4, A4, C5 - minor chord
        notes.forEach((freq, i) => {
          const osc = AC.createOscillator();
          const gain = AC.createGain();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, now + i * 0.06);
          // Add shimmer vibrato
          const vibrato = AC.createOscillator();
          const vibGain = AC.createGain();
          vibrato.frequency.value = 8;
          vibGain.gain.value = 5;
          vibrato.connect(vibGain);
          vibGain.connect(osc.frequency);
          vibrato.start(now);
          vibrato.stop(now + 0.6);
          gain.gain.setValueAtTime(0, now + i * 0.06);
          gain.gain.linearRampToValueAtTime(0.15, now + i * 0.06 + 0.05);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
          osc.connect(gain);
          gain.connect(AC.destination);
          osc.start(now + i * 0.06);
          osc.stop(now + 0.6);
        });
        break;
      }
      case 'mead': {
        // Realistic Viking mead drinking - liquid gulping + wooden mug
        // Liquid gulping sounds (filtered noise bursts)
        [0, 0.2, 0.4].forEach((delay, i) => {
          const gulp = AC.createBufferSource();
          gulp.buffer = createNoiseBuffer(0.15);
          const gulpFilter = AC.createBiquadFilter();
          gulpFilter.type = 'bandpass';
          gulpFilter.frequency.setValueAtTime(400 + i * 100, now + delay);
          gulpFilter.frequency.exponentialRampToValueAtTime(200, now + delay + 0.12);
          gulpFilter.Q.value = 2;
          const gulpGain = AC.createGain();
          gulpGain.gain.setValueAtTime(0, now + delay);
          gulpGain.gain.linearRampToValueAtTime(0.25, now + delay + 0.02);
          gulpGain.gain.exponentialRampToValueAtTime(0.01, now + delay + 0.14);
          gulp.connect(gulpFilter);
          gulpFilter.connect(gulpGain);
          gulpGain.connect(AC.destination);
          gulp.start(now + delay);
        });
        
        // Wooden mug "clunk" when setting down
        const clunk = AC.createOscillator();
        const clunkGain = AC.createGain();
        clunk.type = 'sine';
        clunk.frequency.setValueAtTime(200, now + 0.65);
        clunk.frequency.exponentialRampToValueAtTime(120, now + 0.75);
        clunkGain.gain.setValueAtTime(0.15, now + 0.65);
        clunkGain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
        const clunkFilter = AC.createBiquadFilter();
        clunkFilter.type = 'lowpass';
        clunkFilter.frequency.value = 600;
        clunk.connect(clunkFilter);
        clunkFilter.connect(clunkGain);
        clunkGain.connect(AC.destination);
        clunk.start(now + 0.65);
        clunk.stop(now + 0.85);
        
        // Satisfied "ahh" exhale with proper formants
        const exhale = AC.createOscillator();
        const exhaleGain = AC.createGain();
        exhale.type = 'sawtooth';
        exhale.frequency.setValueAtTime(120, now + 0.7);
        exhale.frequency.exponentialRampToValueAtTime(80, now + 1.0);
        
        // Formants for "ahh" sound
        const f1 = createFormant(700, 10, 0.4);
        const f2 = createFormant(1200, 8, 0.25);
        
        exhaleGain.gain.setValueAtTime(0, now + 0.7);
        exhaleGain.gain.linearRampToValueAtTime(0.18, now + 0.75);
        exhaleGain.gain.exponentialRampToValueAtTime(0.01, now + 1.05);
        
        exhale.connect(f1.filter);
        exhale.connect(f2.filter);
        f1.gain.connect(exhaleGain);
        f2.gain.connect(exhaleGain);
        exhaleGain.connect(AC.destination);
        exhale.start(now + 0.7);
        exhale.stop(now + 1.1);
        break;
      }
      case 'damage': {
        // Viking battle grunt - deep "UGH!" with impact
        // Voice with formants for guttural grunt
        const voice = AC.createOscillator();
        voice.type = 'sawtooth';
        voice.frequency.setValueAtTime(120, now);
        voice.frequency.exponentialRampToValueAtTime(70, now + 0.2);
        // Formants for "UH" grunt sound
        const f1 = createFormant(500, 8, 0.5);
        const f2 = createFormant(1000, 10, 0.3);
        const masterGain = AC.createGain();
        masterGain.gain.setValueAtTime(0.4, now);
        masterGain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        voice.connect(f1.filter);
        voice.connect(f2.filter);
        f1.gain.connect(masterGain);
        f2.gain.connect(masterGain);
        masterGain.connect(AC.destination);
        voice.start(now);
        voice.stop(now + 0.3);
        
        // Shield/armor impact - metallic crash
        const impact = AC.createBufferSource();
        impact.buffer = createNoiseBuffer(0.15);
        const impFilter = AC.createBiquadFilter();
        impFilter.type = 'highpass';
        impFilter.frequency.value = 800;
        const impGain = AC.createGain();
        impGain.gain.setValueAtTime(0.3, now);
        impGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        impact.connect(impFilter);
        impFilter.connect(impGain);
        impGain.connect(AC.destination);
        impact.start(now);
        
        // Body thud
        const thud = AC.createOscillator();
        const thudGain = AC.createGain();
        thud.type = 'sine';
        thud.frequency.setValueAtTime(60, now);
        thud.frequency.exponentialRampToValueAtTime(25, now + 0.1);
        thudGain.gain.setValueAtTime(0.5, now);
        thudGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        thud.connect(thudGain);
        thudGain.connect(AC.destination);
        thud.start(now);
        thud.stop(now + 0.2);
        break;
      }
      case 'gameover': {
        // Somber Viking funeral horn - deep, mournful, not farty
        const fundamental = 73.4; // D2 - deep but not too low
        const duration = 3.0;
        
        // Main horn tone with proper resonance
        [1, 2].forEach((harmonic, i) => {
          const osc = AC.createOscillator();
          const gain = AC.createGain();
          osc.type = 'square'; // Square wave for horn
          const freq = fundamental * harmonic;
          
          // Slow mournful descent
          osc.frequency.setValueAtTime(freq, now);
          osc.frequency.linearRampToValueAtTime(freq * 0.82, now + duration);
          
          // Formant for horn resonance
          const formant = AC.createBiquadFilter();
          formant.type = 'bandpass';
          formant.frequency.value = 150 + i * 100;
          formant.Q.value = 2;
          
          // Slow fade envelope
          const amp = [0.3, 0.12][i];
          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(amp, now + 0.4);
          gain.gain.setValueAtTime(amp * 0.9, now + duration * 0.6);
          gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
          
          // Reverb-like effect with delay
          const delay = AC.createDelay(0.1);
          delay.delayTime.value = 0.08;
          const delayGain = AC.createGain();
          delayGain.gain.value = 0.3;
          
          osc.connect(formant);
          formant.connect(gain);
          formant.connect(delay);
          delay.connect(delayGain);
          delayGain.connect(gain);
          gain.connect(AC.destination);
          
          osc.start(now);
          osc.stop(now + duration);
        });
        break;
      }
      case 'heart': {
        // Healing rune glow - warm mystical sound
        const notes = [196, 293.7, 392]; // G3, D4, G4 - open fifth
        notes.forEach((freq, i) => {
          const osc = AC.createOscillator();
          const gain = AC.createGain();
          osc.type = 'sine';
          osc.frequency.value = freq;
          gain.gain.setValueAtTime(0, now + i * 0.08);
          gain.gain.linearRampToValueAtTime(0.15, now + i * 0.08 + 0.1);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
          osc.connect(gain);
          gain.connect(AC.destination);
          osc.start(now + i * 0.08);
          osc.stop(now + 0.7);
        });
        break;
      }
      case 'warhorn': {
        // Realistic Viking war horn - proper horn resonance, no "fart" sounds
        const fundamental = 98; // G2 - proper horn note
        const duration = 2.0;
        
        // Main horn tone - square wave with formants for horn resonance
        [1, 2, 3, 4].forEach((harmonic, i) => {
          const osc = AC.createOscillator();
          const gain = AC.createGain();
          osc.type = 'square'; // Square wave for horn-like sound
          const freq = fundamental * harmonic;
          
          // Horn call pattern: rise, hold, fall
          osc.frequency.setValueAtTime(freq * 0.92, now);
          osc.frequency.linearRampToValueAtTime(freq, now + 0.3);
          osc.frequency.setValueAtTime(freq, now + 1.0);
          osc.frequency.linearRampToValueAtTime(freq * 0.88, now + duration);
          
          // Formant filters for horn resonance
          const formant1 = AC.createBiquadFilter();
          formant1.type = 'bandpass';
          formant1.frequency.value = 200 + i * 50;
          formant1.Q.value = 2;
          
          const formant2 = AC.createBiquadFilter();
          formant2.type = 'bandpass';
          formant2.frequency.value = 400 + i * 100;
          formant2.Q.value = 1.5;
          
          // Amplitude envelope
          const amp = [0.25, 0.12, 0.06, 0.03][i];
          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(amp, now + 0.2);
          gain.gain.setValueAtTime(amp, now + 1.0);
          gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
          
          // Slight vibrato for natural horn sound
          const vibrato = AC.createOscillator();
          const vibGain = AC.createGain();
          vibrato.frequency.value = 5.5;
          vibGain.gain.value = 2;
          vibrato.connect(vibGain);
          vibGain.connect(osc.frequency);
          
          osc.connect(formant1);
          formant1.connect(formant2);
          formant2.connect(gain);
          gain.connect(AC.destination);
          
          vibrato.start(now);
          vibrato.stop(now + duration);
          osc.start(now);
          osc.stop(now + duration);
        });
        
        // Breath noise - filtered white noise for realism
        const breath = AC.createBufferSource();
        breath.buffer = createNoiseBuffer(0.4);
        const breathFilter = AC.createBiquadFilter();
        breathFilter.type = 'bandpass';
        breathFilter.frequency.value = 800;
        breathFilter.Q.value = 1;
        const breathGain = AC.createGain();
        breathGain.gain.setValueAtTime(0, now);
        breathGain.gain.linearRampToValueAtTime(0.08, now + 0.1);
        breathGain.gain.setValueAtTime(0.08, now + 1.5);
        breathGain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        breath.connect(breathFilter);
        breathFilter.connect(breathGain);
        breathGain.connect(AC.destination);
        breath.start(now);
        
        break;
      }
      case 'stomp': {
        // Heavy Viking boot on wooden deck
        const thud = AC.createOscillator();
        const thudGain = AC.createGain();
        thud.type = 'sine';
        thud.frequency.setValueAtTime(80, now);
        thud.frequency.exponentialRampToValueAtTime(35, now + 0.08);
        thudGain.gain.setValueAtTime(0.5, now);
        thudGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        thud.connect(thudGain);
        thudGain.connect(AC.destination);
        thud.start(now);
        thud.stop(now + 0.15);
        // Wood creak
        const creak = AC.createOscillator();
        const creakGain = AC.createGain();
        creak.type = 'triangle';
        creak.frequency.setValueAtTime(250, now + 0.03);
        creak.frequency.exponentialRampToValueAtTime(180, now + 0.1);
        creakGain.gain.setValueAtTime(0.12, now + 0.03);
        creakGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        creak.connect(creakGain);
        creakGain.connect(AC.destination);
        creak.start(now + 0.03);
        creak.stop(now + 0.15);
        break;
      }
      case 'gold': {
        // Proper metallic coin clinking - multiple coins with reverb
        const coinFreqs = [2400, 2800, 3200, 2600, 3000];
        coinFreqs.forEach((freq, i) => {
          const delay = i * 0.04;
          const coin = AC.createOscillator();
          const gain = AC.createGain();
          coin.type = 'triangle'; // Triangle for metallic "ting"
          coin.frequency.setValueAtTime(freq, now + delay);
          coin.frequency.exponentialRampToValueAtTime(freq * 0.6, now + delay + 0.15);
          
          // Metallic resonance filter
          const metallic = AC.createBiquadFilter();
          metallic.type = 'bandpass';
          metallic.frequency.value = freq;
          metallic.Q.value = 8;
          
          gain.gain.setValueAtTime(0, now + delay);
          gain.gain.linearRampToValueAtTime(0.25, now + delay + 0.01);
          gain.gain.exponentialRampToValueAtTime(0.01, now + delay + 0.18);
          
          // Reverb/delay for multiple coins
          const delayNode = AC.createDelay(0.1);
          delayNode.delayTime.value = 0.05;
          const delayGain = AC.createGain();
          delayGain.gain.value = 0.4;
          
          coin.connect(metallic);
          metallic.connect(gain);
          metallic.connect(delayNode);
          delayNode.connect(delayGain);
          delayGain.connect(gain);
          gain.connect(AC.destination);
          
          coin.start(now + delay);
          coin.stop(now + delay + 0.2);
        });
        
        // Coin bag "chink" - lower metallic sound
        const bag = AC.createOscillator();
        const bagGain = AC.createGain();
        bag.type = 'triangle';
        bag.frequency.setValueAtTime(800, now + 0.2);
        bag.frequency.exponentialRampToValueAtTime(400, now + 0.3);
        bagGain.gain.setValueAtTime(0.2, now + 0.2);
        bagGain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
        const bagFilter = AC.createBiquadFilter();
        bagFilter.type = 'lowpass';
        bagFilter.frequency.value = 1200;
        bag.connect(bagFilter);
        bagFilter.connect(bagGain);
        bagGain.connect(AC.destination);
        bag.start(now + 0.2);
        bag.stop(now + 0.4);
        break;
      }
      case 'shipStart': {
        // Epic Viking longship activation - horn + oars + wind
        // Epic war horn blast
        const horn = AC.createOscillator();
        const hornGain = AC.createGain();
        horn.type = 'square';
        horn.frequency.setValueAtTime(98, now);
        horn.frequency.linearRampToValueAtTime(147, now + 0.4);
        horn.frequency.setValueAtTime(147, now + 0.8);
        horn.frequency.linearRampToValueAtTime(98, now + 1.2);
        const hornFilter = AC.createBiquadFilter();
        hornFilter.type = 'bandpass';
        hornFilter.frequency.value = 200;
        hornFilter.Q.value = 2;
        hornGain.gain.setValueAtTime(0, now);
        hornGain.gain.linearRampToValueAtTime(0.4, now + 0.2);
        hornGain.gain.setValueAtTime(0.4, now + 0.8);
        hornGain.gain.exponentialRampToValueAtTime(0.01, now + 1.4);
        horn.connect(hornFilter);
        hornFilter.connect(hornGain);
        hornGain.connect(AC.destination);
        horn.start(now);
        horn.stop(now + 1.5);
        
        // Oar splashes (rhythmic water sounds)
        [0.3, 0.6, 0.9].forEach((delay) => {
          const splash = AC.createBufferSource();
          splash.buffer = createNoiseBuffer(0.15);
          const splashFilter = AC.createBiquadFilter();
          splashFilter.type = 'bandpass';
          splashFilter.frequency.value = 1500;
          splashFilter.Q.value = 1.5;
          const splashGain = AC.createGain();
          splashGain.gain.setValueAtTime(0.15, now + delay);
          splashGain.gain.exponentialRampToValueAtTime(0.01, now + delay + 0.2);
          splash.connect(splashFilter);
          splashFilter.connect(splashGain);
          splashGain.connect(AC.destination);
          splash.start(now + delay);
        });
        
        // Wind/air whoosh
        const wind = AC.createBufferSource();
        wind.buffer = createNoiseBuffer(0.8);
        const windFilter = AC.createBiquadFilter();
        windFilter.type = 'lowpass';
        windFilter.frequency.value = 400;
        const windGain = AC.createGain();
        windGain.gain.setValueAtTime(0, now);
        windGain.gain.linearRampToValueAtTime(0.12, now + 0.3);
        windGain.gain.setValueAtTime(0.12, now + 1.0);
        windGain.gain.exponentialRampToValueAtTime(0.01, now + 1.5);
        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(AC.destination);
        wind.start(now);
        break;
      }
      case 'shipDestroy': {
        // Viking ship destroying obstacle - crushing impact
        const crush = AC.createBufferSource();
        crush.buffer = createNoiseBuffer(0.25);
        const crushFilter = AC.createBiquadFilter();
        crushFilter.type = 'lowpass';
        crushFilter.frequency.value = 600;
        const crushGain = AC.createGain();
        crushGain.gain.setValueAtTime(0.5, now);
        crushGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        crush.connect(crushFilter);
        crushFilter.connect(crushGain);
        crushGain.connect(AC.destination);
        crush.start(now);
        
        // Water splash
        const splash = AC.createBufferSource();
        splash.buffer = createNoiseBuffer(0.3);
        const splashFilter = AC.createBiquadFilter();
        splashFilter.type = 'bandpass';
        splashFilter.frequency.value = 1800;
        splashFilter.Q.value = 1.5;
        const splashGain = AC.createGain();
        splashGain.gain.setValueAtTime(0.25, now + 0.05);
        splashGain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        splash.connect(splashFilter);
        splashFilter.connect(splashGain);
        splashGain.connect(AC.destination);
        splash.start(now + 0.05);
        break;
      }
      case 'shipDestroyEnemy': {
        // Viking warriors shouting + destruction when ship destroys enemies
        // Viking battle shout "SKOL!" or "FOR VALHALLA!"
        const shout1 = AC.createOscillator();
        const shout1Gain = AC.createGain();
        shout1.type = 'sawtooth';
        shout1.frequency.setValueAtTime(180, now);
        shout1.frequency.linearRampToValueAtTime(140, now + 0.15);
        const shout1Formant = createFormant(800, 12, 0.5);
        shout1Gain.gain.setValueAtTime(0.3, now);
        shout1Gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        shout1.connect(shout1Formant.filter);
        shout1Formant.gain.connect(shout1Gain);
        shout1Gain.connect(AC.destination);
        shout1.start(now);
        shout1.stop(now + 0.25);
        
        // Second shout
        const shout2 = AC.createOscillator();
        const shout2Gain = AC.createGain();
        shout2.type = 'sawtooth';
        shout2.frequency.setValueAtTime(160, now + 0.1);
        shout2.frequency.linearRampToValueAtTime(120, now + 0.25);
        const shout2Formant = createFormant(700, 10, 0.4);
        shout2Gain.gain.setValueAtTime(0.25, now + 0.1);
        shout2Gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        shout2.connect(shout2Formant.filter);
        shout2Formant.gain.connect(shout2Gain);
        shout2Gain.connect(AC.destination);
        shout2.start(now + 0.1);
        shout2.stop(now + 0.35);
        
        // Crushing impact
        const crush = AC.createBufferSource();
        crush.buffer = createNoiseBuffer(0.2);
        const crushFilter = AC.createBiquadFilter();
        crushFilter.type = 'lowpass';
        crushFilter.frequency.value = 800;
        const crushGain = AC.createGain();
        crushGain.gain.setValueAtTime(0.4, now + 0.15);
        crushGain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        crush.connect(crushFilter);
        crushFilter.connect(crushGain);
        crushGain.connect(AC.destination);
        crush.start(now + 0.15);
        break;
      }
      case 'speedBoost': {
        // Fast whoosh/wind sound for speed boost
        const whoosh = AC.createBufferSource();
        whoosh.buffer = createNoiseBuffer(0.4);
        const whooshFilter = AC.createBiquadFilter();
        whooshFilter.type = 'lowpass';
        whooshFilter.frequency.setValueAtTime(2000, now);
        whooshFilter.frequency.exponentialRampToValueAtTime(400, now + 0.4);
        const whooshGain = AC.createGain();
        whooshGain.gain.setValueAtTime(0, now);
        whooshGain.gain.linearRampToValueAtTime(0.3, now + 0.05);
        whooshGain.gain.setValueAtTime(0.3, now + 0.2);
        whooshGain.gain.exponentialRampToValueAtTime(0.01, now + 0.45);
        whoosh.connect(whooshFilter);
        whooshFilter.connect(whooshGain);
        whooshGain.connect(AC.destination);
        whoosh.start(now);
        break;
      }
      case 'invincibility': {
        // Shield activation - metallic shimmer + protective aura
        // Metallic shimmer
        [0, 0.05, 0.1].forEach((delay, i) => {
          const shimmer = AC.createOscillator();
          const gain = AC.createGain();
          shimmer.type = 'triangle';
          shimmer.frequency.value = 1200 + i * 400;
          gain.gain.setValueAtTime(0, now + delay);
          gain.gain.linearRampToValueAtTime(0.2, now + delay + 0.05);
          gain.gain.exponentialRampToValueAtTime(0.01, now + delay + 0.15);
          const metallic = AC.createBiquadFilter();
          metallic.type = 'bandpass';
          metallic.frequency.value = shimmer.frequency.value;
          metallic.Q.value = 10;
          shimmer.connect(metallic);
          metallic.connect(gain);
          gain.connect(AC.destination);
          shimmer.start(now + delay);
          shimmer.stop(now + delay + 0.2);
        });
        
        // Protective aura - low hum
        const aura = AC.createOscillator();
        const auraGain = AC.createGain();
        aura.type = 'sine';
        aura.frequency.value = 110;
        auraGain.gain.setValueAtTime(0, now);
        auraGain.gain.linearRampToValueAtTime(0.15, now + 0.1);
        auraGain.gain.setValueAtTime(0.15, now + 0.3);
        auraGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        aura.connect(auraGain);
        auraGain.connect(AC.destination);
        aura.start(now);
        aura.stop(now + 0.55);
        break;
      }
    }
  };

  // ==========================================
  // VIKING BACKGROUND MUSIC SYSTEM
  // ==========================================
  let musicContext = null;
  let musicPlaying = false;
  let musicNodes = [];
  let musicGain = null;
  
  const startVikingMusic = () => {
    if (musicPlaying) return;
    
    try {
      if (!musicContext) {
        musicContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      
      if (musicContext.state === 'suspended') {
        musicContext.resume();
      }
      
      // Master gain for music volume
      musicGain = musicContext.createGain();
      musicGain.gain.setValueAtTime(0.15, musicContext.currentTime);
      musicGain.connect(musicContext.destination);
      
      // Create a deep, epic Nordic drone
      const createDrone = (freq, type = 'sine') => {
        const osc = musicContext.createOscillator();
        const gain = musicContext.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, musicContext.currentTime);
        gain.gain.setValueAtTime(0.3, musicContext.currentTime);
        osc.connect(gain);
        gain.connect(musicGain);
        osc.start();
        musicNodes.push({ osc, gain });
        return { osc, gain };
      };
      
      // Base drone - low D (73.4 Hz) for epic feel
      createDrone(73.4, 'sine');
      createDrone(73.4 * 2, 'triangle'); // Octave
      createDrone(73.4 * 1.5, 'sine'); // Fifth (A)
      
      // Slow modulating pad
      const lfo = musicContext.createOscillator();
      const lfoGain = musicContext.createGain();
      lfo.frequency.setValueAtTime(0.1, musicContext.currentTime); // Very slow
      lfoGain.gain.setValueAtTime(20, musicContext.currentTime);
      lfo.connect(lfoGain);
      
      // Connect LFO to drone frequencies for subtle movement
      if (musicNodes[0]) {
        lfoGain.connect(musicNodes[0].osc.frequency);
      }
      lfo.start();
      musicNodes.push({ osc: lfo, gain: lfoGain });
      
      // Viking war drum - deep, powerful beats
      const createWarDrum = () => {
        let beatCount = 0;
        const playBeat = () => {
          if (!musicPlaying || !musicContext) return;
          
          const now = musicContext.currentTime;
          beatCount++;
          
          // Main drum hit
          const drum = musicContext.createOscillator();
          const drumGain = musicContext.createGain();
          drum.type = 'sine';
          drum.frequency.setValueAtTime(50, now);
          drum.frequency.exponentialRampToValueAtTime(25, now + 0.25);
          drumGain.gain.setValueAtTime(0.5, now);
          drumGain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
          drum.connect(drumGain);
          drumGain.connect(musicGain);
          drum.start(now);
          drum.stop(now + 0.5);
          
          // Accent on every 4th beat (stronger)
          if (beatCount % 4 === 1) {
            const accent = musicContext.createOscillator();
            const accentGain = musicContext.createGain();
            accent.type = 'triangle';
            accent.frequency.setValueAtTime(40, now);
            accent.frequency.exponentialRampToValueAtTime(20, now + 0.3);
            accentGain.gain.setValueAtTime(0.6, now);
            accentGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
            accent.connect(accentGain);
            accentGain.connect(musicGain);
            accent.start(now);
            accent.stop(now + 0.6);
          }
          
          // Viking march rhythm: BOOM - boom - BOOM - boom
          const nextBeat = beatCount % 2 === 0 ? 800 : 1200;
          if (musicPlaying) {
            setTimeout(playBeat, nextBeat);
          }
        };
        playBeat();
      };
      
      createWarDrum();
      
      // Nordic war horn melody - uses D minor scale (Viking sound)
      const playMelody = () => {
        if (!musicPlaying || !musicContext) return;
        
        // D minor pentatonic - authentic Nordic sound
        const notes = [146.8, 174.6, 196, 220, 261.6]; // D3, F3, G3, A3, C4
        const note = notes[Math.floor(Math.random() * notes.length)];
        const now = musicContext.currentTime;
        
        const hornOsc = musicContext.createOscillator();
        const hornGain = musicContext.createGain();
        
        hornOsc.type = 'sawtooth';
        hornOsc.frequency.setValueAtTime(note, now);
        
        hornGain.gain.setValueAtTime(0, now);
        hornGain.gain.linearRampToValueAtTime(0.1, now + 0.3);
        hornGain.gain.linearRampToValueAtTime(0.08, now + 1);
        hornGain.gain.exponentialRampToValueAtTime(0.01, now + 2);
        
        // Low-pass filter for warmer sound
        const filter = musicContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(800, now);
        
        hornOsc.connect(filter);
        filter.connect(hornGain);
        hornGain.connect(musicGain);
        hornOsc.start(now);
        hornOsc.stop(now + 2.5);
        
        // Next melody note in 3-6 seconds
        if (musicPlaying) {
          setTimeout(playMelody, 3000 + Math.random() * 3000);
        }
      };
      
      setTimeout(playMelody, 2000);
      
      musicPlaying = true;
    } catch (e) {
      console.error("Error starting music:", e);
    }
  };
  
  const stopVikingMusic = () => {
    musicPlaying = false;
    musicNodes.forEach(node => {
      try {
        if (node.osc) node.osc.stop();
      } catch (e) {}
    });
    musicNodes = [];
    if (musicGain) {
      musicGain.disconnect();
      musicGain = null;
    }
  };
  
  const setMusicVolume = (muted) => {
    if (musicGain) {
      musicGain.gain.setValueAtTime(muted ? 0 : 0.15, musicContext.currentTime);
    }
  };
  
  // Start music on first user interaction
  const startMusicOnInteraction = () => {
    if (!musicPlaying && OPT.sound) {
      startVikingMusic();
    }
    document.removeEventListener('click', startMusicOnInteraction);
    document.removeEventListener('keydown', startMusicOnInteraction);
  };
  document.addEventListener('click', startMusicOnInteraction);
  document.addEventListener('keydown', startMusicOnInteraction);

  const OPT = { sound: true }; // Sound ON by default
  const world = { 
    started: false, paused: false, over: false, 
    score: 0, mead: 0, speed: 200, t: 0, groundY: 0, camX: 0,
    lives: 3,
    nextObstacleAt: 0, nextMeadAt: 0, nextPowerupAt: 0, nextPlatformAt: 0, nextEnemyAt: 0, nextHeartAt: 0, nextGoldAt: 0,
    powerups: {
      speedBoost: { active: false, timeLeft: 0 },
      invincibility: { active: false, timeLeft: 0 },
      scoreMultiplier: { active: false, timeLeft: 0, multiplier: 1 }
    }
  };

  const viking = {
    x: 100, y: 0, vy: 0, w: 50, h: 70, 
    onGround: false, ducking: false, faceplant: 0,
    jumpsUsed: 0, maxJumps: 1
  };

  const Obstacles = [];
  const Meads = [];
  const Powerups = [];
  const Particles = [];
  const Platforms = [];
  const Enemies = [];
  const Hearts = [];
  const Golds = [];

  const spawnObstacle = (x) => {
    const type = Math.random() > 0.4 ? "shield" : "rock";
    Obstacles.push({ x, type, w: 45, h: 45, hit: false });
  };

  const spawnMead = (x) => {
    Meads.push({ x, y: world.groundY - rand(40, 160), taken: false, rotation: 0 });
  };

  const spawnPowerup = (x) => {
    const types = ["speedBoost", "invincibility", "scoreMultiplier", "vikingShip"];
    const type = pick(types);
    Powerups.push({ 
      x, 
      y: world.groundY - rand(60, 180), 
      type, 
      taken: false,
      rotation: 0,
      pulse: 0
    });
  };

  const spawnPlatform = (x) => {
    const width = rand(80, 150);
    const height = 20;
    // Sometimes spawn low platforms that require ducking (at ground level or slightly above)
    const isLowPlatform = Math.random() < 0.5; // 50% chance - more duck scenarios
    const y = isLowPlatform ? world.groundY - rand(30, 50) : world.groundY - rand(100, 250);
    Platforms.push({ x, y, width, height, isLow: isLowPlatform });
  };

  const spawnEnemy = (x) => {
    Enemies.push({
      x,
      y: world.groundY,
      w: 50,
      h: 60,
      defeated: false,
      hit: false
    });
  };


  const spawnHeart = (x) => {
    Hearts.push({
      x,
      y: world.groundY - rand(50, 150),
      taken: false,
      pulse: 0,
      rotation: 0
    });
  };

  const spawnGold = (x) => {
    Golds.push({
      x,
      y: world.groundY - rand(60, 200),
      taken: false,
      rotation: 0,
      value: Math.floor(rand(500, 5000))
    });
  };

  const addParticle = (x, y, color, count = 5) => {
    for (let i = 0; i < count; i++) {
      Particles.push({
        x, y,
        vx: rand(-120, 120),
        vy: rand(-180, -60),
        life: 1,
        color,
        size: rand(4, 10)
      });
    }
  };

  const resetWorld = () => {
    try {
      resize(); // Always resize to ensure H is set
      if (!H || H === 0) {
        setTimeout(resetWorld, 10);
        return;
      }
      
      world.started = false;
      world.paused = false;
      world.over = false;
      world.score = 0; 
      world.mead = 0; 
      world.speed = 230; 
      world.t = 0;
    world.groundY = H * 0.8;
      world.camX = 0;
      viking.x = 100;
      viking.y = world.groundY; 
      viking.vy = 0; 
      viking.faceplant = 0;
      viking.ducking = false;
      viking.onGround = true;
      Obstacles.length = 0; 
      Meads.length = 0; 
      Powerups.length = 0;
      Particles.length = 0;
      Platforms.length = 0;
      Enemies.length = 0;
      Hearts.length = 0;
      Golds.length = 0;
    world.nextObstacleAt = viking.x + 600;
      world.nextMeadAt = viking.x + 400;
      world.nextPowerupAt = viking.x + 6000;
      world.nextPlatformAt = viking.x + 500;
      world.nextEnemyAt = viking.x + 800;
      world.nextHeartAt = viking.x + 1200;
      world.nextGoldAt = viking.x + 2000;
      world.lives = 3;
      world.powerups = {
        speedBoost: { active: false, timeLeft: 0 },
        invincibility: { active: false, timeLeft: 0 },
        scoreMultiplier: { active: false, timeLeft: 0, multiplier: 1 },
        vikingShip: { active: false, timeLeft: 0 }
      };
      viking.jumpsUsed = 0;
      viking.maxJumps = 1;
      Input.jump = false;
      Input.duck = false;
      Input.jumpJustPressed = false;
      
      // Force overlay to show
      if (overlay) {
        overlay.style.display = "grid";
        overlay.style.visibility = "visible";
        overlay.style.opacity = "1";
      }
      const overlayTitle = $("overlayTitle");
      const overlayText = $("overlayText");
      if (overlayTitle) overlayTitle.textContent = "Viking Run";
      if (overlayText) overlayText.textContent = "Jump on platforms, avoid enemies, collect powerups, and survive.";
      if (startBtn) {
        startBtn.textContent = "Start Game";
        startBtn.style.display = "block";
      }
      if (statePill) statePill.textContent = "Ready";
      if (pauseBtn) pauseBtn.textContent = "Pause";
    updateHUD();
      
      // Force a redraw
      draw();
    } catch (e) {
      console.error("Error in resetWorld:", e);
    }
  };

  const updateHUD = () => {
    try {
      if (scoreV) scoreV.textContent = Math.floor(world.score).toLocaleString();
      if (meadV) meadV.textContent = world.mead;
      const multStat = $("multiplierStat");
      const multV = $("multiplierV");
      if (multStat && multV) {
        if (world.powerups.scoreMultiplier.active) {
          multStat.style.display = "flex";
          multV.textContent = world.powerups.scoreMultiplier.multiplier + "x";
        } else {
          multStat.style.display = "none";
        }
      }
      

      const livesCount = $("livesCount");
      if (livesCount) {
        livesCount.textContent = world.lives;
      }
    } catch (e) {
      console.error("Error in updateHUD:", e);
    }
  };

  const HighScoreManager = {
    apiUrl: 'https://api.jsonbin.io/v3/b', // Platform-wide leaderboard API
    apiKey: '$2a$10$YourAPIKeyHere', // Replace with actual API key for production
    useLocalStorage: true, // Fallback to localStorage if API fails
    
    getPeriodKey: (period) => {
      const now = new Date();
      const year = now.getFullYear();
      const month = now.getMonth();
      const day = now.toDateString(); // Get day BEFORE any mutations
      
      // Clone date for week calculation to avoid mutating 'now'
      const weekCalc = new Date(now.getTime());
      weekCalc.setDate(weekCalc.getDate() - weekCalc.getDay());
      const weekNum = Math.ceil(weekCalc.getDate() / 7);
      
      switch(period) {
        case 'daily': return `highscore_daily_${day}`;
        case 'weekly': return `highscore_weekly_${year}_W${weekNum}`;
        case 'monthly': return `highscore_monthly_${year}_${month}`;
        case 'yearly': return `highscore_yearly_${year}`;
        case 'alltime': return 'highscore_alltime';
        default: return 'highscore_alltime';
      }
    },

    async saveScore(score, playerName = null) {
      const now = new Date();
      const playerId = localStorage.getItem('playerId') || `player_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const name = playerName || localStorage.getItem('playerName') || `Player${playerId.substring(7, 11)}`;
      
      const scoreEntry = { 
        score, 
        date: now.toISOString(),
        playerId: playerId,
        playerName: name
      };
      
      // Generate player ID if not exists
      if (!localStorage.getItem('playerId')) {
        localStorage.setItem('playerId', playerId);
      }
      
      // Save player name if provided
      if (playerName) {
        localStorage.setItem('playerName', playerName);
      }
      
      // Save to all periods
      for (const period of ['daily', 'weekly', 'monthly', 'yearly', 'alltime']) {
        const key = HighScoreManager.getPeriodKey(period);
        let scores = HighScoreManager.getScoresLocal(period);
        scores.push(scoreEntry);
        scores.sort((a, b) => b.score - a.score);
        scores = scores.slice(0, 10);
        localStorage.setItem(key, JSON.stringify(scores));
      }
      
      // Try to sync to platform-wide API (if configured)
      try {
        // This would sync to a backend API for platform-wide leaderboards
        // For now, uses localStorage but structured for easy API integration
        if (!HighScoreManager.useLocalStorage) {
          // await fetch(`${HighScoreManager.apiUrl}/viking-game-leaderboard`, {
          //   method: 'PUT',
          //   headers: { 'Content-Type': 'application/json', 'X-API-Key': HighScoreManager.apiKey },
          //   body: JSON.stringify({ scores: allScores })
          // });
        }
      } catch (e) {
      }
    },

    getScoresLocal(period = 'alltime') {
      const key = HighScoreManager.getPeriodKey(period);
      return JSON.parse(localStorage.getItem(key) || '[]');
    },

    async getScores(period = 'alltime') {
      // Try API first, fallback to localStorage
      try {
        if (!HighScoreManager.useLocalStorage) {
          // const response = await fetch(`${HighScoreManager.apiUrl}/viking-game-leaderboard`);
          // const data = await response.json();
          // return data.scores || [];
        }
      } catch (e) {
      }
      return HighScoreManager.getScoresLocal(period);
    },

    async displayScores(period = 'alltime') {
      const scores = await HighScoreManager.getScores(period);
      const list = $("highscoreList");
      if (!list) return;
      
      list.innerHTML = '';
      
      if (scores.length === 0) {
        list.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">No scores yet</div>';
        return;
      }
      
      const currentPlayerId = localStorage.getItem('playerId');
      const currentPlayerName = localStorage.getItem('playerName') || 'You';
      
      scores.forEach((item, index) => {
        const div = document.createElement('div');
        const isCurrentPlayer = item.playerId === currentPlayerId;
        div.className = `highscore-item ${index === 0 ? 'rank-1' : ''} ${isCurrentPlayer ? 'current-player' : ''}`;
        const date = new Date(item.date);
        const playerName = item.playerName || item.playerId?.substring(0, 8) || 'Player';
        const displayName = isCurrentPlayer ? `${playerName} (You)` : playerName;
        div.innerHTML = `
          <div>
            <div class="highscore-rank">#${index + 1}</div>
            <div class="highscore-date">${displayName} ‚Ä¢ ${date.toLocaleDateString()}</div>
          </div>
          <div class="highscore-score">${Math.floor(item.score).toLocaleString()}</div>
        `;
        list.appendChild(div);
      });
    }
  };

  const Input = { jump: false, duck: false, jumpJustPressed: false };
  
  window.addEventListener("keydown", (e) => {
    if (e.code === "Space") { 
      if (!Input.jump) {
        Input.jumpJustPressed = true;
      }
      Input.jump = true;
      if(!world.started && !world.over) start(); 
    }
    if (e.code === "ArrowDown") Input.duck = true;
    e.preventDefault();
  });
  
  window.addEventListener("keyup", (e) => {
    if (e.code === "Space") {
      Input.jump = false;
      Input.jumpJustPressed = false;
    }
    if (e.code === "ArrowDown") Input.duck = false;
    e.preventDefault();
  });
  
  canvas.addEventListener("pointerdown", (e) => { 
    if (!Input.jump) {
      Input.jumpJustPressed = true;
    }
    Input.jump = true;
    // Attack system removed
    if(!world.started && !world.over) start(); 
    e.preventDefault();
  });
  
  window.addEventListener("pointerup", () => {
    Input.jump = false;
    Input.jumpJustPressed = false;
  });

  const start = () => {
    if (world.started) return;
    try {
    world.started = true;
      world.over = false;
      world.paused = false;
      if (overlay) {
    overlay.style.display = "none";
        overlay.style.visibility = "hidden";
      }
      if (statePill) statePill.textContent = "Playing";
      if (pauseBtn) pauseBtn.textContent = "Pause";
      playSFX('warhorn'); // Viking war horn!
    } catch (e) {
      console.error("Error in start:", e);
    }
  };

  // Draw Viking longship (when ship powerup is active)
  const drawVikingShip = (x, y) => {
    ctx.save();
    ctx.translate(x, y + 20); // Offset to sit on water level
    
    const bob = Math.sin(world.t * 4) * 3; // Gentle rocking
    const oarPhase = Math.sin(world.t * 8);
    
    // Water splash particles behind ship
    if (Math.random() < 0.3) {
      addParticle(x - 80, y + 10, "#4A90D9", 8);
    }
    
    // Ship hull - curved wooden longship
    ctx.fillStyle = "#5D4E37";
    ctx.beginPath();
    ctx.moveTo(-70, bob);
    ctx.quadraticCurveTo(-80, -20 + bob, -60, -35 + bob);
    ctx.lineTo(60, -35 + bob);
    ctx.quadraticCurveTo(85, -20 + bob, 70, bob + 5);
    ctx.quadraticCurveTo(0, 15 + bob, -70, bob);
    ctx.fill();
    
    // Hull stripes
    ctx.strokeStyle = "#3D2E17";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-65, -10 + bob);
    ctx.quadraticCurveTo(0, -5 + bob, 65, -10 + bob);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-60, -25 + bob);
    ctx.quadraticCurveTo(0, -20 + bob, 60, -25 + bob);
    ctx.stroke();
    
    // Dragon head prow
    ctx.fillStyle = "#8B4513";
    ctx.beginPath();
    ctx.moveTo(70, -35 + bob);
    ctx.quadraticCurveTo(90, -50 + bob, 85, -70 + bob);
    ctx.quadraticCurveTo(80, -65 + bob, 75, -70 + bob);
    ctx.quadraticCurveTo(70, -55 + bob, 65, -40 + bob);
    ctx.fill();
    // Dragon eye
    ctx.fillStyle = "#FFD700";
    ctx.beginPath();
    ctx.arc(78, -55 + bob, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.arc(79, -55 + bob, 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Tail curl at stern
    ctx.fillStyle = "#8B4513";
    ctx.beginPath();
    ctx.moveTo(-60, -35 + bob);
    ctx.quadraticCurveTo(-75, -55 + bob, -65, -75 + bob);
    ctx.quadraticCurveTo(-60, -65 + bob, -55, -45 + bob);
    ctx.fill();
    
    // Mast
    ctx.fillStyle = "#4A3C2A";
    ctx.fillRect(-5, -100 + bob, 10, 70);
    
    // Sail - red and white stripes (classic Viking)
    ctx.beginPath();
    ctx.moveTo(0, -95 + bob);
    ctx.lineTo(45, -80 + bob);
    ctx.lineTo(45, -40 + bob);
    ctx.lineTo(0, -35 + bob);
    ctx.closePath();
    ctx.fillStyle = "#C41E3A";
    ctx.fill();
    // White stripe
    ctx.fillStyle = "#FFF";
    ctx.fillRect(15, -75 + bob, 25, 15);
    
    // Oars (animated)
    ctx.strokeStyle = "#5D4E37";
    ctx.lineWidth = 3;
    [-40, -20, 0, 20].forEach((ox, i) => {
      const oarAngle = oarPhase * 0.3 + (i % 2 === 0 ? 0 : Math.PI);
      ctx.save();
      ctx.translate(ox, -5 + bob);
      ctx.rotate(0.4 + Math.sin(world.t * 8 + i) * 0.2);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, 40);
      ctx.stroke();
      // Oar blade
      ctx.fillStyle = "#5D4E37";
      ctx.fillRect(-5, 35, 10, 15);
      ctx.restore();
    });
    
    // Viking warrior on ship (small)
    ctx.fillStyle = "#556677";
    ctx.fillRect(-8, -50 + bob, 16, 20);
    ctx.fillStyle = "#ffdbac";
    ctx.beginPath();
    ctx.arc(0, -55 + bob, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#7f8c8d";
    ctx.beginPath();
    ctx.arc(0, -58 + bob, 7, Math.PI, 0);
    ctx.fill();
    
    // Shield on side
    ctx.fillStyle = "#C41E3A";
    ctx.beginPath();
    ctx.arc(35, -20 + bob, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#FFD700";
    ctx.beginPath();
    ctx.arc(35, -20 + bob, 5, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
  };

  const drawViking = (x, y) => {
    // Check if Viking ship mode is active
    if (world.powerups.vikingShip.active) {
      drawVikingShip(x, y);
      return;
    }
    
    ctx.save();
    ctx.translate(x, y);
    if (viking.faceplant > 0) ctx.rotate(viking.faceplant * -1);

    const bob = viking.onGround ? Math.sin(world.t * 12) * 4 : 0;
    const duckH = viking.ducking ? 0.6 : 1;

    ctx.fillStyle = "#556677";
    ctx.fillRect(-20, -50 * duckH + bob, 40, 50 * duckH);

    ctx.fillStyle = "#ffdbac";
    ctx.beginPath(); ctx.arc(0, -65 * duckH + bob, 15, 0, Math.PI * 2); ctx.fill();

    ctx.fillStyle = "#e67e22";
    ctx.beginPath(); ctx.moveTo(-12, -60 * duckH + bob); ctx.lineTo(12, -60 * duckH + bob); ctx.lineTo(0, -35 * duckH + bob); ctx.fill();

    ctx.fillStyle = "#7f8c8d";
    ctx.beginPath(); ctx.arc(0, -70 * duckH + bob, 16, Math.PI, 0); ctx.fill();
    ctx.fillStyle = "#ecf0f1";
    ctx.beginPath(); ctx.moveTo(-15, -75 * duckH + bob); ctx.lineTo(-25, -90 * duckH + bob); ctx.lineTo(-10, -80 * duckH + bob); ctx.fill();
    ctx.beginPath(); ctx.moveTo(15, -75 * duckH + bob); ctx.lineTo(25, -90 * duckH + bob); ctx.lineTo(10, -80 * duckH + bob); ctx.fill();

    ctx.restore();
  };

  const drawPlatform = (p) => {
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
    ctx.fillRect(0, p.height, p.width, 5);
    const gradient = ctx.createLinearGradient(0, 0, 0, p.height);
    gradient.addColorStop(0, "#64748b");
    gradient.addColorStop(1, "#475569");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, p.width, p.height);
    ctx.strokeStyle = "#334155";
    ctx.lineWidth = 2;
    ctx.strokeRect(0, 0, p.width, p.height);
    ctx.restore();
  };

  const drawEnemy = (e) => {
    if (e.defeated) return;
    ctx.save();
    ctx.translate(e.x, e.y);
    
    // Saxon/British warrior - enemy of Vikings
    // Body - blue tunic (British colors)
    ctx.fillStyle = "#1e3a5f";
    ctx.fillRect(-e.w/2 + 5, -e.h + 15, e.w - 10, e.h - 15);
    
    // Chainmail armor overlay
    ctx.fillStyle = "#6b7280";
    ctx.fillRect(-e.w/2 + 8, -e.h + 15, e.w - 16, 25);
    
    // Head
    ctx.fillStyle = "#d4a574";
    ctx.beginPath();
    ctx.arc(0, -e.h - 5, 14, 0, Math.PI * 2);
    ctx.fill();
    
    // Saxon helmet (round with nose guard)
    ctx.fillStyle = "#71717a";
    ctx.beginPath();
    ctx.arc(0, -e.h - 8, 16, Math.PI, 0);
    ctx.fill();
    // Nose guard
    ctx.fillRect(-2, -e.h - 10, 4, 15);
    
    // Eyes (angry)
    ctx.fillStyle = "#000";
    ctx.fillRect(-7, -e.h - 5, 4, 3);
    ctx.fillRect(3, -e.h - 5, 4, 3);
    
    // Shield (round Saxon shield with cross)
    ctx.fillStyle = "#dc2626";
    ctx.beginPath();
    ctx.arc(-e.w/2 - 8, -e.h/2, 18, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#fbbf24";
    ctx.lineWidth = 2;
    ctx.stroke();
    // Cross on shield
    ctx.strokeStyle = "#fbbf24";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-e.w/2 - 8, -e.h/2 - 12);
    ctx.lineTo(-e.w/2 - 8, -e.h/2 + 12);
    ctx.moveTo(-e.w/2 - 20, -e.h/2);
    ctx.lineTo(-e.w/2 + 4, -e.h/2);
    ctx.stroke();
    
    // Spear
    ctx.fillStyle = "#78350f";
    ctx.fillRect(e.w/2, -e.h + 5, 4, 50);
    // Spear tip
    ctx.fillStyle = "#a1a1aa";
    ctx.beginPath();
    ctx.moveTo(e.w/2 + 2, -e.h + 5);
    ctx.lineTo(e.w/2 - 3, -e.h - 10);
    ctx.lineTo(e.w/2 + 7, -e.h - 10);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
  };


  const drawHeart = (x, y, pulse, rotation) => {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    const size = 20 * pulse;
    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 2);
    gradient.addColorStop(0, "#ef4444AA");
    gradient.addColorStop(0.5, "#ef444460");
    gradient.addColorStop(1, "#ef444400");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(0, 0, size * 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#ef4444";
    ctx.shadowBlur = 20;
    ctx.shadowColor = "#ef4444";
    ctx.beginPath();
    ctx.moveTo(0, size * 0.3);
    ctx.bezierCurveTo(-size * 0.5, -size * 0.2, -size, size * 0.1, 0, size * 0.8);
    ctx.bezierCurveTo(size, size * 0.1, size * 0.5, -size * 0.2, 0, size * 0.3);
    ctx.fill();
    ctx.restore();
  };

  const drawGold = (g) => {
    ctx.save();
    ctx.translate(g.x, g.y);
    ctx.rotate(g.rotation);
    const size = 18;
    // Glow effect
    const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 2);
    glow.addColorStop(0, "#ffd70080");
    glow.addColorStop(0.5, "#ffd70040");
    glow.addColorStop(1, "#ffd70000");
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(0, 0, size * 2, 0, Math.PI * 2);
    ctx.fill();
    // Gold coin
    ctx.fillStyle = "#ffd700";
    ctx.shadowBlur = 15;
    ctx.shadowColor = "#ffd700";
    ctx.beginPath();
    ctx.arc(0, 0, size, 0, Math.PI * 2);
    ctx.fill();
    // Inner shine
    ctx.fillStyle = "#fff8dc";
    ctx.beginPath();
    ctx.arc(-size * 0.3, -size * 0.3, size * 0.4, 0, Math.PI * 2);
    ctx.fill();
    // $ symbol
    ctx.fillStyle = "#b8860b";
    ctx.font = `bold ${size}px Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("$", 0, 2);
    ctx.restore();
  };

  const drawShield = (x, y) => {
    ctx.save();
    ctx.translate(x, world.groundY);
    ctx.fillStyle = "#5d4037";
    ctx.beginPath(); ctx.arc(0, -22, 22, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = "#bdc3c7"; ctx.lineWidth = 3; ctx.stroke();
    ctx.fillStyle = "#7f8c8d";
    ctx.beginPath(); ctx.arc(0, -22, 6, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
  };

  const drawRock = (x, y) => {
    ctx.fillStyle = "#2c3e50";
    ctx.beginPath(); ctx.moveTo(x-25, world.groundY); ctx.lineTo(x, world.groundY-45); ctx.lineTo(x+25, world.groundY); ctx.fill();
  };

  const drawMead = (x, y) => {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = "#f1c40f";
    ctx.fillRect(-10, -15, 20, 25);
    ctx.fillStyle = "#fff";
    ctx.beginPath(); ctx.arc(-5, -15, 6, 0, Math.PI*2); ctx.arc(5, -15, 6, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = "#f1c40f"; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.arc(10, -2, 8, -Math.PI/2, Math.PI/2); ctx.stroke();
    ctx.restore();
  };

  const getPowerupColor = (type) => {
    const colors = {
      speedBoost: "#FF6B6B",
      invincibility: "#4ECDC4",
      scoreMultiplier: "#FFD93D",
      vikingShip: "#8B4513"
    };
    return colors[type] || "#FFF";
  };

  const getPowerupSymbol = (type) => {
    const symbols = {
      speedBoost: "‚ö°",
      invincibility: "üõ°",
      scoreMultiplier: "‚≠ê",
      vikingShip: "‚õµ"
    };
    return symbols[type] || "?";
  };

  const activatePowerup = (type) => {
    const p = world.powerups[type];
    p.active = true;
    
    if (type === "vikingShip") {
      p.timeLeft = rand(5, 10); // Random 5-10 seconds
      playSFX('shipStart');
    } else if (type === "speedBoost") {
      p.timeLeft = 10;
      playSFX('speedBoost');
    } else if (type === "invincibility") {
      p.timeLeft = 10;
      playSFX('invincibility');
    } else {
      p.timeLeft = 10;
    }
    
    if (type === "scoreMultiplier") {
      p.multiplier = 2;
    }
    updateHUD();
  };

  const drawPowerup = (x, y, type, rotation, pulse) => {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    const size = 22 * pulse;
    const color = getPowerupColor(type);
    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 2);
    gradient.addColorStop(0, color + "AA");
    gradient.addColorStop(0.5, color + "60");
    gradient.addColorStop(1, color + "00");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(0, 0, size * 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(0, 0, size, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#FFF";
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.fillStyle = "#FFF";
    ctx.font = `bold ${size * 0.9}px Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(getPowerupSymbol(type), 0, 0);
    ctx.restore();
  };

  const drawParticle = (p) => {
    ctx.save();
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.shadowBlur = 10;
    ctx.shadowColor = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  };

  const checkPlatformCollision = (dt) => {
    const vikingHeight = viking.ducking ? 42 : 70; // Ducking makes viking shorter
    const vikingWidth = 40;
    const vikingLeft = viking.x - vikingWidth/2;
    const vikingRight = viking.x + vikingWidth/2;
    const vikingTop = viking.y - vikingHeight;
    const vikingBottom = viking.y;
    
    for (const p of Platforms) {
      const platformLeft = p.x;
      const platformRight = p.x + p.width;
      const platformTop = p.y;
      const platformBottom = p.y + p.height;
      
      // Check horizontal overlap
      if (vikingRight > platformLeft && vikingLeft < platformRight) {
        // Low platform collision - must duck or jump over
        if (p.isLow) {
          // Check if landing ON TOP of low platform (safe - like regular platform)
          if (vikingBottom <= platformTop + 10 && vikingBottom + viking.vy * dt >= platformTop && viking.vy >= 0) {
            // Landing on top is safe - treat like regular platform
            viking.y = platformTop;
            viking.vy = 0;
            viking.onGround = true;
            viking.jumpsUsed = 0;
            return true;
          }
          
          // If viking hits low platform from SIDE or BELOW while standing, lose life
          // Only damage if NOT landing from above and NOT ducking
          if (!viking.ducking && vikingBottom > platformTop && vikingTop < platformBottom) {
            // Check if hitting from side (not landing from above)
            if (vikingBottom > platformTop + 10 || viking.vy < 0) {
              if (!world.powerups.invincibility.active && !world.powerups.vikingShip.active) {
                world.lives--;
                addParticle(viking.x, viking.y, "#ef4444", 15);
                playSFX('damage');
                updateHUD();
                
                if (world.lives <= 0) {
                  world.over = true;
                  viking.faceplant = 1.5;
                  if (statePill) statePill.textContent = "Game Over";
                  HighScoreManager.saveScore(world.score);
                  playSFX('gameover');
                  setTimeout(() => { 
                    if (overlay) {
                      overlay.style.display = "grid";
                      overlay.style.visibility = "visible";
                      overlay.style.opacity = "1";
                    }
                    const overlayTitle = $("overlayTitle");
                    const overlayText = $("overlayText");
                    if (overlayTitle) overlayTitle.textContent = "Game Over";
                    if (overlayText) overlayText.textContent = `Hit a low platform!\nFinal Score: ${Math.floor(world.score).toLocaleString()}\nMead Collected: ${world.mead}`;
                    if (startBtn) startBtn.textContent = "Play Again";
                  }, 1200);
                } else {
                  world.powerups.invincibility.active = true;
                  world.powerups.invincibility.timeLeft = 2;
                }
              }
              return false; // Don't land on low platform from side
            }
          }
          // Can pass under if ducking
          return false;
        }
        
        // Regular platform - landing from above
        if (vikingBottom <= platformTop + 10 && vikingBottom + viking.vy * dt >= platformTop && viking.vy >= 0) {
          viking.y = platformTop;
          viking.vy = 0;
          viking.onGround = true;
          viking.jumpsUsed = 0;
          return true;
        }
        // Hitting platform from below
        if (vikingTop + viking.vy * dt <= platformBottom && vikingTop >= platformBottom - 10 && viking.vy < 0) {
          viking.vy = 0;
          viking.y = platformBottom + vikingHeight;
          return true;
        }
      }
    }
    return false;
  };

  const update = (dt) => {
    if (!dt || dt <= 0 || dt > 1) return; // Safety check
    if (!world.started || world.paused || world.over) {
      Input.jumpJustPressed = false;
      return;
    }
    if (!H || H === 0) return; // Safety check

    world.t += dt;
    
    const baseSpeed = 230;
    world.speed = Math.min(400, world.speed + 3 * dt);
    if (world.speed > baseSpeed) {
      world.speed = Math.max(baseSpeed, world.speed - 3 * dt);
    }
    
    // Speed boost: 1.5x movement speed when active
    // Viking ship: 1.8x speed (faster than speed boost!)
    let speedMultiplier = 1.0;
    if (world.powerups.vikingShip.active) {
      speedMultiplier = 1.8;
    } else if (world.powerups.speedBoost.active) {
      speedMultiplier = 1.5;
    }
    const actualSpeed = world.speed * speedMultiplier;
    viking.x += actualSpeed * dt;
    const scoreMultiplier = world.powerups.scoreMultiplier.active ? world.powerups.scoreMultiplier.multiplier : 1;
    world.score += world.speed * 0.015 * dt * scoreMultiplier;
    
    for (const key in world.powerups) {
      const p = world.powerups[key];
      if (p.active) {
        p.timeLeft -= dt;
        if (p.timeLeft <= 0) {
          p.active = false;
          if (key === "scoreMultiplier") p.multiplier = 1;
          updateHUD();
        }
      }
    }

    // Jump logic
    if (Input.jumpJustPressed && !viking.ducking && viking.jumpsUsed < viking.maxJumps) {
      viking.vy = -680;
      viking.onGround = false;
      viking.jumpsUsed++;
      playSFX('jump');
      Input.jumpJustPressed = false;
    }
    
    viking.vy += 1600 * dt;
    viking.y += viking.vy * dt;

    const onPlatform = checkPlatformCollision(dt);
    
    // Ground collision only if not on platform
    if (!onPlatform) {
    if (viking.y >= world.groundY) {
      viking.y = world.groundY;
      viking.vy = 0;
      viking.onGround = true;
        viking.jumpsUsed = 0;
      } else {
        viking.onGround = false;
      }
    }

    // Ducking works in air or on ground
    viking.ducking = Input.duck;

    // Spawn logic - REDUCED FREQUENCY
    if (viking.x > world.nextObstacleAt - W) {
      spawnObstacle(world.nextObstacleAt);
      world.nextObstacleAt += rand(425, 675);
    }
    if (viking.x > world.nextMeadAt - W) {
      spawnMead(world.nextMeadAt);
      world.nextMeadAt += rand(400, 600);
    }
    if (viking.x > world.nextPowerupAt - W) {
      spawnPowerup(world.nextPowerupAt);
      world.nextPowerupAt += rand(6000, 10000); // MUCH RARER
    }
    if (viking.x > world.nextPlatformAt - W) {
      spawnPlatform(world.nextPlatformAt);
      world.nextPlatformAt += rand(350, 600);
    }
    if (viking.x > world.nextEnemyAt - W) {
      spawnEnemy(world.nextEnemyAt);
      world.nextEnemyAt += rand(600, 1050);
    }
    if (viking.x > world.nextHeartAt - W) {
      if (world.lives < 5) { // Only spawn hearts if lives < 5
        spawnHeart(world.nextHeartAt);
      }
      world.nextHeartAt += rand(1400, 2400);
    }
    if (viking.x > world.nextGoldAt - W) {
      spawnGold(world.nextGoldAt);
      world.nextGoldAt += rand(2000, 4000); // Rare gold spawns
    }
    
    // Update all objects
    for (const o of Obstacles) o.x -= world.speed * dt;
    for (const p of Platforms) p.x -= world.speed * dt;
    
    for (const e of Enemies) {
      if (!e.defeated) {
        e.x -= world.speed * 0.4 * dt;
        if (e.x < viking.x - W - 200) e.defeated = true;
      }
    }
    
    
    for (const h of Hearts) {
      if (!h.taken) {
        h.rotation += dt * 2;
        h.pulse = Math.sin(world.t * 8) * 0.2 + 1;
        h.x -= world.speed * dt;
      }
    }
    
    for (const g of Golds) {
      if (!g.taken) {
        g.rotation += dt * 3;
        g.x -= world.speed * dt;
      }
    }
    
    for (const p of Powerups) {
      if (!p.taken) {
        p.rotation += dt * 4;
        p.pulse = Math.sin(world.t * 10) * 0.25 + 1;
        p.x -= world.speed * dt;
      }
    }
    
    for (const m of Meads) {
      if (!m.taken) {
        m.rotation += dt * 2;
        m.x -= world.speed * dt;
      }
    }
    
    for (let i = Particles.length - 1; i >= 0; i--) {
      const p = Particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 350 * dt;
      p.life -= dt * 2.5;
      if (p.life <= 0) Particles.splice(i, 1);
    }

    // Collisions - Obstacles
    for (const o of Obstacles) {
      if (!o.hit && viking.x > o.x - 25 && viking.x < o.x + 25 && viking.y > world.groundY - 45 && !viking.ducking) {
        // Viking ship destroys everything!
        if (world.powerups.vikingShip.active) {
          o.hit = true;
          addParticle(o.x, world.groundY - 20, "#8B4513", 20);
          addParticle(o.x, world.groundY - 30, "#4A90D9", 15);
          playSFX('shipDestroy');
          world.score += 100; // Bonus for destroying
        } else if (!world.powerups.invincibility.active) {
          o.hit = true;
          world.lives--;
          addParticle(o.x, world.groundY - 20, "#ef4444", 15);
          playSFX('damage');
          updateHUD();
          
          if (world.lives <= 0) {
        world.over = true;
        viking.faceplant = 1.5;
            statePill.textContent = "Game Over";
            HighScoreManager.saveScore(world.score);
        playSFX('gameover');
            setTimeout(() => { 
              if (overlay) {
                overlay.style.display = "grid";
                overlay.style.visibility = "visible";
                overlay.style.opacity = "1";
              }
              const overlayTitle = $("overlayTitle");
              const overlayText = $("overlayText");
              if (overlayTitle) overlayTitle.textContent = "Game Over";
              if (overlayText) overlayText.textContent = `Final Score: ${Math.floor(world.score).toLocaleString()}\nMead Collected: ${world.mead}`;
              if (startBtn) startBtn.textContent = "Play Again";
            }, 1200);
          } else {
            world.powerups.invincibility.active = true;
            world.powerups.invincibility.timeLeft = 2;
          }
        } else {
          addParticle(o.x, world.groundY - 20, "#4ECDC4", 12);
          beep("sine", 400, 0.15);
        }
      }
    }

    // Collisions - Enemies - MARIO STYLE: Jump on them to kill!
    for (const e of Enemies) {
      if (!e.defeated && !e.hit) {
        const distX = Math.abs(viking.x - e.x);
        const vikingHeight = viking.ducking ? 42 : 70;
        const vikingTop = viking.y - vikingHeight;
        const vikingBottom = viking.y;
        const enemyTop = e.y - e.h;
        const enemyBottom = e.y;
        
        // Basic overlap check - are they colliding at all?
        // Ship has wider collision area
        const shipWidth = world.powerups.vikingShip.active ? 90 : 45;
        const horizontalOverlap = distX < shipWidth;
        const verticalOverlap = vikingBottom > enemyTop && vikingTop < enemyBottom;
        
        // Viking ship destroys everything on contact!
        if (world.powerups.vikingShip.active && horizontalOverlap) {
          e.defeated = true;
          e.hit = true;
          world.score += 200; // Bonus for destroying enemies
          addParticle(e.x, e.y - e.h/2, "#8B4513", 25);
          addParticle(e.x, e.y - e.h/2, "#4A90D9", 15);
          playSFX('shipDestroyEnemy');
          continue;
        }
        
        // Check if viking is coming from above (stomping)
        const comingFromAbove = viking.vy > 0 && 
                               vikingBottom <= enemyTop + 25 &&
                               vikingBottom >= enemyTop - 15;
        
        if (horizontalOverlap && comingFromAbove) {
          // STOMP! Kill the enemy Mario-style
          e.defeated = true;
          e.hit = true;
          viking.vy = -750; // High bounce after stomp - higher than normal jump!
          world.score += 150;
          addParticle(e.x, e.y - e.h/2, "#fbbf24", 20);
          playSFX('stomp');
          updateHUD();
        } else if (horizontalOverlap && verticalOverlap) {
          // Side/front collision - YOU TAKE DAMAGE
          if (!world.powerups.invincibility.active) {
            e.hit = true;
            world.lives--;
            addParticle(viking.x, viking.y, "#ef4444", 25);
            playSFX('damage');
            updateHUD();
              
            if (world.lives <= 0) {
              world.over = true;
              viking.faceplant = 1.5;
              if (statePill) statePill.textContent = "Game Over";
              HighScoreManager.saveScore(world.score, localStorage.getItem('playerName') || 'Player');
              playSFX('gameover');
              setTimeout(() => { 
                if (overlay) {
                  overlay.style.display = "grid";
                  overlay.style.visibility = "visible";
                  overlay.style.opacity = "1";
                }
                const overlayTitle = $("overlayTitle");
                const overlayText = $("overlayText");
                if (overlayTitle) overlayTitle.textContent = "Game Over";
                if (overlayText) overlayText.textContent = `You were defeated!\nFinal Score: ${Math.floor(world.score).toLocaleString()}\nMead Collected: ${world.mead}`;
                if (startBtn) startBtn.textContent = "Play Again";
              }, 1200);
            } else {
              world.powerups.invincibility.active = true;
              world.powerups.invincibility.timeLeft = 1.5;
            }
          } else {
            e.hit = true; // Passed while invincible
          }
        }
      }
    }

    // Collisions - Meads
    for (const m of Meads) {
      if (!m.taken && Math.hypot(viking.x - m.x, (viking.y-30) - m.y) < 45) {
        m.taken = true;
        world.mead++;
        world.score += 75 * scoreMultiplier;
        addParticle(m.x, m.y, "#FFD700", 8);
        playSFX('mead');
        updateHUD();
      }
    }
    
    
    // Collisions - Powerups
    for (const p of Powerups) {
      if (!p.taken && Math.hypot(viking.x - p.x, (viking.y-30) - p.y) < 40) {
        p.taken = true;
        activatePowerup(p.type);
        addParticle(p.x, p.y, getPowerupColor(p.type), 15);
        playSFX('powerup');
      }
    }

    // Collisions - Hearts
    for (const h of Hearts) {
      if (!h.taken && Math.hypot(viking.x - h.x, (viking.y-30) - h.y) < 40) {
        h.taken = true;
        world.lives++; // No max cap - unlimited storage
        addParticle(h.x, h.y, "#ef4444", 20);
        playSFX('heart');
        updateHUD();
      }
    }
    
    // Collisions - Gold
    for (const g of Golds) {
      if (!g.taken && Math.hypot(viking.x - g.x, (viking.y-30) - g.y) < 45) {
        g.taken = true;
        world.score += g.value * scoreMultiplier;
        addParticle(g.x, g.y, "#ffd700", 25);
        playSFX('gold');
        updateHUD();
      }
    }

    world.camX = viking.x - 150;
    updateHUD();
  };

  const draw = () => {
    ctx.clearRect(0, 0, W, H);
    
    const bgGradient = ctx.createLinearGradient(0, 0, 0, H);
    bgGradient.addColorStop(0, "#0a0a0a");
    bgGradient.addColorStop(1, "#1a1a1a");
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, W, H);
    
    ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
    ctx.lineWidth = 2;
    for (let i = 0; i < 5; i++) {
      const y = world.groundY + (H - world.groundY) * (i / 5) + Math.sin(world.t * 2 + i) * 3;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(W, y);
      ctx.stroke();
    }

    ctx.strokeStyle = "rgba(255, 255, 255, 0.15)"; 
    ctx.lineWidth = 3; 
    ctx.beginPath(); 
    ctx.moveTo(0, world.groundY); 
    ctx.lineTo(W, world.groundY); 
    ctx.stroke();

    ctx.save();
    ctx.translate(-world.camX, 0);

    for (const p of Platforms) {
      if (p.x > viking.x - W - 100 && p.x < viking.x + W + 100) {
        drawPlatform(p);
      }
    }


    for (const h of Hearts) {
      if (!h.taken && h.x > viking.x - W - 100 && h.x < viking.x + W + 100) {
        drawHeart(h.x, h.y, h.pulse, h.rotation);
      }
    }

    for (const g of Golds) {
      if (!g.taken && g.x > viking.x - W - 100 && g.x < viking.x + W + 100) {
        drawGold(g);
      }
    }

    for (const e of Enemies) {
      if (!e.defeated && e.x > viking.x - W - 100 && e.x < viking.x + W + 100) {
        drawEnemy(e);
      }
    }

    for (const m of Meads) if (!m.taken && m.x > viking.x - W - 100 && m.x < viking.x + W + 100) drawMead(m.x, m.y);
    for (const p of Powerups) if (!p.taken && p.x > viking.x - W - 100 && p.x < viking.x + W + 100) drawPowerup(p.x, p.y, p.type, p.rotation, p.pulse);
    for (const o of Obstacles) {
      if (o.x > viking.x - W - 100 && o.x < viking.x + W + 100) {
      if (o.type === "shield") drawShield(o.x, o.y);
      else drawRock(o.x, o.y);
      }
    }

    if (world.powerups.invincibility.active) {
      ctx.save();
      ctx.globalAlpha = 0.4 + Math.sin(world.t * 25) * 0.2;
      ctx.strokeStyle = "#4ECDC4";
      ctx.lineWidth = 5;
      ctx.shadowBlur = 20;
      ctx.shadowColor = "#4ECDC4";
      ctx.beginPath();
      ctx.arc(viking.x, viking.y - 30, 45, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
    
    // Viking ship water wake effect
    if (world.powerups.vikingShip.active) {
      ctx.save();
      ctx.globalAlpha = 0.3 + Math.sin(world.t * 10) * 0.1;
      ctx.strokeStyle = "#4A90D9";
      ctx.lineWidth = 3;
      ctx.shadowBlur = 15;
      ctx.shadowColor = "#4A90D9";
      // Draw wake lines behind ship
      ctx.beginPath();
      ctx.moveTo(viking.x - 80, viking.y + 15);
      ctx.quadraticCurveTo(viking.x - 120, viking.y + 25, viking.x - 160, viking.y + 20);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(viking.x - 80, viking.y + 20);
      ctx.quadraticCurveTo(viking.x - 130, viking.y + 35, viking.x - 180, viking.y + 25);
      ctx.stroke();
      ctx.restore();
    }

    drawViking(viking.x, viking.y);
    ctx.restore();
    
    ctx.save();
    ctx.translate(-world.camX, 0);
    for (const p of Particles) drawParticle(p);
    ctx.restore();
    
    if (world.started && !world.paused && !world.over) {
      let yPos = 100;
      for (const key in world.powerups) {
        const p = world.powerups[key];
        if (p.active) {
          ctx.save();
          ctx.fillStyle = getPowerupColor(key);
          ctx.font = "600 16px -apple-system";
          ctx.textAlign = "left";
          ctx.shadowBlur = 8;
          ctx.shadowColor = getPowerupColor(key);
          ctx.fillText(`${getPowerupSymbol(key)} ${Math.ceil(p.timeLeft)}s`, 24, yPos);
          ctx.restore();
          yPos += 26;
        }
      }
    }
  };

  let last = performance.now();
  const tick = (t) => {
    const dt = Math.min(0.1, (t - last) / 1000);
    last = t;
    update(dt);
    draw();
    requestAnimationFrame(tick);
  };

  startBtn.onclick = () => {
    try {
      // Save player name
      const nameInput = $("playerNameInput");
      if (nameInput && nameInput.value.trim()) {
        localStorage.setItem('playerName', nameInput.value.trim());
      }
      
      // If game is over, reset and start immediately
      if (world.over) {
        resetWorld();
        // Start the game immediately after reset
        setTimeout(() => {
          start();
        }, 100);
      } else {
        start();
      }
    } catch (e) {
      console.error("Error in startBtn click:", e);
      resetWorld();
      setTimeout(() => {
        start();
      }, 100);
    }
  };
  
  // Load player name on startup
  const nameInput = $("playerNameInput");
  if (nameInput) {
    const savedName = localStorage.getItem('playerName');
    if (savedName) {
      nameInput.value = savedName;
    }
  }
  
  restartBtn.onclick = () => { 
    try {
      resetWorld(); 
    } catch (e) {
      console.error("Error in restartBtn click:", e);
    }
  };
  
  pauseBtn.onclick = () => { 
    if (!world.started || world.over) return;
    world.paused = !world.paused; 
    pauseBtn.textContent = world.paused ? "Resume" : "Pause";
    statePill.textContent = world.paused ? "Paused" : "Playing";
    
    // Hide/show gaze zone indicator when paused
    if (gazeZoneIndicator && eyeTrackingEnabled) {
      gazeZoneIndicator.style.display = world.paused ? 'none' : 'block';
    }
  };
  
  soundBtn.onclick = () => { 
    OPT.sound = !OPT.sound; 
    soundBtn.textContent = OPT.sound ? "Sound: On" : "Sound: Off";
    
    // Control Viking music
    if (OPT.sound) {
      if (!musicPlaying) {
        startVikingMusic();
      } else {
        setMusicVolume(false);
      }
    } else {
      setMusicVolume(true);
    }
  };

  const highscoreBtn = $("highscoreBtn");
  const highscoreModal = $("highscoreModal");
  const highscoreTabs = document.querySelectorAll(".highscore-tab");
  const closeHighscoreBtn = $("closeHighscoreBtn");
  
  highscoreBtn.onclick = () => {
    highscoreModal.classList.add("active");
    HighScoreManager.displayScores('alltime');
  };
  
  highscoreTabs.forEach(tab => {
    tab.onclick = () => {
      highscoreTabs.forEach(t => t.classList.remove("active"));
      tab.classList.add("active");
      const period = tab.dataset.period;
      HighScoreManager.displayScores(period);
    };
  });
  
  if (closeHighscoreBtn) {
    closeHighscoreBtn.onclick = () => {
      highscoreModal.classList.remove("active");
    };
  }
  
  highscoreModal.onclick = (e) => {
    if (e.target === highscoreModal) {
      highscoreModal.classList.remove("active");
    }
  };

  // ==========================================
  // EYE TRACKING WITH MEDIAPIPE FACE LANDMARKER + rPPG
  // ==========================================
  
  const eyeTrackBtn = $("eyeTrackBtn");
  const calibrationOverlay = $("calibrationOverlay");
  const calibrationPoints = document.querySelectorAll(".calibration-point");
  const calibrationStatus = $("calibrationStatus");
  const finishCalibrationBtn = $("finishCalibrationBtn");
  const eyeTrackingIndicator = $("eyeTrackingIndicator");
  const gazeCursor = $("gazeCursor");
  const gazeZoneIndicator = $("gazeZoneIndicator");
  
  let eyeTrackingEnabled = false;
  let calibrationClicks = 0;
  let lastGazeAction = 0;
  
  // MediaPipe Face Landmarker
  let faceLandmarker = null;
  let videoElement = null;
  let videoStream = null;
  let animationFrameId = null;
  
  // Gaze calibration thresholds (learned from calibration)
  const gazeCalibration = {
    upThreshold: 0.35,    // Iris position ratio for "looking up"
    downThreshold: 0.65,  // Iris position ratio for "looking down"
    samples: [],          // Calibration samples
    isCalibrating: false
  };
  
  // rPPG Heart Rate Detection
  const rPPG = {
    signalBuffer: [],      // Green channel samples
    timestamps: [],        // Sample timestamps
    bufferSize: 300,       // ~10 seconds at 30fps
    bpm: 0,
    lastBPMUpdate: 0,
    smoothedBPM: 0
  };
  
  // Check if MediaPipe is available
  const mediapipeAvailable = typeof window.tasksVision !== 'undefined';
  
  if (!mediapipeAvailable) {
    console.warn("MediaPipe not loaded - eye tracking disabled");
    if (eyeTrackBtn) {
      eyeTrackBtn.textContent = "üëÅÔ∏è Eye Tracking Unavailable";
      eyeTrackBtn.disabled = true;
      eyeTrackBtn.style.opacity = "0.5";
    }
  }
  
  // Initialize MediaPipe Face Landmarker
  const initFaceLandmarker = async () => {
    try {
      const { FaceLandmarker, FilesetResolver } = window.tasksVision;
      
      const filesetResolver = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );
      
      faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
          delegate: "GPU"
        },
        outputFaceBlendshapes: false,
        outputFacialTransformationMatrixes: false,
        runningMode: "VIDEO",
        numFaces: 1
      });
      
      console.log("MediaPipe Face Landmarker initialized");
      return true;
    } catch (e) {
      console.error("Error initializing Face Landmarker:", e);
      return false;
    }
  };
  
  // Start camera
  const startCamera = async () => {
    try {
      // Create hidden video element
      videoElement = document.createElement('video');
      videoElement.setAttribute('autoplay', '');
      videoElement.setAttribute('playsinline', '');
      videoElement.style.position = 'fixed';
      videoElement.style.top = '10px';
      videoElement.style.right = '10px';
      videoElement.style.width = '160px';
      videoElement.style.height = '120px';
      videoElement.style.borderRadius = '8px';
      videoElement.style.border = '2px solid #4ade80';
      videoElement.style.zIndex = '9999';
      videoElement.style.transform = 'scaleX(-1)'; // Mirror
      document.body.appendChild(videoElement);
      
      videoStream = await navigator.mediaDevices.getUserMedia({
        video: { 
          width: { ideal: 640 },
          height: { ideal: 480 },
          facingMode: "user"
        }
      });
      
      videoElement.srcObject = videoStream;
      await videoElement.play();
      
      console.log("Camera started");
      return true;
    } catch (e) {
      console.error("Error starting camera:", e);
      alert("Could not access camera. Please allow camera access.");
      return false;
    }
  };
  
  // Calculate gaze direction from iris landmarks
  const calculateGaze = (landmarks) => {
    if (!landmarks || landmarks.length < 478) return { vertical: 0.5, horizontal: 0.5 };
    
    // Key landmarks for iris and eye corners
    // Left eye: corners 33 (outer), 133 (inner), iris center 468
    // Right eye: corners 362 (outer), 263 (inner), iris center 473
    
    const leftIris = landmarks[468];
    const leftOuter = landmarks[33];
    const leftInner = landmarks[133];
    const leftTop = landmarks[159];
    const leftBottom = landmarks[145];
    
    const rightIris = landmarks[473];
    const rightOuter = landmarks[362];
    const rightInner = landmarks[263];
    const rightTop = landmarks[386];
    const rightBottom = landmarks[374];
    
    // Calculate horizontal position (0 = left, 1 = right)
    const leftEyeWidth = Math.abs(leftInner.x - leftOuter.x);
    const leftIrisHoriz = (leftIris.x - leftOuter.x) / leftEyeWidth;
    
    const rightEyeWidth = Math.abs(rightInner.x - rightOuter.x);
    const rightIrisHoriz = (rightIris.x - rightOuter.x) / rightEyeWidth;
    
    const horizontal = (leftIrisHoriz + rightIrisHoriz) / 2;
    
    // Calculate vertical position (0 = up, 1 = down)
    const leftEyeHeight = Math.abs(leftBottom.y - leftTop.y);
    const leftIrisVert = (leftIris.y - leftTop.y) / leftEyeHeight;
    
    const rightEyeHeight = Math.abs(rightBottom.y - rightTop.y);
    const rightIrisVert = (rightIris.y - rightTop.y) / rightEyeHeight;
    
    const vertical = (leftIrisVert + rightIrisVert) / 2;
    
    return { vertical: Math.max(0, Math.min(1, vertical)), horizontal: Math.max(0, Math.min(1, horizontal)) };
  };
  
  // Extract forehead ROI for rPPG
  const extractForeheadROI = (landmarks, videoWidth, videoHeight) => {
    if (!landmarks || landmarks.length < 478) return null;
    
    // Forehead landmarks: 10 (center top), 67 (left), 109 (center), 338 (right)
    const forehead = [landmarks[10], landmarks[67], landmarks[109], landmarks[338]];
    
    // Calculate bounding box
    const xs = forehead.map(p => p.x * videoWidth);
    const ys = forehead.map(p => p.y * videoHeight);
    
    return {
      x: Math.min(...xs),
      y: Math.min(...ys),
      width: Math.max(...xs) - Math.min(...xs),
      height: Math.max(...ys) - Math.min(...ys)
    };
  };
  
  // Process rPPG signal and calculate heart rate
  const processRPPG = (greenValue, timestamp) => {
    rPPG.signalBuffer.push(greenValue);
    rPPG.timestamps.push(timestamp);
    
    // Keep buffer at fixed size
    while (rPPG.signalBuffer.length > rPPG.bufferSize) {
      rPPG.signalBuffer.shift();
      rPPG.timestamps.shift();
    }
    
    // Need at least 5 seconds of data
    if (rPPG.signalBuffer.length < 150) return;
    
    // Update BPM every 2 seconds
    if (timestamp - rPPG.lastBPMUpdate < 2000) return;
    rPPG.lastBPMUpdate = timestamp;
    
    // Simple peak detection using zero-crossing of derivative
    const signal = [...rPPG.signalBuffer];
    
    // Detrend (remove DC component)
    const mean = signal.reduce((a, b) => a + b, 0) / signal.length;
    const detrended = signal.map(v => v - mean);
    
    // Simple moving average filter
    const windowSize = 5;
    const filtered = [];
    for (let i = 0; i < detrended.length; i++) {
      let sum = 0;
      let count = 0;
      for (let j = Math.max(0, i - windowSize); j <= Math.min(detrended.length - 1, i + windowSize); j++) {
        sum += detrended[j];
        count++;
      }
      filtered.push(sum / count);
    }
    
    // Count peaks (zero crossings from negative to positive)
    let peaks = 0;
    for (let i = 1; i < filtered.length; i++) {
      if (filtered[i - 1] < 0 && filtered[i] >= 0) {
        peaks++;
      }
    }
    
    // Calculate BPM
    const duration = (rPPG.timestamps[rPPG.timestamps.length - 1] - rPPG.timestamps[0]) / 1000; // seconds
    const rawBPM = (peaks / duration) * 60;
    
    // Clamp to realistic range (40-200 BPM)
    const clampedBPM = Math.max(40, Math.min(200, rawBPM));
    
    // Smooth with exponential moving average
    rPPG.smoothedBPM = rPPG.smoothedBPM === 0 
      ? clampedBPM 
      : rPPG.smoothedBPM * 0.7 + clampedBPM * 0.3;
    
    rPPG.bpm = Math.round(rPPG.smoothedBPM);
    
    // Update BPM display
    const bpmValue = $("bpmValue");
    if (bpmValue) {
      bpmValue.textContent = rPPG.bpm;
    }
  };
  
  // Main processing loop
  const processFrame = async () => {
    if (!faceLandmarker || !videoElement || videoElement.readyState < 2) {
      animationFrameId = requestAnimationFrame(processFrame);
      return;
    }
    
    const startTimeMs = performance.now();
    const results = faceLandmarker.detectForVideo(videoElement, startTimeMs);
    
    if (results.faceLandmarks && results.faceLandmarks.length > 0) {
      const landmarks = results.faceLandmarks[0];
      
      // Calculate gaze
      const gaze = calculateGaze(landmarks);
      
      // During calibration, collect samples
      if (gazeCalibration.isCalibrating) {
        gazeCalibration.samples.push(gaze.vertical);
      }
      
      // Update gaze cursor position
      if (gazeCursor && eyeTrackingEnabled) {
        const x = gaze.horizontal * window.innerWidth;
        const y = gaze.vertical * window.innerHeight;
        gazeCursor.style.left = x + 'px';
        gazeCursor.style.top = y + 'px';
        gazeCursor.classList.add("active");
      }
      
      // Determine gaze direction
      const isLookingUp = gaze.vertical < gazeCalibration.upThreshold;
      const isLookingDown = gaze.vertical > gazeCalibration.downThreshold;
      
      // Show gaze zone indicator
      if (eyeTrackingEnabled && gazeZoneIndicator) {
        if (isLookingUp) {
          gazeZoneIndicator.style.display = 'block';
          gazeZoneIndicator.style.background = 'rgba(74, 222, 128, 0.9)';
          gazeZoneIndicator.textContent = 'üëÜ JUMP ZONE';
        } else if (isLookingDown) {
          gazeZoneIndicator.style.display = 'block';
          gazeZoneIndicator.style.background = 'rgba(251, 191, 36, 0.9)';
          gazeZoneIndicator.textContent = 'üëá DUCK ZONE';
        } else {
          gazeZoneIndicator.style.display = 'block';
          gazeZoneIndicator.style.background = 'rgba(100, 100, 100, 0.7)';
          gazeZoneIndicator.textContent = 'üëÄ CENTER';
        }
      }
      
      // Control game
      const now = Date.now();
      if (eyeTrackingEnabled && world.started && !world.paused && !world.over) {
        if (isLookingUp && now - lastGazeAction > 200) {
          Input.jumpJustPressed = true;
          Input.jump = true;
          Input.duck = false;
          lastGazeAction = now;
          if (gazeCursor) gazeCursor.style.background = 'rgba(74, 222, 128, 0.8)';
        } else if (isLookingDown) {
          Input.duck = true;
          Input.jump = false;
          Input.jumpJustPressed = false;
          if (gazeCursor) gazeCursor.style.background = 'rgba(251, 191, 36, 0.8)';
        } else {
          Input.duck = false;
          if (now - lastGazeAction > 150) {
            Input.jump = false;
            Input.jumpJustPressed = false;
          }
          if (gazeCursor) gazeCursor.style.background = 'rgba(255, 107, 107, 0.6)';
        }
      }
      
      // rPPG: Extract green channel from forehead
      if (eyeTrackingEnabled) {
        try {
          const roi = extractForeheadROI(landmarks, videoElement.videoWidth, videoElement.videoHeight);
          if (roi && roi.width > 10 && roi.height > 10) {
            // Create canvas to extract pixel data
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = roi.width;
            tempCanvas.height = roi.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(
              videoElement,
              roi.x, roi.y, roi.width, roi.height,
              0, 0, roi.width, roi.height
            );
            
            const imageData = tempCtx.getImageData(0, 0, roi.width, roi.height);
            const pixels = imageData.data;
            
            // Calculate average green channel value
            let greenSum = 0;
            let count = 0;
            for (let i = 1; i < pixels.length; i += 4) {
              greenSum += pixels[i]; // Green channel
              count++;
            }
            const avgGreen = greenSum / count;
            
            processRPPG(avgGreen, startTimeMs);
          }
        } catch (e) {
          // Ignore rPPG errors
        }
      }
    }
    
    animationFrameId = requestAnimationFrame(processFrame);
  };
  
  // Eye tracking button click - start calibration
  if (eyeTrackBtn && mediapipeAvailable) {
    eyeTrackBtn.onclick = async () => {
      // Show calibration overlay
      if (calibrationOverlay) {
        calibrationOverlay.classList.add("active");
      }
      
      // Reset calibration
      calibrationClicks = 0;
      gazeCalibration.samples = [];
      calibrationPoints.forEach(p => {
        p.classList.remove("clicked");
        p.textContent = "";
        p.style.transform = "";
      });
      if (calibrationStatus) {
        calibrationStatus.textContent = "Initializing camera and face tracking...";
      }
      
      // Initialize MediaPipe and camera
      const mpInit = await initFaceLandmarker();
      if (!mpInit) {
        calibrationOverlay.classList.remove("active");
        alert("Could not initialize face tracking.");
        return;
      }
      
      const camInit = await startCamera();
      if (!camInit) {
        calibrationOverlay.classList.remove("active");
        return;
      }
      
      // Start processing
      gazeCalibration.isCalibrating = true;
      processFrame();
      
      if (calibrationStatus) {
        calibrationStatus.textContent = "Look at each point and click it 5 times (0/9)";
      }
    };
  }
  
  // Calibration point clicks
  calibrationPoints.forEach(point => {
    let clickCount = 0;
    point.onclick = () => {
      clickCount++;
      
      // Need 5 clicks per point
      if (clickCount >= 5 && !point.classList.contains("clicked")) {
        point.classList.add("clicked");
        calibrationClicks++;
        
        if (calibrationStatus) {
          if (calibrationClicks >= 9) {
            calibrationStatus.textContent = "‚úì Calibration complete! Click the button below to start.";
            
            // Calculate thresholds from samples
            if (gazeCalibration.samples.length > 50) {
              gazeCalibration.samples.sort((a, b) => a - b);
              const len = gazeCalibration.samples.length;
              gazeCalibration.upThreshold = gazeCalibration.samples[Math.floor(len * 0.25)];
              gazeCalibration.downThreshold = gazeCalibration.samples[Math.floor(len * 0.75)];
            }
            gazeCalibration.isCalibrating = false;
          } else {
            calibrationStatus.textContent = `Look at each point and click it 5 times (${calibrationClicks}/9)`;
          }
        }
      } else if (!point.classList.contains("clicked")) {
        point.style.transform = `scale(${1 + clickCount * 0.1})`;
        point.textContent = `${clickCount}/5`;
      }
    };
  });
  
  // Finish calibration and start game
  if (finishCalibrationBtn) {
    finishCalibrationBtn.onclick = () => {
      if (calibrationClicks < 5) {
        alert("Please click at least 5 calibration points for better accuracy.");
        return;
      }
      
      // Hide calibration overlay
      calibrationOverlay.classList.remove("active");
      
      // Enable eye tracking
      eyeTrackingEnabled = true;
      gazeCalibration.isCalibrating = false;
      
      // Show indicators
      if (eyeTrackingIndicator) {
        eyeTrackingIndicator.classList.add("active");
      }
      
      // Show BPM display
      const bpmDisplay = $("bpmDisplay");
      if (bpmDisplay) {
        bpmDisplay.classList.add("active");
      }
      
      // Update button text
      if (eyeTrackBtn) {
        eyeTrackBtn.textContent = "üëÅÔ∏è Eye Tracking ON";
        eyeTrackBtn.style.background = "#4ade80";
        eyeTrackBtn.style.color = "#000";
      }
      
      // Show gaze cursor
      if (gazeCursor) {
        gazeCursor.classList.add("active");
      }
      
      // Hide video preview (minimize it)
      if (videoElement) {
        videoElement.style.width = '80px';
        videoElement.style.height = '60px';
        videoElement.style.opacity = '0.5';
      }
      
      // Update hint
      const hint = $("hint");
      if (hint) {
        hint.innerHTML = '<span style="color:#4ade80;font-weight:700;">üëÅÔ∏è EYE TRACKING ACTIVE</span> | Look <kbd>UP</kbd> = Jump | Look <kbd>DOWN</kbd> = Duck | Press <kbd>E</kbd> to toggle';
      }
      
      // Start the game
      if (!world.started) {
        start();
      }
    };
  }
  
  // Toggle eye tracking on/off
  window.addEventListener("keydown", (e) => {
    if (e.code === "KeyE" && mediapipeAvailable && faceLandmarker) {
      const hint = $("hint");
      const bpmDisplay = $("bpmDisplay");
      if (eyeTrackingEnabled) {
        eyeTrackingEnabled = false;
        if (eyeTrackingIndicator) eyeTrackingIndicator.classList.remove("active");
        if (gazeCursor) gazeCursor.classList.remove("active");
        if (gazeZoneIndicator) gazeZoneIndicator.style.display = 'none';
        if (bpmDisplay) bpmDisplay.classList.remove("active");
        if (eyeTrackBtn) {
          eyeTrackBtn.textContent = "üëÅÔ∏è Enable Eye Tracking";
          eyeTrackBtn.style.background = "";
          eyeTrackBtn.style.color = "";
        }
        if (hint) {
          hint.innerHTML = '<kbd>Space</kbd> Jump | <kbd>Down</kbd> Duck | Press <kbd>E</kbd> for Eye Tracking';
        }
      } else {
        eyeTrackingEnabled = true;
        if (eyeTrackingIndicator) eyeTrackingIndicator.classList.add("active");
        if (gazeCursor) gazeCursor.classList.add("active");
        if (bpmDisplay) bpmDisplay.classList.add("active");
        if (eyeTrackBtn) {
          eyeTrackBtn.textContent = "üëÅÔ∏è Eye Tracking ON";
          eyeTrackBtn.style.background = "#4ade80";
          eyeTrackBtn.style.color = "#000";
        }
        if (hint) {
          hint.innerHTML = '<span style="color:#4ade80;font-weight:700;">üëÅÔ∏è EYE TRACKING ACTIVE</span> | Look <kbd>UP</kbd> = Jump | Look <kbd>DOWN</kbd> = Duck | Press <kbd>E</kbd> to toggle';
        }
      }
    }
  });

  // Initialize after DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      resize();
  resetWorld();
  requestAnimationFrame(tick);
    });
  } else {
    resize();
    resetWorld();
    requestAnimationFrame(tick);
  }
})();
</script>
</body>
</html>
