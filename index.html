<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Viking Run</title>
  <!-- Version: 1.0.0 - MediaPipe Fix -->
  <!-- MediaPipe Face Landmarker for Eye/Gaze Tracking + rPPG - Loaded dynamically -->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');
    
    :root{
      /* iOS 17 Design System */
      --bg: linear-gradient(160deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      --bg-solid: #000000;
      --surface: rgba(30, 30, 30, 0.7);
      --surface-elevated: rgba(44, 44, 46, 0.8);
      --surface-dark: rgba(28, 28, 30, 0.95);
      --text: #ffffff;
      --text-secondary: rgba(255, 255, 255, 0.6);
      --text-tertiary: rgba(255, 255, 255, 0.4);
      --text-light: #ffffff;
      --separator: rgba(255, 255, 255, 0.1);
      
      /* iOS Vibrant Colors */
      --ios-blue: #0A84FF;
      --ios-green: #30D158;
      --ios-orange: #FF9F0A;
      --ios-red: #FF453A;
      --ios-purple: #BF5AF2;
      --ios-pink: #FF375F;
      --ios-teal: #64D2FF;
      --ios-indigo: #5E5CE6;
      --ios-yellow: #FFD60A;
      
      --accent: var(--ios-blue);
      --accent-hover: #409CFF;
      --accent-green: var(--ios-green);
      --accent-gradient: linear-gradient(135deg, var(--ios-blue) 0%, var(--ios-purple) 100%);
      
      --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
      --shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      --shadow-lg: 0 24px 80px rgba(0, 0, 0, 0.5);
      
      --card-bg: rgba(30, 30, 30, 0.6);
      --blur: blur(50px);
      --card-border: 1px solid rgba(255, 255, 255, 0.1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      background-attachment: fixed;
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Inter', system-ui, sans-serif;
      overflow: hidden;
      user-select: none;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      letter-spacing: -0.01em;
    }

    .wrap{ 
      height: 100%; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      padding: 20px;
      background: var(--bg);
    }
    
    .shell{
      width: min(1200px, calc(100vw - 40px));
      height: min(800px, calc(100vh - 40px));
      border-radius: 24px;
      background: var(--card-bg);
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
      border: 1px solid rgba(255, 255, 255, 0.3);
      box-shadow: var(--shadow-lg), inset 0 1px 0 rgba(255, 255, 255, 0.5);
      position: relative;
      overflow: hidden;
    }

    .topbar{ 
      position: absolute; 
      left: 20px; 
      right: 20px; 
      top: 16px; 
      height: 56px; 
      display: flex; 
      align-items: center; 
      justify-content: space-between; 
      z-index: 100; 
      pointer-events: none; 
    }
    
    .leftpack, .rightpack{ 
      display: flex; 
      align-items: center; 
      gap: 12px; 
      pointer-events: auto; 
    }
    
    .title{ 
      padding: 6px 12px; 
      border-radius: 8px; 
      background: transparent;
    }
    
    .title strong{ 
      font-weight: 600; 
      font-size: 21px;
      letter-spacing: -0.5px;
      color: var(--text);
    }
    
    .pill{ 
      font-size: 11px; 
      padding: 4px 8px; 
      border-radius: 6px; 
      background: var(--surface-elevated);
      color: var(--text-secondary);
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }
    
    .scorecard{ 
      display: flex; 
      align-items: center; 
      gap: 24px; 
      padding: 0;
      background: transparent;
      border: none;
    }
    
    .stat{ 
      display: flex;
      flex-direction: column;
      gap: 2px; 
      min-width: 70px; 
    }
    
    .stat .k{ 
      font-size: 10px; 
      color: var(--text-secondary); 
      text-transform: uppercase; 
      font-weight: 500; 
      letter-spacing: 0.5px;
    }
    
    .stat .v{ 
      font-size: 24px; 
      font-weight: 700; 
      line-height: 1; 
      color: var(--ios-blue);
      letter-spacing: -0.5px;
    }

    .btn{ 
      border: none; 
      background: rgba(255, 255, 255, 0.1);
      color: var(--ios-blue); 
      padding: 14px 24px; 
      border-radius: 14px; 
      cursor: pointer; 
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); 
      font-weight: 600; 
      font-size: 17px; 
      font-family: inherit;
      min-width: 100px;
      text-align: center;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      height: 50px;
      letter-spacing: -0.01em;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    .btn:hover{ 
      transform: scale(1.02);
      background: rgba(255, 255, 255, 0.15);
    }
    
    .btn:active {
      transform: scale(0.97);
      opacity: 0.8;
    }
    
    .btn.primary{ 
      background: var(--ios-blue);
      color: #ffffff;
      font-weight: 600;
    }
    
    .btn.primary:hover {
      background: var(--accent-hover);
      transform: scale(1.02);
    }
    
    .btn.eye-track {
      background: rgba(48, 209, 88, 0.2);
      border: none;
      color: var(--ios-green);
    }
    
    .btn.eye-track:hover {
      background: rgba(48, 209, 88, 0.3);
    }
    
    .btn.eye-track.active {
      background: var(--ios-green);
      color: #ffffff;
    }

    .hudline{ 
      position: absolute; 
      left: 20px; 
      right: 20px; 
      bottom: 20px; 
      display: flex; 
      justify-content: center; 
      z-index: 100; 
      pointer-events: none; 
    }
    
    .hint{ 
      max-width: 700px; 
      padding: 12px 20px; 
      border-radius: 16px; 
      background: var(--card-bg);
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
      border: var(--card-border);
      color: var(--text); 
      font-size: 13px; 
      font-weight: 500;
      text-align: center; 
      pointer-events: auto;
      box-shadow: var(--shadow);
    }
    
    kbd{ 
      background: var(--text); 
      border-radius: 6px; 
      padding: 4px 10px; 
      color: #ffffff; 
      border: none; 
      margin: 0 4px; 
      font-weight: 600;
      font-size: 12px;
      font-family: 'SF Mono', 'Menlo', monospace;
    }

    .canvas{ 
      position: absolute; 
      inset: 0; 
      width: 100%; 
      height: 100%; 
      display: block; 
      cursor: crosshair; 
    }
    
    .overlay{ 
      position: absolute; 
      inset: 0; 
      display: grid; 
      place-items: center; 
      pointer-events: none; 
      z-index: 200; 
      background: rgba(0, 0, 0, 0.75);
      backdrop-filter: blur(40px);
      -webkit-backdrop-filter: blur(40px);
      visibility: visible;
      opacity: 1;
    }
    
    .card{ 
      pointer-events: auto; 
      width: min(400px, 92%); 
      max-height: 85vh;
      overflow-y: auto;
      border-radius: 24px; 
      padding: 32px 28px; 
      background: var(--card-bg);
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
      border: var(--card-border);
      box-shadow: var(--shadow-lg);
      text-align: center;
    }
    
    .card h1{ 
      font-size: 32px; 
      margin: 0 0 8px; 
      font-weight: 700;
      color: var(--text);
      letter-spacing: -0.5px;
    }
    
    .card p{ 
      margin: 0 0 24px; 
      color: var(--text-secondary); 
      line-height: 1.6; 
      font-size: 15px;
    }
    
    .eye-tracking-indicator {
      position: absolute;
      top: 70px;
      left: 20px;
      padding: 10px 16px;
      border-radius: 10px;
      background: var(--accent-green);
      color: white;
      font-size: 13px;
      font-weight: 600;
      z-index: 150;
      display: none;
      align-items: center;
      gap: 10px;
      box-shadow: 0 4px 12px rgba(52, 199, 89, 0.3);
    }
    
    .eye-tracking-indicator.active {
      display: flex;
    }
    
    .eye-tracking-indicator .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ffffff;
      animation: pulse 1s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
    }
    
    .bpm-display {
      position: absolute;
      top: 110px;
      left: 20px;
      padding: 10px 16px;
      border-radius: 10px;
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.9), rgba(185, 28, 28, 0.9));
      color: white;
      font-size: 14px;
      font-weight: 700;
      z-index: 150;
      display: none;
      align-items: center;
      gap: 8px;
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
    }
    
    .bpm-display.active {
      display: flex;
    }
    
    .bpm-display .heart-icon {
      font-size: 18px;
      animation: heartbeat 1s ease-in-out infinite;
    }
    
    .bpm-display #bpmValue {
      font-size: 20px;
      font-weight: 800;
      min-width: 36px;
      text-align: center;
    }
    
    .bpm-display .bpm-label {
      font-size: 11px;
      opacity: 0.9;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    @keyframes heartbeat {
      0%, 100% { transform: scale(1); }
      15% { transform: scale(1.15); }
      30% { transform: scale(1); }
      45% { transform: scale(1.1); }
      60% { transform: scale(1); }
    }
    
    .achievement-popup {
      position: fixed;
      top: 24px;
      right: -400px;
      background: var(--card-bg);
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
      border: var(--card-border);
      border-radius: 16px;
      padding: 16px 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 10000;
      box-shadow: var(--shadow-lg);
      transition: right 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
      color: var(--text);
    }
    .achievement-popup.show { right: 24px; }
    .achievement-popup .achievement-icon { font-size: 32px; }
    .achievement-popup strong { font-size: 15px; font-weight: 700; color: var(--ios-yellow); }
    .achievement-popup small { color: var(--text-secondary); font-size: 13px; }
    
    .level-unlock-notification {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      z-index: 10001;
      transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      pointer-events: none;
    }
    .level-unlock-notification.show {
      transform: translate(-50%, -50%) scale(1);
    }
    .level-unlock-content {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border: 3px solid #ffd700;
      border-radius: 20px;
      padding: 32px 48px;
      text-align: center;
      box-shadow: 0 12px 48px rgba(255, 215, 0, 0.5);
      color: #fff;
    }
    .level-unlock-icon {
      font-size: 64px;
      margin-bottom: 16px;
      animation: bounce 0.6s ease-in-out;
    }
    .level-unlock-text strong {
      display: block;
      font-size: 24px;
      color: #ffd700;
      margin-bottom: 8px;
    }
    .level-unlock-text span {
      font-size: 18px;
      color: #fff;
    }
    
    .difficulty-selector {
      display: flex;
      gap: 8px;
      margin: 12px 0;
      flex-wrap: nowrap;
      overflow-x: visible;
      width: 100%;
      justify-content: center;
      align-items: center;
    }
    .difficulty-btn {
      flex: 0 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 12px 10px;
      border: none;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.08);
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      font-weight: 600;
      font-size: 12px;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: visible;
      width: auto;
      min-width: 65px;
    }
    .difficulty-btn[data-difficulty="easy"] { color: var(--ios-green); }
    .difficulty-btn[data-difficulty="normal"] { color: var(--ios-blue); }
    .difficulty-btn[data-difficulty="hard"] { color: var(--ios-red); }
    .difficulty-btn[data-difficulty="extreme"] { color: #FF4500; }
    
    .difficulty-btn:hover {
      background: rgba(255, 255, 255, 0.12);
    }
    .difficulty-btn[data-difficulty="easy"].active {
      background: var(--ios-green);
      color: #fff;
    }
    .difficulty-btn[data-difficulty="normal"].active {
      background: var(--ios-blue);
      color: #fff;
    }
    .difficulty-btn[data-difficulty="hard"].active {
      background: var(--ios-red);
      color: #fff;
    }
    .difficulty-btn[data-difficulty="extreme"].active {
      background: #FF4500;
      color: #fff;
      box-shadow: 0 0 20px rgba(255, 69, 0, 0.5);
    }
    
    .level-grid {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin: 12px 0;
      max-height: 200px;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 4px;
      width: 100%;
    }
    .level-card {
      background: rgba(255, 255, 255, 0.08);
      border: none;
      border-radius: 12px;
      padding: 12px 14px;
      text-align: left;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .level-card:hover:not(.locked) {
      background: rgba(255, 255, 255, 0.12);
    }
    .level-card.locked {
      opacity: 0.35;
      cursor: not-allowed;
    }
    .level-card.active {
      background: var(--ios-blue);
      color: #fff;
    }
    .level-card .level-icon {
      font-size: 24px;
      width: 36px;
      text-align: center;
    }
    .level-card .level-info {
      flex: 1;
    }
    .level-card .level-name {
      font-weight: 600;
      font-size: 15px;
      margin-bottom: 2px;
      color: var(--text);
    }
    .level-card.active .level-name {
      color: #fff;
    }
    .level-card .level-score {
      font-size: 12px;
      color: var(--text-tertiary);
    }
    .level-card.locked .level-score {
      color: var(--text-tertiary);
    }
    .level-card .unlock-req {
      font-size: 11px;
      color: var(--text-tertiary);
      margin-top: 4px;
    }
    
    .combo-display {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      font-size: 48px;
      font-weight: 900;
      color: #ff6b6b;
      text-shadow: 0 0 20px #ff6b6b, 0 4px 8px rgba(0,0,0,0.5);
      pointer-events: none;
      z-index: 200;
      transition: transform 0.15s ease-out, opacity 0.3s;
      opacity: 0;
    }
    .combo-display.show {
      transform: translate(-50%, -50%) scale(1);
      opacity: 1;
    }
    .combo-display.x3 { color: #fbbf24; text-shadow: 0 0 20px #fbbf24, 0 4px 8px rgba(0,0,0,0.5); }
    .combo-display.x5 { color: #4ade80; text-shadow: 0 0 20px #4ade80, 0 4px 8px rgba(0,0,0,0.5); }
    .combo-display.x10 { color: #a855f7; text-shadow: 0 0 30px #a855f7, 0 4px 8px rgba(0,0,0,0.5); font-size: 64px; }
    .combo-display.x15 { color: #ef4444; text-shadow: 0 0 40px #ef4444, 0 4px 12px rgba(0,0,0,0.6); font-size: 72px; animation: combo-fire 0.3s infinite; }
    .combo-display.x20 { color: #ffd700; text-shadow: 0 0 50px #ffd700, 0 0 80px #ff6b00, 0 4px 16px rgba(0,0,0,0.7); font-size: 80px; animation: combo-legendary 0.2s infinite; }
    .combo-display.x25 { color: #fff; text-shadow: 0 0 60px #fff, 0 0 100px #ffd700, 0 0 140px #ff0000, 0 4px 20px rgba(0,0,0,0.8); font-size: 88px; animation: combo-godlike 0.15s infinite; }
    @keyframes combo-fire { 0%, 100% { transform: translate(-50%, -50%) scale(1); } 50% { transform: translate(-50%, -50%) scale(1.05); } }
    @keyframes combo-legendary { 0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(-2deg); } 50% { transform: translate(-50%, -50%) scale(1.08) rotate(2deg); } }
    @keyframes combo-godlike { 0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(-3deg); filter: hue-rotate(0deg); } 50% { transform: translate(-50%, -50%) scale(1.1) rotate(3deg); filter: hue-rotate(30deg); } }
    
    .near-miss {
      position: absolute;
      font-size: 24px;
      font-weight: 800;
      color: #22d3ee;
      text-shadow: 0 0 15px #22d3ee;
      pointer-events: none;
      animation: nearMissFloat 1s ease-out forwards;
    }
    @keyframes nearMissFloat {
      0% { transform: translateY(0) scale(1); opacity: 1; }
      100% { transform: translateY(-60px) scale(0.8); opacity: 0; }
    }
    
    .milestone-flash {
      position: absolute;
      inset: 0;
      background: radial-gradient(circle, rgba(255,215,0,0.3) 0%, transparent 70%);
      pointer-events: none;
      animation: milestoneFlash 0.8s ease-out forwards;
    }
    @keyframes milestoneFlash {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }
    
    @keyframes respawnPulse {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    
    @keyframes fadeOut {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }
    
    .personal-best-alert {
      position: absolute;
      top: 120px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #ffd700, #ff8c00);
      color: #000;
      padding: 8px 24px;
      border-radius: 20px;
      font-weight: 700;
      font-size: 14px;
      animation: pbPulse 0.5s ease-in-out infinite alternate;
      z-index: 150;
    }
    @keyframes pbPulse {
      0% { transform: translateX(-50%) scale(1); }
      100% { transform: translateX(-50%) scale(1.05); box-shadow: 0 0 20px rgba(255,215,0,0.5); }
    }
    
    .daily-bonus-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    .daily-bonus-modal.show { display: flex; }
    .daily-bonus-card {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border: 3px solid #ffd700;
      border-radius: 24px;
      padding: 32px;
      text-align: center;
      color: #fff;
      max-width: 400px;
    }
    .daily-bonus-card h2 { color: #ffd700; margin-bottom: 8px; }
    .daily-bonus-card .streak { font-size: 64px; margin: 16px 0; }
    .daily-bonus-card .reward { font-size: 24px; color: #4ade80; margin: 16px 0; }
    .daily-bonus-card button {
      background: linear-gradient(135deg, #ffd700, #ff8c00);
      border: none;
      padding: 12px 32px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      margin-top: 16px;
    }
    
    .calibration-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 500;
      display: none;
      opacity: 0;
      pointer-events: none; /* Default: Don't block clicks */
      place-items: center;
    }
    
    .calibration-overlay.active {
      display: grid;
      opacity: 1;
      pointer-events: all; /* Only block clicks when calibrating */
    }
    
    .calibration-card {
      background: #ffffff;
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      max-width: 500px;
    }
    
    .calibration-card h2 {
      color: #000;
      margin-bottom: 20px;
      font-size: 24px;
    }
    
    .calibration-card p {
      color: #333;
      margin-bottom: 24px;
      line-height: 1.6;
    }
    
    .calibration-points {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 20px;
      margin: 30px 0;
    }
    
    .calibration-point {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #007aff;
      cursor: pointer;
      transition: all 0.2s;
      margin: 0 auto;
    }
    
    .calibration-point:hover {
      transform: scale(1.2);
      background: #0051d5;
    }
    
    .calibration-point.clicked {
      background: #4ade80;
    }
    
    .gaze-cursor {
      position: fixed;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: rgba(255, 107, 107, 0.6);
      border: 3px solid rgba(255, 107, 107, 0.9);
      pointer-events: none;
      z-index: 9999;
      transform: translate(-50%, -50%);
      display: none;
      transition: left 0.05s, top 0.05s;
    }
    
    .gaze-cursor.active {
      display: block;
    }

    .lives-display {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-left: 12px;
      display: flex;
      gap: 6px;
      align-items: center;
      padding: 10px 16px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.08);
      z-index: 150;
      pointer-events: none;
    }

    .highscore-modal {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 300;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(40px);
      -webkit-backdrop-filter: blur(40px);
      place-items: center;
    }

    .highscore-modal.active {
      display: grid;
    }

    .highscore-card {
      width: min(420px, 92%);
      max-height: 80vh;
      overflow-y: auto;
      padding: 32px;
      border-radius: 24px;
      background: var(--card-bg);
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
      border: var(--card-border);
      box-shadow: var(--shadow-lg);
    }

    .highscore-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--separator);
    }

    .highscore-tab {
      padding: 8px 14px;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-weight: 500;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.15s;
      font-size: 13px;
    }

    .highscore-tab:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .highscore-tab.active {
      color: var(--text);
      background: rgba(255, 255, 255, 0.15);
      font-weight: 600;
    }

    .highscore-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .highscore-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 14px;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      border: none;
    }

    .highscore-item.rank-1 {
      background: rgba(255, 214, 10, 0.2);
      border: 1px solid rgba(255, 214, 10, 0.3);
    }

    .highscore-rank {
      font-size: 18px;
      font-weight: 600;
      color: var(--accent);
      min-width: 35px;
    }

    .highscore-score {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
    }

    .highscore-date {
      font-size: 11px;
      color: var(--text-secondary);
    }

    /* Progress Visualization System */
    .progress-container {
      position: absolute;
      bottom: 20px;
      right: 20px;
      left: auto;
      top: auto;
      z-index: 50;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      gap: 6px;
      opacity: 0.35;
      max-width: 280px;
    }

    .progress-bar-wrapper {
      background: rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      border-radius: 8px;
      padding: 6px 8px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      pointer-events: auto;
    }

    .progress-label {
      font-size: 9px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 600;
      margin-bottom: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .progress-label .progress-text {
      color: var(--text);
      font-size: 10px;
      font-weight: 700;
    }

    .progress-bar-bg {
      height: 3px;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 2px;
      overflow: hidden;
      position: relative;
    }

    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--ios-blue), var(--ios-green));
      border-radius: 3px;
      transition: width 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .progress-bar-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
      animation: shimmer 3s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .progress-bar-fill.warning {
      background: linear-gradient(90deg, #fbbf24, #f59e0b);
    }

    .progress-bar-fill.danger {
      background: linear-gradient(90deg, #ef4444, #dc2626);
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* Future Rewards Preview */
    .future-rewards {
      position: absolute;
      right: 20px;
      top: 80px;
      z-index: 50;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-width: 280px;
    }

    .reward-card {
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 12px 14px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      pointer-events: auto;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .reward-card:hover {
      transform: translateX(-4px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .reward-icon {
      font-size: 20px;
      margin-right: 8px;
    }

    .reward-title {
      font-size: 11px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .reward-name {
      font-size: 14px;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 2px;
    }

    .reward-desc {
      font-size: 11px;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .reward-progress {
      font-size: 10px;
      color: var(--ios-blue);
      font-weight: 600;
      margin-top: 4px;
    }

    /* Powerup Countdown Timers */
    .powerup-indicators {
      position: absolute;
      right: 20px;
      bottom: 80px;
      z-index: 99;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: flex-end;
    }

    .powerup-indicator {
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 10px 14px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 140px;
      pointer-events: auto;
      transition: all 0.3s ease;
    }

    .powerup-indicator.warning {
      border-color: #fbbf24;
      animation: pulse-warning 1s infinite;
    }

    .powerup-indicator.danger {
      border-color: #ef4444;
      animation: pulse-danger 0.5s infinite;
    }

    @keyframes pulse-warning {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    @keyframes pulse-danger {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.8; }
    }

    .powerup-icon {
      font-size: 24px;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.1);
    }

    .powerup-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .powerup-name {
      font-size: 12px;
      font-weight: 700;
      color: var(--text);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .powerup-timer {
      font-size: 18px;
      font-weight: 700;
      font-family: 'SF Mono', 'Menlo', monospace;
      color: var(--ios-blue);
      letter-spacing: -0.5px;
    }

    .powerup-timer.warning {
      color: #fbbf24;
    }

    .powerup-timer.danger {
      color: #ef4444;
    }

    @keyframes slideDown {
      from {
        transform: translateX(-50%) translateY(-100%);
        opacity: 0;
      }
      to {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
      }
    }

    @keyframes slideUp {
      from {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
      }
      to {
        transform: translateX(-50%) translateY(-100%);
        opacity: 0;
      }
    }

    /* Duck Warning Indicator */
  </style>
</head>

<body>
  <!-- Eye Tracking Gaze Cursor -->
  <div class="gaze-cursor" id="gazeCursor"></div>
  
  <div class="wrap">
    <div class="shell" id="shell">
      <canvas class="canvas" id="c"></canvas>
      
      <!-- Combo Display -->
      <div class="combo-display" id="comboDisplay">COMBO x2</div>
      
      <!-- Personal Best Alert -->
      <div class="personal-best-alert" id="pbAlert" style="display:none;">üî• NEW RECORD INCOMING!</div>
      
      <!-- Eye Tracking Indicator -->
      <div class="eye-tracking-indicator" id="eyeTrackingIndicator">
        <div class="dot"></div>
        <span>Eye Tracking Active</span>
      </div>
      
      <!-- Heart Rate (BPM) Display -->
      <div class="bpm-display" id="bpmDisplay">
        <span class="heart-icon">‚ù§Ô∏è</span>
        <span id="bpmValue">--</span>
        <span class="bpm-label">BPM</span>
      </div>
      
      <!-- Gaze Zone Indicator - shows what zone you're looking at -->
      <div id="gazeZoneIndicator" style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); padding:20px 40px; border-radius:12px; font-size:24px; font-weight:bold; color:white; z-index:1000; display:none; pointer-events:none;"></div>
      
      <!-- Calibration Overlay -->
      <div class="calibration-overlay" id="calibrationOverlay">
        <div class="calibration-card">
          <h2>üëÅÔ∏è Eye Tracking Calibration</h2>
          <p style="margin-bottom: 16px;"><strong>How it works:</strong> Look at each blue dot and click it.<br>This trains the eye tracker on your gaze patterns.</p>
          <div style="background: #f0f9ff; padding: 12px; border-radius: 8px; margin-bottom: 20px;">
            <p style="margin: 0; font-size: 14px; color: #0369a1;">
              <strong>üëÜ TIP:</strong> Keep your head still and move only your eyes.<br>
              Good lighting helps accuracy!
            </p>
          </div>
          <div class="calibration-points" id="calibrationPoints">
            <div class="calibration-point" data-pos="1"></div>
            <div class="calibration-point" data-pos="2"></div>
            <div class="calibration-point" data-pos="3"></div>
            <div class="calibration-point" data-pos="4"></div>
            <div class="calibration-point" data-pos="5"></div>
            <div class="calibration-point" data-pos="6"></div>
            <div class="calibration-point" data-pos="7"></div>
            <div class="calibration-point" data-pos="8"></div>
            <div class="calibration-point" data-pos="9"></div>
          </div>
          <p id="calibrationStatus" style="font-weight: 600;">Click all 9 points to calibrate (0/9)</p>
          <div style="background: #ecfdf5; padding: 12px; border-radius: 8px; margin-top: 16px;">
            <p style="margin: 0; font-size: 13px; color: #047857;">
              <strong>During gameplay:</strong><br>
              üëÄ Look UP = Viking JUMPS<br>
              üëÄ Look DOWN = Viking DUCKS<br>
              Press <kbd style="background:#000;color:#fff;padding:2px 6px;border-radius:4px;">E</kbd> to toggle eye tracking
            </p>
          </div>
          <button class="btn primary" id="finishCalibrationBtn" style="margin-top: 24px; padding: 14px 32px; font-size: 15px;">Start Playing with Eye Tracking</button>
          <button onclick="document.getElementById('calibrationOverlay').classList.remove('active')" 
                  style="position:absolute; bottom:20px; background:red; color:white; padding:10px; z-index:10001; border:none; border-radius:8px; cursor:pointer; font-weight:bold;">
            SKIP CALIBRATION & PLAY
          </button>
        </div>
      </div>

      <div class="topbar">
        <div class="leftpack">
          <div class="title"><strong>Viking Run</strong> <span class="pill" id="statePill">Ready</span></div>
          <div class="scorecard">
            <div class="stat"><div class="k">Score</div><div class="v" id="scoreV">0</div></div>
            <div class="stat"><div class="k">Mead</div><div class="v" id="meadV">0</div></div>
            <div class="stat" id="multiplierStat" style="display: none;"><div class="k">Multiplier</div><div class="v" id="multiplierV">1x</div></div>
          </div>
        </div>
        <div class="rightpack">
          <div class="lives-display" id="livesDisplay">
            <span style="font-size: 20px;">‚ù§Ô∏è</span>
            <span id="livesCount" style="font-size: 18px; font-weight: 700; color: #ef4444;">3</span>
          </div>
          <div class="lives-display" id="respawnDisplay" style="display: flex;">
            <span style="font-size: 20px;">üîÑ</span>
            <span id="respawnCount" style="font-size: 18px; font-weight: 700; color: #9B59B6;">0</span>
          </div>
          <button class="btn" id="pauseBtn">Pause</button>
          <button class="btn" id="soundBtn">Sound: On</button>
          <button class="btn" id="musicBtn">üéµ Music: On</button>
          <button class="btn primary" id="restartBtn">Restart</button>
        </div>
      </div>

      <!-- Progress Visualization System -->
      <div class="progress-container" id="progressContainer" style="display: none;">
        <div class="progress-bar-wrapper" id="levelProgressBar">
          <div class="progress-label">
            <span>Next Level</span>
            <span class="progress-text" id="levelProgressText">--</span>
          </div>
          <div class="progress-bar-bg">
            <div class="progress-bar-fill" id="levelProgressFill" style="width: 0%;"></div>
          </div>
        </div>
        <div class="progress-bar-wrapper" id="bossProgressBar">
          <div class="progress-label">
            <span>Next Boss</span>
            <span class="progress-text" id="bossProgressText">--</span>
          </div>
          <div class="progress-bar-bg">
            <div class="progress-bar-fill" id="bossProgressFill" style="width: 0%;"></div>
          </div>
        </div>
        <div class="progress-bar-wrapper" id="achievementProgressBar" style="display: none !important;">
          <div class="progress-label">
            <span>Next Achievement</span>
            <span class="progress-text" id="achievementProgressText">--</span>
          </div>
          <div class="progress-bar-bg">
            <div class="progress-bar-fill" id="achievementProgressFill" style="width: 0%;"></div>
          </div>
        </div>
        <div class="progress-bar-wrapper" id="challengeProgressBar" style="display: none;">
          <div class="progress-label">
            <span>Daily Challenge</span>
            <span class="progress-text" id="challengeProgressText">--</span>
          </div>
          <div class="progress-bar-bg">
            <div class="progress-bar-fill" id="challengeProgressFill" style="width: 0%;"></div>
          </div>
        </div>
      </div>

      <!-- Future Rewards Preview -->
      <div class="future-rewards" id="futureRewards" style="display: none;">
        <div class="reward-card" id="nextLevelCard">
          <div class="reward-title">Next Level</div>
          <div class="reward-name" id="nextLevelName">--</div>
          <div class="reward-desc" id="nextLevelDesc">--</div>
          <div class="reward-progress" id="nextLevelProgress">--</div>
        </div>
        <div class="reward-card" id="nextAchievementCard">
          <div class="reward-title">Next Achievement</div>
          <div class="reward-name" id="nextAchievementName">--</div>
          <div class="reward-desc" id="nextAchievementDesc">--</div>
          <div class="reward-progress" id="nextAchievementProgress">--</div>
        </div>
        <div class="reward-card" id="nextBossCard">
          <div class="reward-title">Next Boss</div>
          <div class="reward-name" id="nextBossName">--</div>
          <div class="reward-desc" id="nextBossDesc">--</div>
          <div class="reward-progress" id="nextBossProgress">--</div>
        </div>
      </div>

      <!-- Powerup Countdown Timers -->
      <div class="powerup-indicators" id="powerupIndicators"></div>



      <div class="hudline">
        <div class="hint" id="hint">
          <kbd>Space</kbd> Jump | <kbd>Down</kbd> Duck | <kbd>üëÅÔ∏è</kbd> Eye Track | Jump ON enemies to stomp them!
        </div>
      </div>

      <div class="overlay" id="overlay">
        <div class="card">
          <h1 id="overlayTitle">Viking Run</h1>
          <p id="overlayText" style="white-space: pre-line;">Jump on platforms, avoid enemies, collect powerups, and survive.</p>
          
          <div style="width: 100%; max-width: 320px; margin: 20px auto 0;">
            <div style="margin-bottom: 16px;">
              <label style="display: block; font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px;">Difficulty</label>
              <div class="difficulty-selector" id="difficultySelector">
                <button class="difficulty-btn" data-difficulty="easy">üõ°Ô∏è Easy</button>
                <button class="difficulty-btn active" data-difficulty="normal">‚öîÔ∏è Normal</button>
                <button class="difficulty-btn" data-difficulty="hard">üíÄ Hard</button>
                <button class="difficulty-btn" data-difficulty="extreme">üî• Extreme</button>
              </div>
            </div>
            
            <div style="margin-bottom: 16px;">
              <label style="display: block; font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px;">Level</label>
              <div class="level-grid" id="levelGrid" style="max-height: 200px;"></div>
            </div>
          </div>
          
          <div style="display: flex; flex-direction: column; align-items: center; gap: 14px; width: 100%; max-width: 320px; margin: 28px auto 0;">
            <button class="btn primary" id="startBtn" style="width: 100%; height: 54px; font-size: 18px;">
              ‚öîÔ∏è Start Game
            </button>
            
            <div style="width: 100%; padding: 16px; background: rgba(48, 209, 88, 0.15); border-radius: 14px; margin: 4px 0; border: 1px solid rgba(48, 209, 88, 0.3);">
              <button class="btn eye-track" id="eyeTrackBtn" style="width: 100%; height: 48px; font-size: 16px;">
                üëÅÔ∏è Eye Tracking
              </button>
              <p style="margin: 10px 0 0; font-size: 12px; color: var(--text-secondary); line-height: 1.4;">
                Control with your eyes ‚Äî look up to jump, down to duck
              </p>
            </div>
            
            <button class="btn" id="highscoreBtn" style="width: 100%; height: 50px;">
              üèÜ High Scores
            </button>
            
            <button class="btn" id="shareBtn" style="width: 100%; height: 50px; margin-top: 8px;">
              üì§ Share Achievement
            </button>
          </div>
        </div>
      </div>

      <div class="highscore-modal" id="highscoreModal">
        <div class="highscore-card">
          <h2 style="margin-bottom: 24px; font-size: 24px; font-weight: 600; color: var(--text);">High Scores</h2>
          <div class="highscore-tabs">
            <button class="highscore-tab active" data-period="alltime">All Time</button>
            <button class="highscore-tab" data-period="yearly">Yearly</button>
            <button class="highscore-tab" data-period="monthly">Monthly</button>
            <button class="highscore-tab" data-period="weekly">Weekly</button>
            <button class="highscore-tab" data-period="daily">Daily</button>
          </div>
          <div class="highscore-list" id="highscoreList"></div>
          <button class="btn" id="closeHighscoreBtn" style="margin-top: 24px; width: 100%;">Close</button>
        </div>
      </div>
    </div>
  </div>

<script>
// 1. Declare at the top of your module - This prevents the "not defined" error
let mpFaceLandmarker = null;
let videoElement = null; // Will be initialized when camera starts
let lastVideoTime = -1;
(() => {
  "use strict";

  const $ = (id) => document.getElementById(id);
  const rand = (a, b) => a + Math.random() * (b - a);
  const pick = (arr) => arr[(Math.random() * arr.length) | 0];

  const canvas = $("c");
  const shell = $("shell");
  const scoreV = $("scoreV");
  const meadV = $("meadV");
  const statePill = $("statePill");
  const overlay = $("overlay");
  // Button references moved to DOMContentLoaded to ensure DOM is ready

  let W, H, DPR, ctx;
  const resize = () => {
    const rect = shell.getBoundingClientRect();
    DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    W = Math.floor(rect.width); H = Math.floor(rect.height);
    canvas.width = Math.floor(W * DPR); canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + "px"; canvas.style.height = H + "px";
    ctx = canvas.getContext("2d");
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  };
  window.addEventListener("resize", resize);
  resize(); // Initialize immediately

  let AC = null;
  const beep = (type, freq, dur, gain = 0.2) => {
    if (!OPT.sound) return;
    if (!AC) AC = new (window.AudioContext || window.webkitAudioContext)();
    const o = AC.createOscillator(), g = AC.createGain();
    o.type = type; o.frequency.setValueAtTime(freq, AC.currentTime);
    g.gain.setValueAtTime(gain, AC.currentTime); g.gain.exponentialRampToValueAtTime(0.01, AC.currentTime + dur);
    o.connect(g); g.connect(AC.destination);
    o.start(); o.stop(AC.currentTime + dur);
  };

  // Powerup looping sounds manager
  const powerupSounds = {
    speedBoost: null,
    invincibility: null,
    vikingShip: null,
    scoreMultiplier: null
  };
  
  const powerupIntervals = {
    vikingShip: null
  };
  
  const stopPowerupSound = (type) => {
    if (powerupSounds[type]) {
      try {
        powerupSounds[type].stop();
        powerupSounds[type].disconnect();
      } catch (e) {}
      powerupSounds[type] = null;
    }
    // Clear intervals
    if (powerupIntervals[type]) {
      clearInterval(powerupIntervals[type]);
      powerupIntervals[type] = null;
    }
  };
  
  const startPowerupSound = (type) => {
    if (!OPT.sound) return;
    if (!AC) AC = new (window.AudioContext || window.webkitAudioContext)();
    
    // Stop existing sound if any
    stopPowerupSound(type);
    
    const now = AC.currentTime;
    let source = null;
    
    switch(type) {
      case 'speedBoost': {
        // Continuous whoosh/wind sound
        const whoosh = AC.createBufferSource();
        whoosh.buffer = createNoiseBuffer(0.5);
        whoosh.loop = true;
        const whooshFilter = AC.createBiquadFilter();
        whooshFilter.type = 'lowpass';
        whooshFilter.frequency.value = 1200;
        const whooshGain = AC.createGain();
        whooshGain.gain.value = 0.15;
        whoosh.connect(whooshFilter);
        whooshFilter.connect(whooshGain);
        whooshGain.connect(AC.destination);
        whoosh.start(now);
        source = whoosh;
        break;
      }
      case 'invincibility': {
        // Continuous protective aura hum
        const aura = AC.createOscillator();
        const auraGain = AC.createGain();
        aura.type = 'sine';
        aura.frequency.value = 110;
        auraGain.gain.value = 0.08;
        const auraFilter = AC.createBiquadFilter();
        auraFilter.type = 'lowpass';
        auraFilter.frequency.value = 300;
        aura.connect(auraFilter);
        auraFilter.connect(auraGain);
        auraGain.connect(AC.destination);
        aura.start(now);
        source = aura;
        break;
      }
      case 'vikingShip': {
        // Enhanced viking ship sounds - wind, water, oars, and ship creaking
        // Wind whoosh (continuous)
        const wind = AC.createBufferSource();
        wind.buffer = createNoiseBuffer(1.0);
        wind.loop = true;
        const windFilter = AC.createBiquadFilter();
        windFilter.type = 'lowpass';
        windFilter.frequency.value = 800; // Slightly higher for more presence
        const windGain = AC.createGain();
        windGain.gain.value = 0.15; // Slightly louder
        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(AC.destination);
        wind.start(now);
        
        // Water splashing rhythm (matching oar strokes) - use interval
        powerupIntervals['vikingShip'] = setInterval(() => {
          if (!powerupSounds['vikingShip']) {
            clearInterval(powerupIntervals['vikingShip']);
            powerupIntervals['vikingShip'] = null;
            return;
          }
          const splash = AC.createBufferSource();
          splash.buffer = createNoiseBuffer(0.15);
          const splashFilter = AC.createBiquadFilter();
          splashFilter.type = 'bandpass';
          splashFilter.frequency.value = 400;
          splashFilter.Q.value = 3;
          const splashGain = AC.createGain();
          splashGain.gain.value = 0.08;
          splash.connect(splashFilter);
          splashFilter.connect(splashGain);
          splashGain.connect(AC.destination);
          splash.start(AC.currentTime);
        }, 400); // Every 400ms = oar rhythm
        
        // Oar rhythm (low frequency pulse)
        const oarPulse = AC.createOscillator();
        const oarGain = AC.createGain();
        oarPulse.type = 'sine';
        oarPulse.frequency.value = 2.5; // 2.5 Hz = oar rhythm
        oarGain.gain.value = 0.08; // Slightly louder
        const oarFilter = AC.createBiquadFilter();
        oarFilter.type = 'lowpass';
        oarFilter.frequency.value = 250;
        oarPulse.connect(oarFilter);
        oarFilter.connect(oarGain);
        oarGain.connect(AC.destination);
        oarPulse.start(now);
        
        // Ship creaking (wooden ship sounds)
        const creak = AC.createOscillator();
        const creakGain = AC.createGain();
        creak.type = 'triangle';
        creak.frequency.value = 3; // Slow creaking
        creakGain.gain.value = 0.05;
        const creakFilter = AC.createBiquadFilter();
        creakFilter.type = 'bandpass';
        creakFilter.frequency.value = 150;
        creakFilter.Q.value = 2;
        creak.connect(creakFilter);
        creakFilter.connect(creakGain);
        creakGain.connect(AC.destination);
        creak.start(now);
        
        // Track wind as main source
        source = wind;
        break;
      }
      case 'scoreMultiplier': {
        // Subtle continuous magical shimmer
        const shimmer = AC.createOscillator();
        const shimmerGain = AC.createGain();
        shimmer.type = 'triangle';
        shimmer.frequency.value = 880; // A5
        shimmerGain.gain.value = 0.05;
        const shimmerFilter = AC.createBiquadFilter();
        shimmerFilter.type = 'bandpass';
        shimmerFilter.frequency.value = 880;
        shimmerFilter.Q.value = 5;
        shimmer.connect(shimmerFilter);
        shimmerFilter.connect(shimmerGain);
        shimmerGain.connect(AC.destination);
        shimmer.start(now);
        source = shimmer;
        break;
      }
    }
    
    if (source) {
      powerupSounds[type] = source;
    }
  };
  
  // Sound Effects System
  
  // White noise buffer
  const createNoiseBuffer = (duration) => {
    const bufferSize = AC.sampleRate * duration;
    const buffer = AC.createBuffer(1, bufferSize, AC.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      data[i] = Math.random() * 2 - 1;
    }
    return buffer;
  };
  
  // Formant filter
  const createFormant = (freq, q, gain) => {
    const filter = AC.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = freq;
    filter.Q.value = q;
    const gn = AC.createGain();
    gn.gain.value = gain;
    filter.connect(gn);
    return { filter, gain: gn };
  };
  
  // Audio file loader with synthesis fallback
  const AudioLoader = {
    files: {},
    loaded: false,
    supported: ['warhorn', 'mead', 'gameover', 'stomp', 'gold', 'shipStart', 'shipDestroy', 'jump', 'damage', 'heart', 'powerup'],
    
    async init() {
      // Gracefully handle CORS and file loading errors
      for (const name of this.supported) {
        try {
          const audio = new Audio();
          // Handle CORS errors gracefully
          audio.crossOrigin = 'anonymous';
          audio.src = `sounds/${name}.mp3`;
          
          // Use Promise with timeout and error handling
          await new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
              // Timeout is not an error - file just doesn't exist or can't load
              resolve();
            }, 2000);
            
            audio.oncanplaythrough = () => {
              clearTimeout(timeout);
              resolve();
            };
            
            audio.onerror = (e) => {
              clearTimeout(timeout);
              // CORS or file not found - not critical, just resolve
              resolve();
            };
            
            // Try to load
            audio.load();
          });
          
          // Only store if audio actually loaded
          if (audio.readyState >= 2) { // HAVE_CURRENT_DATA or higher
            this.files[name] = audio.src;
          }
        } catch (e) {
          // Silently ignore - will use synthesis fallback
          // Don't log errors for missing files (CORS/file:// issues)
        }
      }
      this.loaded = true;
    },
    
    play(name, volume = 1.0, rate = 1.0) {
      if (!OPT.sound || !this.files[name]) return false;
      try {
        const audio = new Audio(this.files[name]);
        audio.volume = Math.min(1, Math.max(0, volume * (0.9 + Math.random() * 0.2)));
        audio.playbackRate = rate * (0.95 + Math.random() * 0.1);
        // Gracefully handle play() promise rejection
        audio.play().catch(() => {
          // Audio play failed (user interaction, etc.) - not critical
        });
        return true;
      } catch (e) {
        // Audio creation/play failed - not critical
        return false;
      }
    }
  };
  
  // Try to load audio files (non-blocking, graceful error handling)
  AudioLoader.init().catch(() => {
    // Silently fail - synthesis will be used as fallback
  });
  
  const playSFX = (sfxType) => {
    if (!OPT.sound) return;
    
    // Try audio file first
    if (AudioLoader.play(sfxType)) return;
    
    // Fall back to synthesis
    if (!AC) AC = new (window.AudioContext || window.webkitAudioContext)();
    
    const now = AC.currentTime;
    
    switch(sfxType) {
      case 'jump': {
        // Leather armor creak + cloth whoosh
        const noise = AC.createBufferSource();
        noise.buffer = createNoiseBuffer(0.2);
        const filter = AC.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(1500, now);
        filter.frequency.exponentialRampToValueAtTime(3000, now + 0.1);
        filter.Q.value = 1;
        const gain = AC.createGain();
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(AC.destination);
        noise.start(now);
        break;
      }
      case 'powerup': {
        // Ancient Nordic rune activation - mystical shimmer
        const notes = [293.7, 349.2, 440, 523.3]; // D4, F4, A4, C5 - minor chord
        notes.forEach((freq, i) => {
          const osc = AC.createOscillator();
          const gain = AC.createGain();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, now + i * 0.06);
          // Add shimmer vibrato
          const vibrato = AC.createOscillator();
          const vibGain = AC.createGain();
          vibrato.frequency.value = 8;
          vibGain.gain.value = 5;
          vibrato.connect(vibGain);
          vibGain.connect(osc.frequency);
          vibrato.start(now);
          vibrato.stop(now + 0.6);
          gain.gain.setValueAtTime(0, now + i * 0.06);
          gain.gain.linearRampToValueAtTime(0.15, now + i * 0.06 + 0.05);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
          osc.connect(gain);
          gain.connect(AC.destination);
          osc.start(now + i * 0.06);
          osc.stop(now + 0.6);
        });
        break;
      }
      case 'mead': {
        // Realistic Viking mead drinking - liquid gulping + wooden mug
        // Liquid gulping sounds (filtered noise bursts)
        [0, 0.2, 0.4].forEach((delay, i) => {
          const gulp = AC.createBufferSource();
          gulp.buffer = createNoiseBuffer(0.15);
          const gulpFilter = AC.createBiquadFilter();
          gulpFilter.type = 'bandpass';
          gulpFilter.frequency.setValueAtTime(400 + i * 100, now + delay);
          gulpFilter.frequency.exponentialRampToValueAtTime(200, now + delay + 0.12);
          gulpFilter.Q.value = 2;
          const gulpGain = AC.createGain();
          gulpGain.gain.setValueAtTime(0, now + delay);
          gulpGain.gain.linearRampToValueAtTime(0.25, now + delay + 0.02);
          gulpGain.gain.exponentialRampToValueAtTime(0.01, now + delay + 0.14);
          gulp.connect(gulpFilter);
          gulpFilter.connect(gulpGain);
          gulpGain.connect(AC.destination);
          gulp.start(now + delay);
        });
        
        // Wooden mug "clunk" when setting down
        const clunk = AC.createOscillator();
        const clunkGain = AC.createGain();
        clunk.type = 'sine';
        clunk.frequency.setValueAtTime(200, now + 0.65);
        clunk.frequency.exponentialRampToValueAtTime(120, now + 0.75);
        clunkGain.gain.setValueAtTime(0.15, now + 0.65);
        clunkGain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
        const clunkFilter = AC.createBiquadFilter();
        clunkFilter.type = 'lowpass';
        clunkFilter.frequency.value = 600;
        clunk.connect(clunkFilter);
        clunkFilter.connect(clunkGain);
        clunkGain.connect(AC.destination);
        clunk.start(now + 0.65);
        clunk.stop(now + 0.85);
        
        // Satisfied "ahh" exhale with proper formants
        const exhale = AC.createOscillator();
        const exhaleGain = AC.createGain();
        exhale.type = 'sawtooth';
        exhale.frequency.setValueAtTime(120, now + 0.7);
        exhale.frequency.exponentialRampToValueAtTime(80, now + 1.0);
        
        // Formants for "ahh" sound
        const f1 = createFormant(700, 10, 0.4);
        const f2 = createFormant(1200, 8, 0.25);
        
        exhaleGain.gain.setValueAtTime(0, now + 0.7);
        exhaleGain.gain.linearRampToValueAtTime(0.18, now + 0.75);
        exhaleGain.gain.exponentialRampToValueAtTime(0.01, now + 1.05);
        
        exhale.connect(f1.filter);
        exhale.connect(f2.filter);
        f1.gain.connect(exhaleGain);
        f2.gain.connect(exhaleGain);
        exhaleGain.connect(AC.destination);
        exhale.start(now + 0.7);
        exhale.stop(now + 1.1);
        break;
      }
      case 'damage': {
        // Viking battle grunt - deep "UGH!" with impact
        // Voice with formants for guttural grunt
        const voice = AC.createOscillator();
        voice.type = 'sawtooth';
        voice.frequency.setValueAtTime(120, now);
        voice.frequency.exponentialRampToValueAtTime(70, now + 0.2);
        // Formants for "UH" grunt sound
        const f1 = createFormant(500, 8, 0.5);
        const f2 = createFormant(1000, 10, 0.3);
        const masterGain = AC.createGain();
        masterGain.gain.setValueAtTime(0.4, now);
        masterGain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        voice.connect(f1.filter);
        voice.connect(f2.filter);
        f1.gain.connect(masterGain);
        f2.gain.connect(masterGain);
        masterGain.connect(AC.destination);
        voice.start(now);
        voice.stop(now + 0.3);
        
        // Shield/armor impact - metallic crash
        const impact = AC.createBufferSource();
        impact.buffer = createNoiseBuffer(0.15);
        const impFilter = AC.createBiquadFilter();
        impFilter.type = 'highpass';
        impFilter.frequency.value = 800;
        const impGain = AC.createGain();
        impGain.gain.setValueAtTime(0.3, now);
        impGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        impact.connect(impFilter);
        impFilter.connect(impGain);
        impGain.connect(AC.destination);
        impact.start(now);
        
        // Body thud
        const thud = AC.createOscillator();
        const thudGain = AC.createGain();
        thud.type = 'sine';
        thud.frequency.setValueAtTime(60, now);
        thud.frequency.exponentialRampToValueAtTime(25, now + 0.1);
        thudGain.gain.setValueAtTime(0.5, now);
        thudGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        thud.connect(thudGain);
        thudGain.connect(AC.destination);
        thud.start(now);
        thud.stop(now + 0.2);
        break;
      }
      case 'gameover': {
        // Somber Viking funeral horn - deep, mournful, not farty
        const fundamental = 73.4; // D2 - deep but not too low
        const endFreq = 55; // A1 - as specified in plan
        const duration = 3.0;
        
        // Main horn tone with proper resonance
        [1, 2].forEach((harmonic, i) => {
          const osc = AC.createOscillator();
          const gain = AC.createGain();
          osc.type = 'square'; // Square wave for horn
          const freq = fundamental * harmonic;
          const endFreqHarmonic = endFreq * harmonic;
          
          // Slow mournful descent: Start 73Hz (D2), descend to 55Hz (A1)
          osc.frequency.setValueAtTime(freq, now);
          osc.frequency.linearRampToValueAtTime(endFreqHarmonic, now + duration);
          
          // Formant for horn resonance
          const formant = AC.createBiquadFilter();
          formant.type = 'bandpass';
          formant.frequency.value = 150 + i * 100;
          formant.Q.value = 2;
          
          // Slow fade envelope
          const amp = [0.3, 0.12][i];
          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(amp, now + 0.4);
          gain.gain.setValueAtTime(amp * 0.9, now + duration * 0.6);
          gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
          
          // Reverb-like effect with delay
          const delay = AC.createDelay(0.1);
          delay.delayTime.value = 0.08;
          const delayGain = AC.createGain();
          delayGain.gain.value = 0.3;
          
          osc.connect(formant);
          formant.connect(gain);
          formant.connect(delay);
          delay.connect(delayGain);
          delayGain.connect(gain);
          gain.connect(AC.destination);
          
          osc.start(now);
          osc.stop(now + duration);
        });
        break;
      }
      case 'heart': {
        // Healing rune glow - warm mystical sound
        const notes = [196, 293.7, 392]; // G3, D4, G4 - open fifth
        notes.forEach((freq, i) => {
          const osc = AC.createOscillator();
          const gain = AC.createGain();
          osc.type = 'sine';
          osc.frequency.value = freq;
          gain.gain.setValueAtTime(0, now + i * 0.08);
          gain.gain.linearRampToValueAtTime(0.15, now + i * 0.08 + 0.1);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
          osc.connect(gain);
          gain.connect(AC.destination);
          osc.start(now + i * 0.08);
          osc.stop(now + 0.7);
        });
        break;
      }
      case 'warhorn': {
        // Realistic Viking war horn - proper horn resonance, no "fart" sounds
        // Frequency: Start at 98Hz (G2), rise to 147Hz (D3), hold, then fall
        const startFreq = 98; // G2
        const peakFreq = 147; // D3
        const duration = 2.0;
        
        // Main horn tone - square wave with formants for horn resonance
        [1, 2, 3, 4].forEach((harmonic, i) => {
          const osc = AC.createOscillator();
          const gain = AC.createGain();
          osc.type = 'square'; // Square wave for horn-like sound
          const startFreqHarmonic = startFreq * harmonic;
          const peakFreqHarmonic = peakFreq * harmonic;
          
          // Horn call pattern: rise to peak, hold, then fall
          osc.frequency.setValueAtTime(startFreqHarmonic * 0.92, now);
          osc.frequency.linearRampToValueAtTime(peakFreqHarmonic, now + 0.3);
          osc.frequency.setValueAtTime(peakFreqHarmonic, now + 1.0);
          osc.frequency.linearRampToValueAtTime(startFreqHarmonic * 0.88, now + duration);
          
          // Formant filters for horn resonance
          const formant1 = AC.createBiquadFilter();
          formant1.type = 'bandpass';
          formant1.frequency.value = 200 + i * 50;
          formant1.Q.value = 2;
          
          const formant2 = AC.createBiquadFilter();
          formant2.type = 'bandpass';
          formant2.frequency.value = 400 + i * 100;
          formant2.Q.value = 1.5;
          
          // Amplitude envelope
          const amp = [0.25, 0.12, 0.06, 0.03][i];
          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(amp, now + 0.2);
          gain.gain.setValueAtTime(amp, now + 1.0);
          gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
          
          // Slight vibrato for natural horn sound
          const vibrato = AC.createOscillator();
          const vibGain = AC.createGain();
          vibrato.frequency.value = 5.5;
          vibGain.gain.value = 2;
          vibrato.connect(vibGain);
          vibGain.connect(osc.frequency);
          
          osc.connect(formant1);
          formant1.connect(formant2);
          formant2.connect(gain);
          gain.connect(AC.destination);
          
          vibrato.start(now);
          vibrato.stop(now + duration);
          osc.start(now);
          osc.stop(now + duration);
        });
        
        // Breath noise - filtered white noise for realism
        const breath = AC.createBufferSource();
        breath.buffer = createNoiseBuffer(0.4);
        const breathFilter = AC.createBiquadFilter();
        breathFilter.type = 'bandpass';
        breathFilter.frequency.value = 800;
        breathFilter.Q.value = 1;
        const breathGain = AC.createGain();
        breathGain.gain.setValueAtTime(0, now);
        breathGain.gain.linearRampToValueAtTime(0.08, now + 0.1);
        breathGain.gain.setValueAtTime(0.08, now + 1.5);
        breathGain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        breath.connect(breathFilter);
        breathFilter.connect(breathGain);
        breathGain.connect(AC.destination);
        breath.start(now);
        
        break;
      }
      case 'stomp': {
        // Heavy Viking boot on wooden deck
        const thud = AC.createOscillator();
        const thudGain = AC.createGain();
        thud.type = 'sine';
        thud.frequency.setValueAtTime(80, now);
        thud.frequency.exponentialRampToValueAtTime(35, now + 0.08);
        thudGain.gain.setValueAtTime(0.5, now);
        thudGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        thud.connect(thudGain);
        thudGain.connect(AC.destination);
        thud.start(now);
        thud.stop(now + 0.15);
        // Wood creak
        const creak = AC.createOscillator();
        const creakGain = AC.createGain();
        creak.type = 'triangle';
        creak.frequency.setValueAtTime(250, now + 0.03);
        creak.frequency.exponentialRampToValueAtTime(180, now + 0.1);
        creakGain.gain.setValueAtTime(0.12, now + 0.03);
        creakGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        creak.connect(creakGain);
        creakGain.connect(AC.destination);
        creak.start(now + 0.03);
        creak.stop(now + 0.15);
        break;
      }
      case 'gold': {
        // Proper metallic coin clinking - multiple coins with reverb
        const coinFreqs = [2400, 2800, 3200, 2600, 3000];
        coinFreqs.forEach((freq, i) => {
          const delay = i * 0.04;
          const coin = AC.createOscillator();
          const gain = AC.createGain();
          coin.type = 'triangle'; // Triangle for metallic "ting"
          coin.frequency.setValueAtTime(freq, now + delay);
          coin.frequency.exponentialRampToValueAtTime(freq * 0.6, now + delay + 0.15);
          
          // Metallic resonance filter
          const metallic = AC.createBiquadFilter();
          metallic.type = 'bandpass';
          metallic.frequency.value = freq;
          metallic.Q.value = 8;
          
          gain.gain.setValueAtTime(0, now + delay);
          gain.gain.linearRampToValueAtTime(0.25, now + delay + 0.01);
          gain.gain.exponentialRampToValueAtTime(0.01, now + delay + 0.18);
          
          // Reverb/delay for multiple coins
          const delayNode = AC.createDelay(0.1);
          delayNode.delayTime.value = 0.05;
          const delayGain = AC.createGain();
          delayGain.gain.value = 0.4;
          
          coin.connect(metallic);
          metallic.connect(gain);
          metallic.connect(delayNode);
          delayNode.connect(delayGain);
          delayGain.connect(gain);
          gain.connect(AC.destination);
          
          coin.start(now + delay);
          coin.stop(now + delay + 0.2);
        });
        
        // Coin bag "chink" - lower metallic sound
        const bag = AC.createOscillator();
        const bagGain = AC.createGain();
        bag.type = 'triangle';
        bag.frequency.setValueAtTime(800, now + 0.2);
        bag.frequency.exponentialRampToValueAtTime(400, now + 0.3);
        bagGain.gain.setValueAtTime(0.2, now + 0.2);
        bagGain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
        const bagFilter = AC.createBiquadFilter();
        bagFilter.type = 'lowpass';
        bagFilter.frequency.value = 1200;
        bag.connect(bagFilter);
        bagFilter.connect(bagGain);
        bagGain.connect(AC.destination);
        bag.start(now + 0.2);
        bag.stop(now + 0.4);
        break;
      }
      case 'shipStart': {
        // Epic Viking longship activation - horn + oars + wind
        // Epic war horn blast
        const horn = AC.createOscillator();
        const hornGain = AC.createGain();
        horn.type = 'square';
        horn.frequency.setValueAtTime(98, now);
        horn.frequency.linearRampToValueAtTime(147, now + 0.4);
        horn.frequency.setValueAtTime(147, now + 0.8);
        horn.frequency.linearRampToValueAtTime(98, now + 1.2);
        const hornFilter = AC.createBiquadFilter();
        hornFilter.type = 'bandpass';
        hornFilter.frequency.value = 200;
        hornFilter.Q.value = 2;
        hornGain.gain.setValueAtTime(0, now);
        hornGain.gain.linearRampToValueAtTime(0.4, now + 0.2);
        hornGain.gain.setValueAtTime(0.4, now + 0.8);
        hornGain.gain.exponentialRampToValueAtTime(0.01, now + 1.4);
        horn.connect(hornFilter);
        hornFilter.connect(hornGain);
        hornGain.connect(AC.destination);
        horn.start(now);
        horn.stop(now + 1.5);
        
        // Oar splashes (rhythmic water sounds)
        [0.3, 0.6, 0.9].forEach((delay) => {
          const splash = AC.createBufferSource();
          splash.buffer = createNoiseBuffer(0.15);
          const splashFilter = AC.createBiquadFilter();
          splashFilter.type = 'bandpass';
          splashFilter.frequency.value = 1500;
          splashFilter.Q.value = 1.5;
          const splashGain = AC.createGain();
          splashGain.gain.setValueAtTime(0.15, now + delay);
          splashGain.gain.exponentialRampToValueAtTime(0.01, now + delay + 0.2);
          splash.connect(splashFilter);
          splashFilter.connect(splashGain);
          splashGain.connect(AC.destination);
          splash.start(now + delay);
        });
        
        // Wind/air whoosh
        const wind = AC.createBufferSource();
        wind.buffer = createNoiseBuffer(0.8);
        const windFilter = AC.createBiquadFilter();
        windFilter.type = 'lowpass';
        windFilter.frequency.value = 400;
        const windGain = AC.createGain();
        windGain.gain.setValueAtTime(0, now);
        windGain.gain.linearRampToValueAtTime(0.12, now + 0.3);
        windGain.gain.setValueAtTime(0.12, now + 1.0);
        windGain.gain.exponentialRampToValueAtTime(0.01, now + 1.5);
        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(AC.destination);
        wind.start(now);
        break;
      }
      case 'shipDestroy': {
        // Viking ship destroying obstacle - crushing impact
        const crush = AC.createBufferSource();
        crush.buffer = createNoiseBuffer(0.25);
        const crushFilter = AC.createBiquadFilter();
        crushFilter.type = 'lowpass';
        crushFilter.frequency.value = 600;
        const crushGain = AC.createGain();
        crushGain.gain.setValueAtTime(0.5, now);
        crushGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        crush.connect(crushFilter);
        crushFilter.connect(crushGain);
        crushGain.connect(AC.destination);
        crush.start(now);
        
        // Water splash
        const splash = AC.createBufferSource();
        splash.buffer = createNoiseBuffer(0.3);
        const splashFilter = AC.createBiquadFilter();
        splashFilter.type = 'bandpass';
        splashFilter.frequency.value = 1800;
        splashFilter.Q.value = 1.5;
        const splashGain = AC.createGain();
        splashGain.gain.setValueAtTime(0.25, now + 0.05);
        splashGain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        splash.connect(splashFilter);
        splashFilter.connect(splashGain);
        splashGain.connect(AC.destination);
        splash.start(now + 0.05);
        break;
      }
      case 'shipDestroyEnemy': {
        // Viking warriors shouting + destruction when ship destroys enemies
        // Viking battle shout "SKOL!" or "FOR VALHALLA!"
        const shout1 = AC.createOscillator();
        const shout1Gain = AC.createGain();
        shout1.type = 'sawtooth';
        shout1.frequency.setValueAtTime(180, now);
        shout1.frequency.linearRampToValueAtTime(140, now + 0.15);
        const shout1Formant = createFormant(800, 12, 0.5);
        shout1Gain.gain.setValueAtTime(0.3, now);
        shout1Gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        shout1.connect(shout1Formant.filter);
        shout1Formant.gain.connect(shout1Gain);
        shout1Gain.connect(AC.destination);
        shout1.start(now);
        shout1.stop(now + 0.25);
        
        // Second shout
        const shout2 = AC.createOscillator();
        const shout2Gain = AC.createGain();
        shout2.type = 'sawtooth';
        shout2.frequency.setValueAtTime(160, now + 0.1);
        shout2.frequency.linearRampToValueAtTime(120, now + 0.25);
        const shout2Formant = createFormant(700, 10, 0.4);
        shout2Gain.gain.setValueAtTime(0.25, now + 0.1);
        shout2Gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        shout2.connect(shout2Formant.filter);
        shout2Formant.gain.connect(shout2Gain);
        shout2Gain.connect(AC.destination);
        shout2.start(now + 0.1);
        shout2.stop(now + 0.35);
        
        // Crushing impact
        const crush = AC.createBufferSource();
        crush.buffer = createNoiseBuffer(0.2);
        const crushFilter = AC.createBiquadFilter();
        crushFilter.type = 'lowpass';
        crushFilter.frequency.value = 800;
        const crushGain = AC.createGain();
        crushGain.gain.setValueAtTime(0.4, now + 0.15);
        crushGain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        crush.connect(crushFilter);
        crushFilter.connect(crushGain);
        crushGain.connect(AC.destination);
        crush.start(now + 0.15);
        break;
      }
      case 'speedBoost': {
        // Fast whoosh/wind sound for speed boost
        const whoosh = AC.createBufferSource();
        whoosh.buffer = createNoiseBuffer(0.4);
        const whooshFilter = AC.createBiquadFilter();
        whooshFilter.type = 'lowpass';
        whooshFilter.frequency.setValueAtTime(2000, now);
        whooshFilter.frequency.exponentialRampToValueAtTime(400, now + 0.4);
        const whooshGain = AC.createGain();
        whooshGain.gain.setValueAtTime(0, now);
        whooshGain.gain.linearRampToValueAtTime(0.3, now + 0.05);
        whooshGain.gain.setValueAtTime(0.3, now + 0.2);
        whooshGain.gain.exponentialRampToValueAtTime(0.01, now + 0.45);
        whoosh.connect(whooshFilter);
        whooshFilter.connect(whooshGain);
        whooshGain.connect(AC.destination);
        whoosh.start(now);
        break;
      }
      case 'invincibility': {
        // Shield activation - metallic shimmer + protective aura
        // Metallic shimmer
        [0, 0.05, 0.1].forEach((delay, i) => {
          const shimmer = AC.createOscillator();
          const gain = AC.createGain();
          shimmer.type = 'triangle';
          shimmer.frequency.value = 1200 + i * 400;
          gain.gain.setValueAtTime(0, now + delay);
          gain.gain.linearRampToValueAtTime(0.2, now + delay + 0.05);
          gain.gain.exponentialRampToValueAtTime(0.01, now + delay + 0.15);
          const metallic = AC.createBiquadFilter();
          metallic.type = 'bandpass';
          metallic.frequency.value = shimmer.frequency.value;
          metallic.Q.value = 10;
          shimmer.connect(metallic);
          metallic.connect(gain);
          gain.connect(AC.destination);
          shimmer.start(now + delay);
          shimmer.stop(now + delay + 0.2);
        });
        
        // Protective aura - low hum
        const aura = AC.createOscillator();
        const auraGain = AC.createGain();
        aura.type = 'sine';
        aura.frequency.value = 110;
        auraGain.gain.setValueAtTime(0, now);
        auraGain.gain.linearRampToValueAtTime(0.15, now + 0.1);
        auraGain.gain.setValueAtTime(0.15, now + 0.3);
        auraGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        aura.connect(auraGain);
        auraGain.connect(AC.destination);
        aura.start(now);
        aura.stop(now + 0.55);
        break;
      }
    }
  };

  // Background Music
  let musicContext = null;
  let musicPlaying = false;
  let musicNodes = [];
  let musicGain = null;
  
  // Menu Music (separate from gameplay music)
  let menuMusicContext = null;
  let menuMusicPlaying = false;
  let menuMusicNodes = [];
  let menuMusicGain = null;
  let menuMusicMuted = localStorage.getItem('menuMusicMuted') === 'true';
  
  // Level-specific music themes
  const LevelMusicThemes = {
    1: { // Forest - Nature sounds, birds, wind
      baseFreq: 73.4, // D
      scale: [146.8, 174.6, 196, 220, 261.6], // D minor pentatonic
      drumPattern: 'slow',
      atmosphere: 'calm'
    },
    2: { // Village - Fire crackling, battle sounds
      baseFreq: 82.4, // E
      scale: [164.8, 196, 220, 246.9, 293.7], // E minor pentatonic
      drumPattern: 'medium',
      atmosphere: 'tense'
    },
    3: { // Snow - Wind, ice cracking
      baseFreq: 65.4, // C
      scale: [130.8, 155.6, 174.6, 196, 233.1], // C minor pentatonic
      drumPattern: 'slow',
      atmosphere: 'cold'
    },
    4: { // Volcano - Lava bubbling, rumbling
      baseFreq: 87.3, // F
      scale: [174.6, 207.7, 233.1, 261.6, 311.1], // F minor pentatonic
      drumPattern: 'fast',
      atmosphere: 'intense'
    },
    5: { // Valhalla - Epic orchestral, thunder
      baseFreq: 98, // G
      scale: [196, 233.1, 261.6, 293.7, 349.2], // G major pentatonic
      drumPattern: 'epic',
      atmosphere: 'majestic'
    },
    6: { // Ragnarok - Chaos sounds, destruction
      baseFreq: 110, // A
      scale: [220, 261.6, 293.7, 329.6, 392], // A minor pentatonic
      drumPattern: 'chaotic',
      atmosphere: 'chaos'
    },
    7: { // Cosmic - Space sounds, ethereal
      baseFreq: 55, // Low A
      scale: [110, 130.8, 146.8, 174.6, 220], // A minor pentatonic (lower)
      drumPattern: 'slow',
      atmosphere: 'ethereal'
    },
    8: { // Bifrost - Divine sounds, rainbow effects
      baseFreq: 73.4, // D
      scale: [146.8, 174.6, 196, 220, 261.6, 293.7, 329.6], // D major scale
      drumPattern: 'epic',
      atmosphere: 'divine'
    }
  };

  let currentMusicLevel = 1;

  const startVikingMusic = () => {
    if (musicPlaying) return;
    
    try {
      if (!musicContext) {
        musicContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      
      if (musicContext.state === 'suspended') {
        musicContext.resume();
      }
      
      // Master gain for music volume
      musicGain = musicContext.createGain();
      musicGain.gain.setValueAtTime(0.15, musicContext.currentTime);
      musicGain.connect(musicContext.destination);
      
      // Get current level for music theme
      const score = world.score || 0;
      const currentLevel = LevelSystem.levels.slice().reverse().find(l => score >= l.unlockScore) || LevelSystem.levels[0];
      currentMusicLevel = currentLevel.id;
      const theme = LevelMusicThemes[currentMusicLevel] || LevelMusicThemes[1];
      
      // Create a deep, epic Nordic drone
      const createDrone = (freq, type = 'sine') => {
        const osc = musicContext.createOscillator();
        const gain = musicContext.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, musicContext.currentTime);
        gain.gain.setValueAtTime(0.3, musicContext.currentTime);
        osc.connect(gain);
        gain.connect(musicGain);
        osc.start();
        musicNodes.push({ osc, gain });
        return { osc, gain };
      };
      
      // Base drone - level-specific frequency
      createDrone(theme.baseFreq, 'sine');
      createDrone(theme.baseFreq * 2, 'triangle'); // Octave
      createDrone(theme.baseFreq * 1.5, 'sine'); // Fifth
      
      // Slow modulating pad
      const lfo = musicContext.createOscillator();
      const lfoGain = musicContext.createGain();
      lfo.frequency.setValueAtTime(0.1, musicContext.currentTime); // Very slow
      lfoGain.gain.setValueAtTime(20, musicContext.currentTime);
      lfo.connect(lfoGain);
      
      // Connect LFO to drone frequencies for subtle movement
      if (musicNodes[0]) {
        lfoGain.connect(musicNodes[0].osc.frequency);
      }
      lfo.start();
      musicNodes.push({ osc: lfo, gain: lfoGain });
      
      // Level-specific war drum patterns
      const createWarDrum = () => {
        let beatCount = 0;
        const playBeat = () => {
          if (!musicPlaying || !musicContext) return;
          
          const now = musicContext.currentTime;
          beatCount++;
          
          // Level-specific drum patterns
          let drumFreq = 50;
          let drumGainVal = 0.5;
          let nextBeat = 1000;
          
          if (theme.drumPattern === 'slow') {
            drumFreq = 45;
            drumGainVal = 0.4;
            nextBeat = beatCount % 2 === 0 ? 1000 : 1500;
          } else if (theme.drumPattern === 'medium') {
            drumFreq = 55;
            drumGainVal = 0.6;
            nextBeat = beatCount % 2 === 0 ? 700 : 1100;
          } else if (theme.drumPattern === 'fast') {
            drumFreq = 60;
            drumGainVal = 0.7;
            nextBeat = beatCount % 2 === 0 ? 500 : 800;
          } else if (theme.drumPattern === 'epic') {
            drumFreq = 50;
            drumGainVal = 0.8;
            nextBeat = beatCount % 2 === 0 ? 600 : 1000;
          } else if (theme.drumPattern === 'chaotic') {
            drumFreq = 55 + Math.random() * 20;
            drumGainVal = 0.7 + Math.random() * 0.2;
            nextBeat = 400 + Math.random() * 600;
          }
          
          // Main drum hit
          const drum = musicContext.createOscillator();
          const drumGain = musicContext.createGain();
          drum.type = 'sine';
          drum.frequency.setValueAtTime(drumFreq, now);
          drum.frequency.exponentialRampToValueAtTime(drumFreq * 0.5, now + 0.25);
          drumGain.gain.setValueAtTime(drumGainVal, now);
          drumGain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
          drum.connect(drumGain);
          drumGain.connect(musicGain);
          drum.start(now);
          drum.stop(now + 0.5);
          
          // Accent on every 4th beat (stronger)
          if (beatCount % 4 === 1) {
            const accent = musicContext.createOscillator();
            const accentGain = musicContext.createGain();
            accent.type = 'triangle';
            accent.frequency.setValueAtTime(drumFreq * 0.8, now);
            accent.frequency.exponentialRampToValueAtTime(drumFreq * 0.4, now + 0.3);
            accentGain.gain.setValueAtTime(drumGainVal * 1.2, now);
            accentGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
            accent.connect(accentGain);
            accentGain.connect(musicGain);
            accent.start(now);
            accent.stop(now + 0.6);
          }
          
          if (musicPlaying) {
            setTimeout(playBeat, nextBeat);
          }
        };
        playBeat();
      };
      
      createWarDrum();
      
      // Level-specific melody using theme scale
      const playMelody = () => {
        if (!musicPlaying || !musicContext) return;
        
        const notes = theme.scale;
        const note = notes[Math.floor(Math.random() * notes.length)];
        const now = musicContext.currentTime;
        
        const hornOsc = musicContext.createOscillator();
        const hornGain = musicContext.createGain();
        
        // Level-specific oscillator types
        if (theme.atmosphere === 'calm' || theme.atmosphere === 'cold') {
          hornOsc.type = 'sine';
        } else if (theme.atmosphere === 'tense' || theme.atmosphere === 'intense') {
          hornOsc.type = 'sawtooth';
        } else if (theme.atmosphere === 'majestic' || theme.atmosphere === 'divine') {
          hornOsc.type = 'triangle';
        } else {
          hornOsc.type = 'sawtooth';
        }
        
        hornOsc.frequency.setValueAtTime(note, now);
        
        hornGain.gain.setValueAtTime(0, now);
        hornGain.gain.linearRampToValueAtTime(0.1, now + 0.3);
        hornGain.gain.linearRampToValueAtTime(0.08, now + 1);
        hornGain.gain.exponentialRampToValueAtTime(0.01, now + 2);
        
        // Level-specific filter
        const filter = musicContext.createBiquadFilter();
        filter.type = 'lowpass';
        if (theme.atmosphere === 'cold') {
          filter.frequency.setValueAtTime(600, now);
        } else if (theme.atmosphere === 'intense' || theme.atmosphere === 'chaos') {
          filter.frequency.setValueAtTime(1200, now);
        } else if (theme.atmosphere === 'divine') {
          filter.frequency.setValueAtTime(1500, now);
        } else {
          filter.frequency.setValueAtTime(800, now);
        }
        
        hornOsc.connect(filter);
        filter.connect(hornGain);
        hornGain.connect(musicGain);
        hornOsc.start(now);
        hornOsc.stop(now + 2.5);
        
        // Level-specific melody timing
        const melodyDelay = theme.atmosphere === 'calm' ? 4000 : theme.atmosphere === 'chaos' ? 2000 : 3000;
        if (musicPlaying) {
          setTimeout(playMelody, melodyDelay + Math.random() * 2000);
        }
      };
      
      setTimeout(playMelody, 2000);
      
      musicPlaying = true;
    } catch (e) {
      console.error("Error starting music:", e);
    }
  };
  
  const stopVikingMusic = () => {
    musicPlaying = false;
    musicNodes.forEach(node => {
      try {
        if (node.osc) node.osc.stop();
      } catch (e) {}
    });
    musicNodes = [];
    if (musicGain) {
      musicGain.disconnect();
      musicGain = null;
    }
  };
  
  const setMusicVolume = (muted) => {
    if (musicGain) {
      musicGain.gain.setValueAtTime(muted ? 0 : 0.15, musicContext.currentTime);
    }
  };

  // Update music when level changes
  const updateLevelMusic = () => {
    if (!world.started || !musicPlaying || !musicContext) return;
    
    // Use world.currentLevel instead of calculating from score
    const currentLevel = world.currentLevel || 1;
    
    if (currentLevel !== currentMusicLevel) {
      // Level changed - restart music with new theme
      stopVikingMusic();
      currentMusicLevel = currentLevel;
      setTimeout(() => {
        if (world.started) {
          startVikingMusic();
        }
      }, 500);
    }
  };

  // Boss music - more intense
  let bossMusicActive = false;
  const startBossMusic = () => {
    if (bossMusicActive || !musicContext) return;
    
    // Ensure musicGain exists
    if (!musicGain) {
      // Try to initialize music system
      if (!musicPlaying) {
        startVikingMusic();
      }
      // If still null, create it directly
      if (!musicGain && musicContext) {
        try {
          musicGain = musicContext.createGain();
          musicGain.gain.setValueAtTime(0.15, musicContext.currentTime);
          musicGain.connect(musicContext.destination);
        } catch (e) {
          console.warn("Failed to create musicGain:", e);
          return; // Can't initialize, skip boss music
        }
      }
    }
    
    if (!musicGain) return; // Still can't initialize, skip boss music
    
    bossMusicActive = true;
    
    // Increase music intensity for boss
    if (musicGain) {
      try {
        musicGain.gain.linearRampToValueAtTime(0.3, musicContext.currentTime + 0.5);
      } catch (e) {
        console.warn("Failed to ramp music gain:", e);
      }
    }
    
    // Add intense bass drum
    const playBossDrum = () => {
      if (!bossMusicActive || !musicContext || !musicGain) return;
      
      try {
        const now = musicContext.currentTime;
        const bossDrum = musicContext.createOscillator();
        const bossDrumGain = musicContext.createGain();
        bossDrum.type = 'sine';
        bossDrum.frequency.setValueAtTime(30, now);
        bossDrum.frequency.exponentialRampToValueAtTime(15, now + 0.3);
        bossDrumGain.gain.setValueAtTime(0.8, now);
        bossDrumGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        bossDrum.connect(bossDrumGain);
        bossDrumGain.connect(musicGain);
        bossDrum.start(now);
        bossDrum.stop(now + 0.6);
        
        setTimeout(playBossDrum, 600);
      } catch (e) {
        console.warn("Boss music connection failed:", e);
        bossMusicActive = false;
      }
    };
    playBossDrum();
  };

  const stopBossMusic = () => {
    bossMusicActive = false;
    if (musicGain) {
      musicGain.gain.linearRampToValueAtTime(0.15, musicContext.currentTime + 0.5);
    }
  };

  // Victory fanfare when boss defeated
  const playVictoryFanfare = () => {
    if (!musicContext || !OPT.sound) return;
    
    const now = musicContext.currentTime;
    const fanfareNotes = [261.6, 329.6, 392, 523.3]; // C4, E4, G4, C5 (major triad)
    
    fanfareNotes.forEach((freq, i) => {
      const osc = musicContext.createOscillator();
      const gain = musicContext.createGain();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(freq, now + i * 0.1);
      gain.gain.setValueAtTime(0, now + i * 0.1);
      gain.gain.linearRampToValueAtTime(0.3, now + i * 0.1 + 0.1);
      gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.8);
      osc.connect(gain);
      gain.connect(musicContext.destination);
      osc.start(now + i * 0.1);
      osc.stop(now + i * 0.1 + 1);
    });
  };
  
  // Dynamic music intensity based on gameplay
  const updateMusicIntensity = () => {
    if (!musicGain || !musicPlaying || !world.started) return;
    
    // Base volume + intensity scaling
    let intensity = 0.15;
    
    // Higher speed = more intense music
    const speedFactor = Math.min((world.speed - 230) / 170, 1); // 0-1 based on speed
    intensity += speedFactor * 0.1;
    
    // Low lives = more intense
    if (world.lives <= 2) intensity += 0.05;
    if (world.lives === 1) intensity += 0.08;
    
    // Powerups = more intense
    if (world.powerups.vikingShip.active) intensity += 0.1;
    if (world.powerups.speedBoost.active) intensity += 0.05;
    if (world.powerups.invincibility.active) intensity += 0.03;
    
    // Combo = more intense
    if (engagement.combo.count >= 5) intensity += 0.05;
    if (engagement.combo.count >= 10) intensity += 0.05;
    
    // Approaching personal best = intense
    if (engagement.personalBest > 0 && world.score >= engagement.personalBest * 0.9) {
      intensity += 0.08;
    }
    
    const clampedIntensity = Math.min(intensity, 0.4);
    musicGain.gain.linearRampToValueAtTime(clampedIntensity, musicContext.currentTime + 0.1);
  };
  
  // Epic Viking Menu Music
  const startMenuMusic = () => {
    if (menuMusicPlaying || menuMusicMuted) return;
    
    try {
      if (!menuMusicContext) {
        menuMusicContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      
      if (menuMusicContext.state === 'suspended') {
        menuMusicContext.resume();
      }
      
      // Master gain for menu music volume
      menuMusicGain = menuMusicContext.createGain();
      menuMusicGain.gain.setValueAtTime(0.13, menuMusicContext.currentTime);
      menuMusicGain.connect(menuMusicContext.destination);
      
      const now = menuMusicContext.currentTime;
      
      // Deep Nordic war drums - powerful taiko-style
      const createWarDrum = () => {
        let beatCount = 0;
        const playBeat = () => {
          if (!menuMusicPlaying || !menuMusicContext) return;
          
          const beatTime = menuMusicContext.currentTime;
          beatCount++;
          
          // Main drum - deep and powerful
          const drum = menuMusicContext.createOscillator();
          const drumGain = menuMusicContext.createGain();
          const drumFilter = menuMusicContext.createBiquadFilter();
          drumFilter.type = 'lowpass';
          drumFilter.frequency.setValueAtTime(80, beatTime);
          drumFilter.Q.setValueAtTime(2, beatTime);
          
          drum.type = 'sine';
          drum.frequency.setValueAtTime(45, beatTime);
          drum.frequency.exponentialRampToValueAtTime(30, beatTime + 0.3);
          
          drumGain.gain.setValueAtTime(0, beatTime);
          drumGain.gain.linearRampToValueAtTime(0.6, beatTime + 0.05);
          drumGain.gain.exponentialRampToValueAtTime(0.01, beatTime + 0.5);
          
          drum.connect(drumFilter);
          drumFilter.connect(drumGain);
          drumGain.connect(menuMusicGain);
          drum.start(beatTime);
          drum.stop(beatTime + 0.6);
          
          // Accent on every 4th beat (stronger)
          if (beatCount % 4 === 1) {
            const accent = menuMusicContext.createOscillator();
            const accentGain = menuMusicContext.createGain();
            const accentFilter = menuMusicContext.createBiquadFilter();
            accentFilter.type = 'lowpass';
            accentFilter.frequency.setValueAtTime(100, beatTime);
            
            accent.type = 'triangle';
            accent.frequency.setValueAtTime(50, beatTime);
            accent.frequency.exponentialRampToValueAtTime(35, beatTime + 0.4);
            
            accentGain.gain.setValueAtTime(0, beatTime);
            accentGain.gain.linearRampToValueAtTime(0.8, beatTime + 0.05);
            accentGain.gain.exponentialRampToValueAtTime(0.01, beatTime + 0.7);
            
            accent.connect(accentFilter);
            accentFilter.connect(accentGain);
            accentGain.connect(menuMusicGain);
            accent.start(beatTime);
            accent.stop(beatTime + 0.8);
          }
          
          // Secondary drum on off-beats
          if (beatCount % 2 === 0) {
            const secondary = menuMusicContext.createOscillator();
            const secondaryGain = menuMusicContext.createGain();
            secondary.type = 'sine';
            secondary.frequency.setValueAtTime(55, beatTime);
            secondary.frequency.exponentialRampToValueAtTime(40, beatTime + 0.2);
            secondaryGain.gain.setValueAtTime(0, beatTime);
            secondaryGain.gain.linearRampToValueAtTime(0.3, beatTime + 0.03);
            secondaryGain.gain.exponentialRampToValueAtTime(0.01, beatTime + 0.3);
            secondary.connect(secondaryGain);
            secondaryGain.connect(menuMusicGain);
            secondary.start(beatTime);
            secondary.stop(beatTime + 0.4);
          }
          
          // Steady rhythm - not too fast, not too slow
          const nextBeat = beatCount % 4 === 0 ? 900 : 700;
          if (menuMusicPlaying) {
            setTimeout(playBeat, nextBeat);
          }
        };
        playBeat();
      };
      
      // Start with a drum roll
      setTimeout(() => {
        if (menuMusicPlaying) {
          createWarDrum();
        }
      }, 500);
      
      // Epic Viking horn melody - D minor (viking key)
      const vikingScale = [146.8, 174.6, 196, 220, 261.6, 293.7]; // D minor pentatonic + 6th
      let melodyPhase = 0;
      
      const playHornMelody = () => {
        if (!menuMusicPlaying || !menuMusicContext) return;
        
        const noteTime = menuMusicContext.currentTime;
        melodyPhase++;
        
        // Create proper musical phrases (not random)
        let notes = [];
        if (melodyPhase % 4 === 1) {
          // Opening phrase
          notes = [vikingScale[0], vikingScale[2], vikingScale[4], vikingScale[3]];
        } else if (melodyPhase % 4 === 2) {
          // Rising phrase
          notes = [vikingScale[1], vikingScale[3], vikingScale[5], vikingScale[4]];
        } else if (melodyPhase % 4 === 3) {
          // Descending phrase
          notes = [vikingScale[5], vikingScale[4], vikingScale[2], vikingScale[0]];
        } else {
          // Resolution phrase
          notes = [vikingScale[4], vikingScale[2], vikingScale[0], vikingScale[0]];
        }
        
        notes.forEach((note, i) => {
          const playTime = noteTime + (i * 0.6);
          
          // Create horn sound with formant filter (like warhorn SFX)
          const hornOsc = menuMusicContext.createOscillator();
          const hornGain = menuMusicContext.createGain();
          
          // Use formant filters for authentic horn sound
          const formant1 = menuMusicContext.createBiquadFilter();
          const formant2 = menuMusicContext.createBiquadFilter();
          const formant3 = menuMusicContext.createBiquadFilter();
          
          formant1.type = 'bandpass';
          formant1.frequency.setValueAtTime(600, playTime);
          formant1.Q.setValueAtTime(8, playTime);
          
          formant2.type = 'bandpass';
          formant2.frequency.setValueAtTime(1200, playTime);
          formant2.Q.setValueAtTime(6, playTime);
          
          formant3.type = 'bandpass';
          formant3.frequency.setValueAtTime(2400, playTime);
          formant3.Q.setValueAtTime(4, playTime);
          
          hornOsc.type = 'sawtooth';
          hornOsc.frequency.setValueAtTime(note, playTime);
          
          // Smooth attack and decay
          hornGain.gain.setValueAtTime(0, playTime);
          hornGain.gain.linearRampToValueAtTime(0.12, playTime + 0.2);
          hornGain.gain.setValueAtTime(0.1, playTime + 0.4);
          hornGain.gain.exponentialRampToValueAtTime(0.01, playTime + 0.6);
          
          hornOsc.connect(formant1);
          formant1.connect(formant2);
          formant2.connect(formant3);
          formant3.connect(hornGain);
          hornGain.connect(menuMusicGain);
          
          hornOsc.start(playTime);
          hornOsc.stop(playTime + 0.65);
        });
        
        // Next melody phrase
        const melodyDelay = melodyPhase % 4 === 0 ? 3500 : 2800;
        if (menuMusicPlaying) {
          setTimeout(playHornMelody, melodyDelay);
        }
      };
      
      // Start melody after initial drum roll
      setTimeout(() => {
        if (menuMusicPlaying) {
          playHornMelody();
        }
      }, 2000);
      
      // Deep bass drone - foundation
      const createDrone = (freq, type = 'sine') => {
        const osc = menuMusicContext.createOscillator();
        const gain = menuMusicContext.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, now);
        gain.gain.setValueAtTime(0.25, now);
        osc.connect(gain);
        gain.connect(menuMusicGain);
        osc.start();
        menuMusicNodes.push({ osc, gain });
      };
      
      // D minor drone layers
      createDrone(73.4, 'sine'); // D
      createDrone(146.8, 'triangle'); // D octave
      createDrone(110, 'sine'); // A (fifth)
      
      // Subtle ambient layer (wind-like)
      const ambientOsc = menuMusicContext.createOscillator();
      const ambientGain = menuMusicContext.createGain();
      const ambientFilter = menuMusicContext.createBiquadFilter();
      ambientFilter.type = 'lowpass';
      ambientFilter.frequency.setValueAtTime(200, now);
      ambientFilter.Q.setValueAtTime(1, now);
      
      ambientOsc.type = 'sawtooth';
      ambientOsc.frequency.setValueAtTime(65, now);
      
      // Slow LFO for wind effect
      const windLFO = menuMusicContext.createOscillator();
      const windLFOGain = menuMusicContext.createGain();
      windLFO.frequency.setValueAtTime(0.05, now);
      windLFOGain.gain.setValueAtTime(5, now);
      windLFO.connect(windLFOGain);
      windLFOGain.connect(ambientOsc.frequency);
      
      ambientGain.gain.setValueAtTime(0.08, now);
      
      ambientOsc.connect(ambientFilter);
      ambientFilter.connect(ambientGain);
      ambientGain.connect(menuMusicGain);
      
      ambientOsc.start();
      windLFO.start();
      menuMusicNodes.push({ osc: ambientOsc, gain: ambientGain });
      menuMusicNodes.push({ osc: windLFO, gain: windLFOGain });
      
      menuMusicPlaying = true;
    } catch (e) {
      console.error("Error starting menu music:", e);
    }
  };
  
  const stopMenuMusic = () => {
    menuMusicPlaying = false;
    menuMusicNodes.forEach(node => {
      try {
        if (node.osc) node.osc.stop();
      } catch (e) {}
    });
    menuMusicNodes = [];
    if (menuMusicGain) {
      menuMusicGain.disconnect();
      menuMusicGain = null;
    }
  };
  
  const setMenuMusicVolume = (muted) => {
    menuMusicMuted = muted;
    localStorage.setItem('menuMusicMuted', muted ? 'true' : 'false');
    if (menuMusicGain) {
      menuMusicGain.gain.setValueAtTime(muted ? 0 : 0.13, menuMusicContext.currentTime);
    }
    if (muted && menuMusicPlaying) {
      stopMenuMusic();
    } else if (!muted && !menuMusicPlaying && !world.started) {
      startMenuMusic();
    }
  };
  
  // Start menu music on first user interaction
  const startMenuMusicOnInteraction = () => {
    if (!menuMusicPlaying && !menuMusicMuted && !world.started) {
      startMenuMusic();
    }
    document.removeEventListener('click', startMenuMusicOnInteraction);
    document.removeEventListener('keydown', startMenuMusicOnInteraction);
  };
  document.addEventListener('click', startMenuMusicOnInteraction);
  document.addEventListener('keydown', startMenuMusicOnInteraction);
  
  // Start music on first user interaction (for gameplay)
  const startMusicOnInteraction = () => {
    if (!musicPlaying && OPT.sound) {
      startVikingMusic();
    }
    document.removeEventListener('click', startMusicOnInteraction);
    document.removeEventListener('keydown', startMusicOnInteraction);
  };
  document.addEventListener('click', startMusicOnInteraction);
  document.addEventListener('keydown', startMusicOnInteraction);

  const OPT = { sound: true };
  
  // Engagement & Addiction Systems
  const engagement = {
    combo: { count: 0, timer: 0, maxCombo: 0 },
    nearMiss: { count: 0, lastTime: 0 },
    milestones: { last: 0, nextAt: 10000 },
    sessionDeaths: 0,
    personalBest: parseInt(localStorage.getItem('personalBest') || '0'),
    notifiedApproaching: false,
    newRecordShown: false,
    luckySpinAvailable: false,
    streakBonus: 1.0,
    totalSessionScore: 0,
    bestStreak: parseInt(localStorage.getItem('bestStreak') || '0'),
    gamesPlayed: parseInt(localStorage.getItem('gamesPlayed') || '0'),
    lastMilestoneTime: 0,
    // Enhanced progression tracking
    totalPlayTime: parseFloat(localStorage.getItem('totalPlayTime') || '0'),
    levelCompletions: JSON.parse(localStorage.getItem('levelCompletions') || '{}'),
    difficultyCompletions: JSON.parse(localStorage.getItem('difficultyCompletions') || '{}'),
    perfectRuns: parseInt(localStorage.getItem('perfectRuns') || '0'),
    maxComboPerLevel: JSON.parse(localStorage.getItem('maxComboPerLevel') || '{}'),
    sessionStartTime: Date.now()
  };
  
  // Daily Bonus System
  const DailyBonus = {
    rewards: [
      { day: 1, type: 'life', value: 1, label: '+1 Life' },
      { day: 2, type: 'gold', value: 500, label: '+500 Gold' },
      { day: 3, type: 'powerup', value: 'speedBoost', label: 'Speed Boost' },
      { day: 4, type: 'life', value: 2, label: '+2 Lives' },
      { day: 5, type: 'gold', value: 1000, label: '+1000 Gold' },
      { day: 6, type: 'powerup', value: 'invincibility', label: 'Invincibility' },
      { day: 7, type: 'mega', value: null, label: 'MEGA BONUS!' }
    ],
    getStreak() {
      const lastLogin = localStorage.getItem('lastLoginDate');
      const streak = parseInt(localStorage.getItem('loginStreak') || '0');
      const today = new Date().toDateString();
      if (lastLogin === today) return { streak, claimed: true };
      const yesterday = new Date(Date.now() - 86400000).toDateString();
      if (lastLogin === yesterday) return { streak: streak + 1, claimed: false };
      return { streak: 1, claimed: false };
    },
    claim() {
      const { streak, claimed } = this.getStreak();
      if (claimed) return null;
      localStorage.setItem('lastLoginDate', new Date().toDateString());
      localStorage.setItem('loginStreak', Math.min(streak, 7).toString());
      return this.rewards[(streak - 1) % 7];
    }
  };
  
  // Daily Challenges System
  const DailyChallenges = {
    challenges: [],
    init() {
      const today = new Date().toDateString();
      const saved = localStorage.getItem(`dailyChallenges_${today}`);
      if (saved) {
        this.challenges = JSON.parse(saved);
      } else {
        this.generateChallenges();
      }
    },
    generateChallenges() {
      const levels = [1, 2, 3, 4, 5, 6, 7, 8];
      const randomLevel = levels[Math.floor(Math.random() * levels.length)];
      this.challenges = [
        { id: 1, desc: `Defeat 10 enemies in Level ${randomLevel}`, type: 'enemyKills', target: 10, progress: 0, reward: 500, completed: false },
        { id: 2, desc: `Reach ${rand(30000, 80000)} points without taking damage`, type: 'noDamage', target: rand(30000, 80000), progress: 0, reward: 1000, completed: false },
        { id: 3, desc: `Collect 20 mead in one run`, type: 'meadCollect', target: 20, progress: 0, reward: 750, completed: false }
      ];
      const today = new Date().toDateString();
      localStorage.setItem(`dailyChallenges_${today}`, JSON.stringify(this.challenges));
    },
    updateProgress(type, amount) {
      this.challenges.forEach(challenge => {
        if (challenge.type === type && !challenge.completed) {
          challenge.progress += amount;
          if (challenge.progress >= challenge.target) {
            challenge.completed = true;
            world.score += challenge.reward;
            showAchievement({ name: 'Challenge Complete!', desc: challenge.desc, icon: 'üéØ', rarity: 'gold' });
          }
        }
      });
      const today = new Date().toDateString();
      localStorage.setItem(`dailyChallenges_${today}`, JSON.stringify(this.challenges));
    },
    getProgress() {
      return this.challenges.filter(c => !c.completed).length;
    }
  };
  
  // Weekly Challenges System - Maximum Addiction Potential
  const WeeklyChallenges = {
    challenges: [],
    weekStart: null,
    
    getWeekStart() {
      const now = new Date();
      const day = now.getDay();
      const diff = now.getDate() - day; // Sunday = 0
      const weekStart = new Date(now.setDate(diff));
      weekStart.setHours(0, 0, 0, 0);
      return weekStart.toDateString();
    },
    
    init() {
      const weekStart = this.getWeekStart();
      const saved = localStorage.getItem(`weeklyChallenges_${weekStart}`);
      if (saved) {
        this.challenges = JSON.parse(saved);
        this.weekStart = weekStart;
      } else {
        this.generateChallenges();
      }
    },
    
    generateChallenges() {
      const weekStart = this.getWeekStart();
      this.weekStart = weekStart;
      
      // More challenging weekly objectives
      this.challenges = [
        { 
          id: 1, 
          desc: 'Reach 500k points in Extreme mode', 
          type: 'extremeScore', 
          target: 500000, 
          progress: 0, 
          reward: 5000, 
          prestigeReward: 50,
          completed: false 
        },
        { 
          id: 2, 
          desc: 'Defeat 5 bosses in one run', 
          type: 'bossKills', 
          target: 5, 
          progress: 0, 
          reward: 3000,
          prestigeReward: 30,
          completed: false 
        },
        { 
          id: 3, 
          desc: 'Complete a perfect run (no deaths) with 100k+ score', 
          type: 'perfectRun', 
          target: 100000, 
          progress: 0, 
          reward: 4000,
          prestigeReward: 40,
          completed: false 
        },
        { 
          id: 4, 
          desc: 'Reach Prestige level', 
          type: 'prestige', 
          target: 1, 
          progress: 0, 
          reward: 6000,
          prestigeReward: 100,
          completed: false 
        },
        { 
          id: 5, 
          desc: 'Collect 50 mead in one session', 
          type: 'meadCollect', 
          target: 50, 
          progress: 0, 
          reward: 2000,
          prestigeReward: 20,
          completed: false 
        }
      ];
      
      localStorage.setItem(`weeklyChallenges_${weekStart}`, JSON.stringify(this.challenges));
    },
    
    updateProgress(type, amount, score = 0) {
      const weekStart = this.getWeekStart();
      if (weekStart !== this.weekStart) {
        // New week, reset challenges
        this.generateChallenges();
        return;
      }
      
      this.challenges.forEach(challenge => {
        if (challenge.type === type && !challenge.completed) {
          if (type === 'extremeScore' || type === 'perfectRun') {
            // For score-based challenges, update if current score exceeds progress
            if (score > challenge.progress) {
              challenge.progress = score;
            }
          } else {
            challenge.progress += amount;
          }
          
          if (challenge.progress >= challenge.target) {
            challenge.completed = true;
            world.score += challenge.reward;
            PrestigeSystem.points += challenge.prestigeReward || 0;
            localStorage.setItem('prestigePoints', PrestigeSystem.points.toString());
            showAchievement({ 
              name: 'Weekly Challenge Complete!', 
              desc: challenge.desc, 
              icon: 'üèÜ', 
              rarity: 'platinum' 
            });
            showStickinessNotification(`‚≠ê Weekly Challenge: +${challenge.reward.toLocaleString()} pts, +${challenge.prestigeReward} prestige!`, 'info');
          }
        }
      });
      
      localStorage.setItem(`weeklyChallenges_${weekStart}`, JSON.stringify(this.challenges));
    },
    
    getProgress() {
      const weekStart = this.getWeekStart();
      if (weekStart !== this.weekStart) {
        this.generateChallenges();
      }
      return this.challenges.filter(c => !c.completed).length;
    },
    
    getTimeRemaining() {
      const now = new Date();
      const day = now.getDay();
      const daysUntilSunday = 7 - day;
      const nextSunday = new Date(now);
      nextSunday.setDate(now.getDate() + daysUntilSunday);
      nextSunday.setHours(0, 0, 0, 0);
      const msRemaining = nextSunday - now;
      const hours = Math.floor(msRemaining / (1000 * 60 * 60));
      const minutes = Math.floor((msRemaining % (1000 * 60 * 60)) / (1000 * 60));
      return { hours, minutes, total: msRemaining };
    }
  };
  
  // Time-Limited Events System - Maximum Addiction Potential
  const EventSystem = {
    currentEvent: null,
    events: [],
    
    init() {
      const now = new Date();
      const dayOfWeek = now.getDay();
      const hour = now.getHours();
      
      // Weekend events (Friday 6 PM - Sunday 11:59 PM)
      if ((dayOfWeek === 5 && hour >= 18) || dayOfWeek === 6 || (dayOfWeek === 0 && hour < 24)) {
        this.currentEvent = {
          type: 'weekend',
          name: 'Weekend Warrior',
          description: '2x Score Multiplier + Rare Powerups!',
          scoreMultiplier: 2.0,
          powerupFrequency: 0.5, // 2x more frequent
          endTime: this.getWeekendEndTime(),
          icon: 'üî•'
        };
      }
      
      // Monthly boss rush (first weekend of month)
      const firstWeekend = this.getFirstWeekendOfMonth();
      if (now >= firstWeekend && now <= new Date(firstWeekend.getTime() + 2 * 24 * 60 * 60 * 1000)) {
        this.currentEvent = {
          type: 'bossRush',
          name: 'Boss Rush',
          description: 'Bosses spawn 3x more frequently!',
          bossSpawnMultiplier: 3.0,
          endTime: new Date(firstWeekend.getTime() + 2 * 24 * 60 * 60 * 1000),
          icon: 'üëπ'
        };
      }
      
      // Seasonal events (placeholder - can be expanded)
      const month = now.getMonth();
      if (month === 11) { // December
        this.currentEvent = {
          type: 'seasonal',
          name: 'Yule Festival',
          description: 'Holiday-themed powerups and bonuses!',
          scoreMultiplier: 1.5,
          endTime: new Date(now.getFullYear(), 11, 31, 23, 59, 59),
          icon: 'üéÑ'
        };
      }
      
      if (this.currentEvent) {
        localStorage.setItem('currentEvent', JSON.stringify(this.currentEvent));
        showStickinessNotification(`üéâ ${this.currentEvent.icon} ${this.currentEvent.name} Event Active! ${this.currentEvent.description}`, 'info');
      }
    },
    
    getWeekendEndTime() {
      const now = new Date();
      const dayOfWeek = now.getDay();
      const daysUntilSunday = 7 - dayOfWeek;
      const nextSunday = new Date(now);
      nextSunday.setDate(now.getDate() + daysUntilSunday);
      nextSunday.setHours(23, 59, 59, 999);
      return nextSunday;
    },
    
    getFirstWeekendOfMonth() {
      const now = new Date();
      const firstDay = new Date(now.getFullYear(), now.getMonth(), 1);
      const firstDayOfWeek = firstDay.getDay();
      // Find first Friday
      const daysUntilFriday = firstDayOfWeek <= 5 ? (5 - firstDayOfWeek) : (12 - firstDayOfWeek);
      const firstFriday = new Date(firstDay);
      firstFriday.setDate(firstDay.getDate() + daysUntilFriday);
      firstFriday.setHours(18, 0, 0, 0);
      return firstFriday;
    },
    
    isActive() {
      if (!this.currentEvent) return false;
      return new Date() < new Date(this.currentEvent.endTime);
    },
    
    getScoreMultiplier() {
      if (this.isActive() && this.currentEvent.scoreMultiplier) {
        return this.currentEvent.scoreMultiplier;
      }
      return 1.0;
    },
    
    getPowerupFrequencyMultiplier() {
      if (this.isActive() && this.currentEvent.powerupFrequency) {
        return this.currentEvent.powerupFrequency;
      }
      return 1.0;
    },
    
    getBossSpawnMultiplier() {
      if (this.isActive() && this.currentEvent.bossSpawnMultiplier) {
        return this.currentEvent.bossSpawnMultiplier;
      }
      return 1.0;
    },
    
    getTimeRemaining() {
      if (!this.isActive()) return null;
      const msRemaining = new Date(this.currentEvent.endTime) - new Date();
      const hours = Math.floor(msRemaining / (1000 * 60 * 60));
      const minutes = Math.floor((msRemaining % (1000 * 60 * 60)) / (1000 * 60));
      return { hours, minutes, total: msRemaining };
    }
  };
  
  // Level Mastery System
  const LevelMastery = {
    stars: JSON.parse(localStorage.getItem('levelMastery') || '{}'),
    checkLevel(levelId, score, deaths) {
      const key = `level_${levelId}`;
      if (!this.stars[key]) this.stars[key] = 0;
      
      let newStars = 0;
      if (score > 0) newStars = 1; // 1 star for completion
      if (deaths === 0 && score > 0) newStars = 2; // 2 stars for no deaths
      if (deaths === 0 && score >= LevelSystem.levels.find(l => l.id === levelId)?.unlockScore * 2) {
        newStars = 3; // 3 stars for perfect score
      }
      
      if (newStars > this.stars[key]) {
        this.stars[key] = newStars;
        localStorage.setItem('levelMastery', JSON.stringify(this.stars));
        showAchievement({ 
          name: `${newStars} Star Mastery!`, 
          desc: `Level ${levelId} - ${newStars} stars`, 
          icon: '‚≠ê'.repeat(newStars), 
          rarity: newStars === 3 ? 'platinum' : newStars === 2 ? 'gold' : 'silver' 
        });
      }
    },
    getStars(levelId) {
      return this.stars[`level_${levelId}`] || 0;
    }
  };
  
  // Prestige System - Maximum Addiction Potential
  const PrestigeSystem = {
    level: parseInt(localStorage.getItem('prestigeLevel') || '0'),
    points: parseInt(localStorage.getItem('prestigePoints') || '0'),
    upgrades: JSON.parse(localStorage.getItem('prestigeUpgrades') || '{}'),
    
    // Prestige milestones (score thresholds to prestige)
    milestones: [
      50000,    // Prestige 1
      150000,   // Prestige 2
      300000,   // Prestige 3
      600000,   // Prestige 4
      1000000,  // Prestige 5
      2000000,  // Prestige 6
      4000000,  // Prestige 7
      8000000,  // Prestige 8
      15000000, // Prestige 9
      30000000  // Prestige 10+
    ],
    
    getCurrentMilestone() {
      if (this.level >= this.milestones.length) {
        // After prestige 10, each level requires 2x the previous
        const base = this.milestones[this.milestones.length - 1];
        return base * Math.pow(2, this.level - this.milestones.length + 1);
      }
      return this.milestones[this.level];
    },
    
    canPrestige(score) {
      return score >= this.getCurrentMilestone();
    },
    
    calculatePoints(score) {
      // Points = score / 10000, with bonus for difficulty
      const diff = DifficultyModes.getCurrent();
      const basePoints = Math.floor(score / 10000);
      const difficultyMultiplier = {
        easy: 0.5,
        normal: 1.0,
        hard: 2.0,
        extreme: 4.0
      };
      return Math.floor(basePoints * (difficultyMultiplier[diff.name.toLowerCase()] || 1.0));
    },
    
    prestige(score) {
      if (!this.canPrestige(score)) return false;
      
      const pointsEarned = this.calculatePoints(score);
      this.level++;
      this.points += pointsEarned;
      
      localStorage.setItem('prestigeLevel', this.level.toString());
      localStorage.setItem('prestigePoints', this.points.toString());
      
      // Show prestige notification
      showStickinessNotification(`‚≠ê PRESTIGE ${this.level} UNLOCKED! +${pointsEarned.toLocaleString()} Prestige Points`, 'info');
      playSFX('powerup');
      
      return true;
    },
    
    getUpgradeCost(upgradeId) {
      const costs = {
        scoreMultiplier: 100 + (this.upgrades.scoreMultiplier || 0) * 50,
        startingLives: 150 + (this.upgrades.startingLives || 0) * 75,
        powerupFrequency: 200 + (this.upgrades.powerupFrequency || 0) * 100,
        enemySpeedReduction: 250 + (this.upgrades.enemySpeedReduction || 0) * 125
      };
      return costs[upgradeId] || 999999;
    },
    
    buyUpgrade(upgradeId) {
      const cost = this.getUpgradeCost(upgradeId);
      if (this.points < cost) return false;
      
      this.points -= cost;
      this.upgrades[upgradeId] = (this.upgrades[upgradeId] || 0) + 1;
      
      localStorage.setItem('prestigePoints', this.points.toString());
      localStorage.setItem('prestigeUpgrades', JSON.stringify(this.upgrades));
      
      showStickinessNotification(`‚ú® Upgrade Purchased: ${upgradeId}`, 'info');
      return true;
    },
    
    getScoreMultiplier() {
      return 1.0 + (this.upgrades.scoreMultiplier || 0) * 0.1; // +10% per level
    },
    
    getStartingLivesBonus() {
      return this.upgrades.startingLives || 0; // +1 life per level
    },
    
    getPowerupFrequencyBonus() {
      return 1.0 - (this.upgrades.powerupFrequency || 0) * 0.05; // -5% delay per level
    },
    
    getEnemySpeedReduction() {
      return 1.0 - (this.upgrades.enemySpeedReduction || 0) * 0.03; // -3% enemy speed per level
    }
  };
  
  // Unlockables System - Maximum Addiction Potential
  const Unlockables = {
    unlocked: JSON.parse(localStorage.getItem('unlockables') || '[]'),
    
    // Unlock definitions
    definitions: {
      // Character skins
      skin_viking_warrior: { type: 'skin', name: 'Viking Warrior', unlockAt: 50000, icon: '‚öîÔ∏è' },
      skin_berserker: { type: 'skin', name: 'Berserker', unlockAt: 150000, icon: 'üî•' },
      skin_jarl: { type: 'skin', name: 'Jarl', unlockAt: 500000, icon: 'üëë' },
      skin_odin_chosen: { type: 'skin', name: "Odin's Chosen", unlockAt: 2000000, icon: '‚ö°' },
      
      // Titles
      title_novice: { type: 'title', name: 'Viking Novice', unlockAt: 10000, icon: 'üõ°Ô∏è' },
      title_raider: { type: 'title', name: 'Raider', unlockAt: 50000, icon: '‚öîÔ∏è' },
      title_berserker: { type: 'title', name: 'Berserker', unlockAt: 150000, icon: 'üî•' },
      title_dragon_slayer: { type: 'title', name: 'Dragon Slayer', unlockAt: 500000, icon: 'üêâ' },
      title_valhalla_bound: { type: 'title', name: 'Valhalla Bound', unlockAt: 1000000, icon: '‚≠ê' },
      title_ragnarok_slayer: { type: 'title', name: 'Ragnarok Slayer', unlockAt: 5000000, icon: 'üíÄ' },
      
      // Background themes
      theme_fire_realm: { type: 'theme', name: 'Fire Realm', unlockAt: 300000, icon: 'üî•' },
      theme_ice_realm: { type: 'theme', name: 'Ice Realm', unlockAt: 600000, icon: '‚ùÑÔ∏è' },
      theme_valhalla: { type: 'theme', name: 'Valhalla', unlockAt: 2000000, icon: '‚≠ê' },
      
      // Powerup variants (visual only)
      powerup_golden_speed: { type: 'powerupVariant', name: 'Golden Speed Boost', unlockAt: 200000, icon: '‚ö°' },
      powerup_legendary_ship: { type: 'powerupVariant', name: 'Legendary Ship', unlockAt: 1000000, icon: 'üö¢' }
    },
    
    checkUnlocks(score, levelId = null) {
      let newUnlocks = [];
      
      Object.keys(this.definitions).forEach(key => {
        const unlock = this.definitions[key];
        if (!this.unlocked.includes(key)) {
          if (unlock.unlockAt && score >= unlock.unlockAt) {
            this.unlocked.push(key);
            newUnlocks.push(unlock);
          } else if (unlock.unlockLevel && levelId && levelId >= unlock.unlockLevel) {
            this.unlocked.push(key);
            newUnlocks.push(unlock);
          }
        }
      });
      
      if (newUnlocks.length > 0) {
        this.save();
        newUnlocks.forEach(unlock => {
          showAchievement({
            name: 'UNLOCKED!',
            desc: unlock.name,
            icon: unlock.icon,
            rarity: 'platinum'
          });
          showStickinessNotification(`üéâ ${unlock.icon} ${unlock.name} Unlocked!`, 'info');
          playSFX('powerup');
        });
      }
    },
    
    isUnlocked(key) {
      return this.unlocked.includes(key);
    },
    
    save() {
      localStorage.setItem('unlockables', JSON.stringify(this.unlocked));
    },
    
    getUnlockedByType(type) {
      return this.unlocked.filter(key => this.definitions[key]?.type === type);
    }
  };
  
  // Collectibles System
  const Collectibles = {
    runeStones: JSON.parse(localStorage.getItem('runeStones') || '[]'),
    artifacts: JSON.parse(localStorage.getItem('artifacts') || '[]'),
    spawnRuneStone(x, y, levelId) {
      if (Math.random() < 0.02) { // 2% chance
        const id = `rune_${levelId}_${Date.now()}`;
        Golds.push({
          x,
          y: world.groundY - rand(60, 200),
          taken: false,
          rotation: 0,
          value: 0,
          isRuneStone: true,
          runeId: id,
          levelId: levelId
        });
      }
    },
    collectRuneStone(runeId, levelId) {
      if (!this.runeStones.includes(runeId)) {
        this.runeStones.push(runeId);
        localStorage.setItem('runeStones', JSON.stringify(this.runeStones));
        showAchievement({ name: 'Rune Stone Found!', desc: `Level ${levelId} rune collected`, icon: 'üîÆ', rarity: 'bronze' });
      }
    },
    collectArtifact(artifactId) {
      if (!this.artifacts.includes(artifactId)) {
        this.artifacts.push(artifactId);
        localStorage.setItem('artifacts', JSON.stringify(this.artifacts));
        showAchievement({ name: 'Mythical Artifact!', desc: 'Rare artifact collected', icon: '‚ö°', rarity: 'platinum' });
      }
    },
    getProgress() {
      return {
        runeStones: this.runeStones.length,
        artifacts: this.artifacts.length,
        totalRunes: LevelSystem.levels.length * 3, // 3 runes per level
        totalArtifacts: 8 // One per boss
      };
    }
  };
  
  // Difficulty Modes System
  const DifficultyModes = {
    presets: {
      easy: {
        name: 'Easy',
        baseSpeed: 120, // Much slower - very forgiving
        maxSpeed: 200, // Much slower
        enemySpawnMin: 1500, // Much fewer enemies
        enemySpawnMax: 2500, // Much fewer enemies
        comboTimer: 6.0, // Longer combo window
        startingLives: 5, // More lives
        enemySpeedMultiplier: 0.2, // Enemies move much slower
        icon: 'üõ°Ô∏è'
      },
      normal: {
        name: 'Normal',
        baseSpeed: 180, // Moderate speed
        maxSpeed: 320, // Moderate speed
        enemySpawnMin: 1000, // Moderate enemies
        enemySpawnMax: 1800, // Moderate enemies
        comboTimer: 4.0, // Standard combo window
        startingLives: 3, // Standard lives
        enemySpeedMultiplier: 0.35, // Moderate enemy speed
        icon: '‚öîÔ∏è'
      },
      hard: {
        name: 'Hard',
        baseSpeed: 240, // Much faster
        maxSpeed: 400, // Much faster
        enemySpawnMin: 600, // Many enemies
        enemySpawnMax: 1000, // Many enemies
        comboTimer: 2.5, // Shorter combo window
        startingLives: 2, // Fewer lives
        enemySpeedMultiplier: 0.6, // Enemies move much faster
        icon: 'üíÄ'
      },
      extreme: {
        name: 'Extreme',
        baseSpeed: 300, // Extremely fast
        maxSpeed: 480, // Extremely fast
        enemySpawnMin: 400, // Very many enemies
        enemySpawnMax: 700, // Very many enemies
        comboTimer: 1.5, // Very short combo window
        startingLives: 1, // Minimal lives - true challenge
        enemySpeedMultiplier: 0.8, // Enemies move at high speed
        icon: 'üî•'
      }
    },
    getCurrent() {
      return this.presets[world.difficulty] || this.presets.normal;
    },
    apply(difficulty) {
      world.difficulty = difficulty;
      localStorage.setItem('selectedDifficulty', difficulty);
    },
    loadSaved() {
      const saved = localStorage.getItem('selectedDifficulty');
      if (saved && this.presets[saved]) {
        world.difficulty = saved;
      }
    }
  };
  
  // Level System
  const LevelSystem = {
    levels: [
      { id: 1, name: "Fjord Runner", unlockScore: 0, difficulty: "easy", description: "Begin your journey" },
      { id: 2, name: "Raid Master", unlockScore: 10000, difficulty: "easy", description: "Prove your worth" },
      { id: 3, name: "Berserker", unlockScore: 25000, difficulty: "normal", description: "Unleash your fury" },
      { id: 4, name: "Dragon Slayer", unlockScore: 50000, difficulty: "normal", description: "Face the beasts" },
      { id: 5, name: "Valhalla Bound", unlockScore: 100000, difficulty: "hard", description: "Ascend to glory" },
      { id: 6, name: "Ragnarok", unlockScore: 200000, difficulty: "hard", description: "Face the end times" },
      { id: 7, name: "Odin's Trial", unlockScore: 500000, difficulty: "hard", description: "Face the Allfather" },
      { id: 8, name: "Viking God", unlockScore: 1000000, difficulty: "hard", description: "Become a legend" }
    ],
    unlocked: [],
    currentLevel: 1,
    
    init() {
      const saved = localStorage.getItem('unlockedLevels');
      if (saved) {
        this.unlocked = JSON.parse(saved);
      } else {
        this.unlocked = [1]; // Level 1 always unlocked
        this.save();
      }
      const current = localStorage.getItem('currentLevel');
      if (current) {
        this.currentLevel = parseInt(current);
      }
    },
    
    save() {
      localStorage.setItem('unlockedLevels', JSON.stringify(this.unlocked));
      localStorage.setItem('currentLevel', this.currentLevel.toString());
    },
    
    checkUnlocks(score) {
      let newUnlocks = false;
      for (const level of this.levels) {
        if (!this.unlocked.includes(level.id) && score >= level.unlockScore) {
          this.unlocked.push(level.id);
          newUnlocks = true;
          this.showUnlockNotification(level);
        }
      }
      if (newUnlocks) {
        this.save();
        // Update level grid UI if visible
        if (typeof renderLevelGrid === 'function') {
          renderLevelGrid();
        }
      }
    },
    
    showUnlockNotification(level) {
      // Play unlock sound
      playSFX('powerup');
      
      const notification = document.createElement('div');
      notification.className = 'level-unlock-notification';
      notification.style.zIndex = '10001'; // Ensure it's on top
      notification.innerHTML = `
        <div class="level-unlock-content">
          <div class="level-unlock-icon">üéâ</div>
          <div class="level-unlock-text">
            <strong>LEVEL UNLOCKED!</strong><br>
            <span style="font-size: 24px; font-weight: 700; color: #ffd700; margin-top: 8px; display: block;">${level.name}</span>
          </div>
        </div>
      `;
      document.body.appendChild(notification);
      setTimeout(() => notification.classList.add('show'), 10);
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 300);
      }, 4000); // Show for 4 seconds instead of 3
    },
    
    getLevel(id) {
      return this.levels.find(l => l.id === id);
    },
    
    getBestScore(levelId) {
      const key = `level_${levelId}_best`;
      return parseInt(localStorage.getItem(key) || '0');
    },
    
    saveBestScore(levelId, score) {
      const current = this.getBestScore(levelId);
      if (score > current) {
        localStorage.setItem(`level_${levelId}_best`, score.toString());
        return true;
      }
      return false;
    },
    
    async loadExternal() {
      try {
        // Gracefully handle CORS errors when running from file://
        const response = await fetch('levels.json').catch(() => {
          // CORS or file not found - use default levels
          return null;
        });
        
        if (!response || !response.ok) {
          // File doesn't exist or CORS blocked - use default levels
          return;
        }
        if (response.ok) {
          const data = await response.json();
          if (data.levels && Array.isArray(data.levels)) {
            // Merge external levels with defaults
            const existingIds = new Set(this.levels.map(l => l.id));
            for (const extLevel of data.levels) {
              if (!existingIds.has(extLevel.id)) {
                this.levels.push(extLevel);
              }
            }
            this.levels.sort((a, b) => a.unlockScore - b.unlockScore);
          }
        }
      } catch (e) {
        // External file not found, use defaults
      }
    }
  };
  
  // Level Themes System - Unique visuals, enemies, obstacles per level
  const LevelThemes = {
    1: {
      name: 'York',
      bgGradient: ['#87CEEB', '#228B22'],
      groundColor: '#2d5016',
      weather: 'rain',
      parallaxLayers: [
        { speed: 0.2, color: '#B0C4DE' },
        { speed: 0.4, color: '#87CEEB' },
        { speed: 0.6, color: '#90EE90' }
      ],
      enemies: ['vikingScout', 'vikingRaider', 'vikingBerserker'],
      birdEnemies: ['crow'],
      obstacles: ['tree', 'log', 'rock', 'branch'],
      duckObstacles: ['lowBranch'],
      powerups: ['speed', 'invincibility', 'scoreMultiplier'],
      boss: 'troll',
      bossSpawnScore: 5000
    },
    2: {
      name: 'Dublin',
      bgGradient: ['#FF6B35', '#2E2E2E'],
      groundColor: '#3d2914',
      weather: 'smoke',
      parallaxLayers: [
        { speed: 0.3, color: '#8B0000' },
        { speed: 0.5, color: '#FF6B35' },
        { speed: 0.7, color: '#2E2E2E' }
      ],
      enemies: ['vikingWarrior', 'vikingAxeman', 'vikingSpearman'],
      birdEnemies: ['raven'],
      obstacles: ['debris', 'building', 'firePit'],
      duckObstacles: ['axe', 'lowFire'],
      powerups: ['fireResistance', 'doubleJump'],
      boss: 'chief',
      bossSpawnScore: 15000
    },
    3: {
      name: 'Hedeby',
      bgGradient: ['#B0E0E6', '#FFFFFF'],
      groundColor: '#E0E0E0',
      weather: 'snow',
      parallaxLayers: [
        { speed: 0.2, color: '#B0E0E6' },
        { speed: 0.4, color: '#E0F6FF' },
        { speed: 0.6, color: '#FFFFFF' }
      ],
      enemies: ['vikingShieldMaiden', 'vikingVeteran', 'vikingChampion'],
      birdEnemies: ['seagull'],
      obstacles: ['iceBlock', 'snowDrift', 'icicle'],
      duckObstacles: ['icicle', 'snowball'],
      powerups: ['iceResistance', 'slideBoost'],
      boss: 'iceGiant',
      bossSpawnScore: 30000
    },
    4: {
      name: 'Ribe',
      bgGradient: ['#8B0000', '#FF4500'],
      groundColor: '#1a1a1a',
      weather: 'fire',
      parallaxLayers: [
        { speed: 0.3, color: '#4B0000' },
        { speed: 0.5, color: '#8B0000' },
        { speed: 0.7, color: '#FF4500' }
      ],
      enemies: ['vikingEliteWarrior', 'vikingJarl', 'vikingBerserkerElite'],
      birdEnemies: ['eagle'],
      obstacles: ['lavaPool', 'fireGeyser', 'volcanicRock'],
      duckObstacles: ['fireball', 'lavaStream'],
      powerups: ['lavaWalk', 'fireImmunity'],
      boss: 'fireDragon',
      bossSpawnScore: 60000
    },
    5: {
      name: 'Birka',
      bgGradient: ['#FFD700', '#4B0082'],
      groundColor: '#FFD700',
      weather: 'lightning',
      parallaxLayers: [
        { speed: 0.2, color: '#4B0082' },
        { speed: 0.4, color: '#9370DB' },
        { speed: 0.6, color: '#FFD700' }
      ],
      enemies: ['vikingRoyalGuard', 'vikingWarlord', 'vikingLegend'],
      birdEnemies: ['hawk'],
      obstacles: ['lightning', 'goldenBarrier', 'pillar'],
      duckObstacles: ['lowLightning', 'goldenSpear'],
      powerups: ['lightningDash', 'goldenShield'],
      boss: 'valkyrie',
      bossSpawnScore: 120000
    },
    6: {
      name: 'Kaupang',
      bgGradient: ['#FF0000', '#0000FF', '#000000'],
      groundColor: '#2a2a2a',
      weather: 'chaos',
      parallaxLayers: [
        { speed: 0.3, color: '#FF0000' },
        { speed: 0.5, color: '#0000FF' },
        { speed: 0.7, color: '#000000' }
      ],
      enemies: ['vikingMythicalWarrior', 'vikingGodWarrior', 'vikingRagnarok'],
      birdEnemies: ['mythicalRaven', 'phoenix'],
      obstacles: ['fireIce', 'chaosPortal', 'destruction'],
      duckObstacles: ['chaosProjectile', 'lowDestruction'],
      powerups: ['chaosMode', 'elementMastery'],
      boss: 'fenrir',
      bossSpawnScore: 200000
    },
    7: {
      name: "Trondheim",
      bgGradient: ['#4B0082', '#000000'],
      groundColor: '#1a0033',
      weather: 'cosmic',
      parallaxLayers: [
        { speed: 0.2, color: '#000000' },
        { speed: 0.4, color: '#1a0033' },
        { speed: 0.6, color: '#4B0082' }
      ],
      enemies: ['vikingMythicalWarrior', 'vikingGodWarrior', 'vikingRagnarok'],
      birdEnemies: ['mythicalRaven', 'phoenix'],
      obstacles: ['starBarrier', 'blackHole', 'cosmicStorm'],
      duckObstacles: ['lowStar', 'cosmicRay'],
      powerups: ['cosmicDash', 'starShield', 'timeSlow'],
      boss: 'odin',
      bossSpawnScore: 600000
    },
    8: {
      name: 'Uppsala',
      bgGradient: ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'],
      groundColor: '#FFD700',
      weather: 'rainbow',
      parallaxLayers: [
        { speed: 0.2, color: '#9400D3' },
        { speed: 0.4, color: '#4B0082' },
        { speed: 0.6, color: '#FFD700' }
      ],
      enemies: ['vikingMythicalWarrior', 'vikingGodWarrior', 'vikingRagnarok'],
      birdEnemies: ['mythicalRaven', 'phoenix'],
      obstacles: ['divineBarrier', 'rainbowPortal', 'godlyObstacle'],
      duckObstacles: ['lowDivineRay', 'rainbowProjectile'],
      powerups: ['all', 'godMode', 'infiniteDash'],
      boss: 'ragnarokFinal',
      bossSpawnScore: 1200000
    },
    getCurrent() {
      // Ensure world.currentLevel is synced
      if (!world.currentLevel) {
        world.currentLevel = LevelSystem.currentLevel || 1;
      }
      return this[world.currentLevel] || this[1];
    }
  };
  
  // Boss System - 8 Unique Bosses
  const BossData = {
    troll: {
      name: 'King Alfred of Wessex',
      level: 1,
      spawnScore: 5000,
      health: 3,
      maxHealth: 3,
      speed: 0.3,
      size: { width: 80, height: 120 },
      color: '#8B4513',
      crownType: 'simple',
      robeColor: '#654321',
      attacks: [
        { type: 'rockThrow', cooldown: 2000, damage: 1 },
        { type: 'groundSlam', cooldown: 3000, damage: 1 }
      ],
      rewards: { score: 500, mead: 5 }
    },
    chief: {
      name: 'Earl of Mercia',
      level: 2,
      spawnScore: 15000,
      health: 5,
      maxHealth: 5,
      speed: 0.5,
      size: { width: 70, height: 110 },
      color: '#A0522D',
      crownType: 'decorative',
      robeColor: '#8B4513',
      attacks: [
        { type: 'axeThrow', cooldown: 1500, damage: 1 },
        { type: 'charge', cooldown: 4000, damage: 1 },
        { type: 'summon', cooldown: 5000, damage: 0 }
      ],
      rewards: { score: 1000, mead: 10 }
    },
    iceGiant: {
      name: 'King Aethelred',
      level: 3,
      spawnScore: 30000,
      health: 7,
      maxHealth: 7,
      speed: 0.4,
      size: { width: 90, height: 140 },
      color: '#4A5568',
      crownType: 'royal',
      robeColor: '#2D3748',
      attacks: [
        { type: 'iceBreath', cooldown: 2000, damage: 1 },
        { type: 'groundFreeze', cooldown: 3500, damage: 1 },
        { type: 'iceSpikes', cooldown: 4000, damage: 1 }
      ],
      rewards: { score: 2000, mead: 15 }
    },
    fireDragon: {
      name: 'Duke of Northumbria',
      level: 4,
      spawnScore: 60000,
      health: 10,
      maxHealth: 10,
      speed: 0.6,
      size: { width: 120, height: 100 },
      color: '#DC2626',
      crownType: 'ornate',
      robeColor: '#991b1b',
      attacks: [
        { type: 'fireBreath', cooldown: 2000, damage: 1 },
        { type: 'flyDive', cooldown: 4000, damage: 1 },
        { type: 'lavaEruption', cooldown: 5000, damage: 1 }
      ],
      rewards: { score: 5000, mead: 20 }
    },
    valkyrie: {
      name: 'King Edmund',
      level: 5,
      spawnScore: 120000,
      health: 12,
      maxHealth: 12,
      speed: 0.7,
      size: { width: 75, height: 130 },
      color: '#FFD700',
      crownType: 'imperial',
      robeColor: '#B8860B',
      attacks: [
        { type: 'lightningStrike', cooldown: 1500, damage: 1 },
        { type: 'teleport', cooldown: 3000, damage: 0 },
        { type: 'swordBarrage', cooldown: 4000, damage: 1 }
      ],
      rewards: { score: 10000, mead: 25 }
    },
    fenrir: {
      name: 'High King of England',
      level: 6,
      spawnScore: 200000,
      health: 15,
      maxHealth: 15,
      speed: 0.8,
      size: { width: 100, height: 80 },
      color: '#4B0082',
      crownType: 'divine',
      robeColor: '#2D1B69',
      attacks: [
        { type: 'bite', cooldown: 1000, damage: 1 },
        { type: 'howl', cooldown: 3000, damage: 0 },
        { type: 'packSummon', cooldown: 5000, damage: 0 },
        { type: 'chaosBurst', cooldown: 6000, damage: 1 }
      ],
      rewards: { score: 20000, mead: 30 }
    },
    odin: {
      name: 'Emperor of Britannia',
      level: 7,
      spawnScore: 600000,
      health: 20,
      maxHealth: 20,
      speed: 0.9,
      size: { width: 85, height: 150 },
      color: '#FFFFFF',
      crownType: 'divine',
      robeColor: '#C0C0C0',
      attacks: [
        { type: 'gungnirThrow', cooldown: 2000, damage: 1 },
        { type: 'teleport', cooldown: 2500, damage: 0 },
        { type: 'lightningStorm', cooldown: 4000, damage: 1 },
        { type: 'timeFreeze', cooldown: 6000, damage: 0 },
        { type: 'summonRavens', cooldown: 5000, damage: 0 }
      ],
      rewards: { score: 50000, mead: 50 }
    },
    ragnarokFinal: {
      name: 'Supreme Ruler',
      level: 8,
      spawnScore: 1200000,
      health: 30,
      maxHealth: 30,
      speed: 1.0,
      size: { width: 150, height: 180 },
      color: '#FF1493',
      attacks: [
        { type: 'allAttacks', cooldown: 1000, damage: 1 },
        { type: 'ultimateChaos', cooldown: 5000, damage: 2 },
        { type: 'screenWide', cooldown: 8000, damage: 1 }
      ],
      rewards: { score: 100000, mead: 100 }
    }
  };
  
  const spawnBoss = (bossKey) => {
    const bossData = BossData[bossKey];
    if (!bossData) return;
    
    Bosses.push({
      ...bossData,
      bossKey: bossKey, // Store bossKey for drawing
      x: viking.x + W + 100,
      y: world.groundY,
      currentHealth: bossData.health,
      lastAttack: 0,
      attackIndex: 0,
      phase: 1, // 1 = normal, 2 = enraged (50% health), 3 = final (25% health)
      active: true
    });
    
    // Screen shake on boss spawn
    world.screenShake = 1.0;
    playSFX('warhorn');
    startBossMusic();
    
    // Prominent "BOSS IS HERE" notification - only show if no active boss exists
    const hasActiveBoss = Bosses.some(b => b.active && !b.defeated);
    if (!hasActiveBoss) {
      const bossNotification = document.createElement('div');
      bossNotification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #dc2626, #991b1b);
        color: #ffffff;
        padding: 40px 60px;
        border-radius: 20px;
        font-size: 48px;
        font-weight: 900;
        text-align: center;
        z-index: 10000;
        box-shadow: 0 20px 60px rgba(220, 38, 38, 0.6);
        border: 4px solid #fbbf24;
        animation: bossPulse 0.5s ease-in-out;
        pointer-events: none;
      `;
      bossNotification.textContent = `üëπ BOSS IS HERE: ${bossData.name} üëπ`;
      document.body.appendChild(bossNotification);
    
    // Add pulse animation
    const style = document.createElement('style');
    style.textContent = `
      @keyframes bossPulse {
        0%, 100% { transform: translate(-50%, -50%) scale(1); }
        50% { transform: translate(-50%, -50%) scale(1.1); }
      }
    `;
    document.head.appendChild(style);
    
    setTimeout(() => {
      bossNotification.style.transition = 'opacity 0.5s';
      bossNotification.style.opacity = '0';
      setTimeout(() => {
        bossNotification.remove();
        style.remove();
      }, 500);
    }, 3000); // Show for 3 seconds
  };
  
  // Achievement System
  const Achievements = {
    list: {
      // Beginner achievements (instant gratification)
      firstJump: { name: 'First Leap', desc: 'Make your first jump', icon: 'ü¶ò', rarity: 'bronze' },
      firstDuck: { name: 'Head Down', desc: 'Duck for the first time', icon: 'ü¶Ü', rarity: 'bronze' },
      firstMead: { name: 'Thirsty Viking', desc: 'Collect your first mead', icon: 'üç∫', rarity: 'bronze' },
      firstGold: { name: 'First Plunder', desc: 'Collect your first gold coin', icon: 'ü™ô', rarity: 'bronze' },
      firstPowerup: { name: 'Odin\'s Blessing', desc: 'Collect your first powerup', icon: '‚ö°', rarity: 'bronze' },
      tenJumps: { name: 'Bouncy Viking', desc: 'Jump 10 times in one run', icon: 'üèÉ', rarity: 'bronze' },
      surviveMinute: { name: 'Minute Warrior', desc: 'Survive for 60 seconds', icon: '‚è±Ô∏è', rarity: 'bronze' },
      
      // Score milestones (1k, 5k, 10k, 25k, 50k, 100k, 500k, 1M, 5M, 10M)
      score1k: { name: 'Viking Initiate', desc: 'Reach 1,000 points', icon: 'üå±', rarity: 'bronze' },
      score5k: { name: 'Fjord Runner', desc: 'Reach 5,000 points', icon: 'üèîÔ∏è', rarity: 'bronze' },
      score10k: { name: 'Shield Bearer', desc: 'Reach 10,000 points', icon: 'üõ°Ô∏è', rarity: 'bronze' },
      score25k: { name: 'Nordic Warrior', desc: 'Reach 25,000 points', icon: '‚öîÔ∏è', rarity: 'silver' },
      score50k: { name: 'Viking Veteran', desc: 'Reach 50,000 points', icon: 'üó°Ô∏è', rarity: 'silver' },
      score100k: { name: 'Viking Legend', desc: 'Reach 100,000 points', icon: 'üëë', rarity: 'gold' },
      score500k: { name: 'Odin\'s Chosen', desc: 'Reach 500,000 points', icon: 'üèÜ', rarity: 'gold' },
      score1m: { name: 'Valhalla Warrior', desc: 'Reach 1,000,000 points', icon: 'üíé', rarity: 'platinum' },
      score5m: { name: 'Legendary Viking', desc: 'Reach 5,000,000 points', icon: 'üåü', rarity: 'platinum' },
      score10m: { name: 'God of War', desc: 'Reach 10,000,000 points', icon: '‚ö°', rarity: 'platinum' },
      
      // Other bronze achievements
      firstBlood: { name: 'First Blood', desc: 'Stomp your first enemy', icon: '‚öîÔ∏è', rarity: 'bronze' },
      goldRush: { name: 'Plunder Master', desc: 'Collect 10 gold coins in one run', icon: 'üí∞', rarity: 'bronze' },
      meadLover: { name: 'Mead Lover', desc: 'Collect 50 mead in one run', icon: 'üç∫', rarity: 'bronze' },
      closeCall: { name: 'Narrow Escape', desc: 'Survive 10 near misses in one run', icon: 'üò∞', rarity: 'bronze' },
      level2: { name: 'Raid Master', desc: 'Complete Level 2', icon: 'üõ°Ô∏è', rarity: 'bronze' },
      level3: { name: 'Berserker', desc: 'Complete Level 3', icon: '‚öîÔ∏è', rarity: 'bronze' },
      
      // Level-specific boss achievements
      boss1: { name: 'Forest Troll Slayer', desc: 'Defeat the Forest Troll', icon: 'üå≤', rarity: 'bronze' },
      boss2: { name: 'Saxon Conqueror', desc: 'Defeat the Saxon Warlord', icon: '‚öîÔ∏è', rarity: 'bronze' },
      boss3: { name: 'Frost Giant Slayer', desc: 'Defeat the Frost Giant', icon: '‚ùÑÔ∏è', rarity: 'silver' },
      boss4: { name: 'Fire Giant Slayer', desc: 'Defeat the Fire Giant', icon: 'üî•', rarity: 'silver' },
      boss5: { name: 'Einherjar Champion', desc: 'Defeat the Einherjar Warrior', icon: '‚ö°', rarity: 'gold' },
      boss6: { name: 'Fenrir Slayer', desc: 'Defeat Fenrir', icon: 'üê∫', rarity: 'gold' },
      boss7: { name: 'Odin\'s Challenger', desc: 'Defeat Odin\'s Trial Boss', icon: 'üëÅÔ∏è', rarity: 'platinum' },
      boss8: { name: 'God Slayer', desc: 'Defeat the Final Boss', icon: '‚ö°', rarity: 'platinum' },
      
      // Silver achievements
      comboMaster: { name: 'Combo Master', desc: 'Get a 10x combo streak', icon: 'üî•', rarity: 'silver' },
      captain: { name: 'Ship Captain', desc: 'Destroy 5 enemies with Viking ship', icon: '‚õµ', rarity: 'silver' },
      level4: { name: 'Dragon Slayer', desc: 'Complete Level 4', icon: 'üêâ', rarity: 'silver' },
      combo20: { name: 'Combo Fury', desc: 'Get a 20x combo streak', icon: 'üî•', rarity: 'silver' },
      goldCollector: { name: 'Gold Collector', desc: 'Collect 100 gold coins total', icon: 'üíé', rarity: 'silver' },
      meadMaster: { name: 'Mead Master', desc: 'Collect 500 mead total', icon: 'üçª', rarity: 'silver' },
      hardMode: { name: 'Hard Mode Warrior', desc: 'Reach 50k points on Hard difficulty', icon: 'üíÄ', rarity: 'silver' },
      
      // Gold achievements
      level5: { name: 'Valhalla Bound', desc: 'Complete Level 5', icon: '‚ö°', rarity: 'gold' },
      combo50: { name: 'Combo God', desc: 'Get a 50x combo streak', icon: 'üî•', rarity: 'gold' },
      level6: { name: 'Ragnarok', desc: 'Complete Level 6', icon: 'üåã', rarity: 'gold' },
      streak5: { name: 'Dedicated Raider', desc: '5-day login streak', icon: 'üìÖ', rarity: 'gold' },
      playtime1h: { name: 'Hour Warrior', desc: 'Play for 1 hour total', icon: '‚è∞', rarity: 'gold' },
      nearMissMaster: { name: 'Dodge Master', desc: 'Survive 50 near misses total', icon: 'üéØ', rarity: 'gold' },
      
      // Platinum achievements
      combo100: { name: 'Combo Deity', desc: 'Get a 100x combo streak', icon: 'üî•', rarity: 'platinum' },
      streak30: { name: 'Unstoppable Raider', desc: '30-day login streak', icon: 'üî•', rarity: 'platinum' },
      playtime10h: { name: 'Viking Veteran', desc: 'Play for 10 hours total', icon: '‚öîÔ∏è', rarity: 'platinum' },
      allLevels: { name: 'Level Master', desc: 'Complete all levels', icon: 'üåü', rarity: 'platinum' },
      hardLegend: { name: 'Hard Legend', desc: 'Reach 100k points on Hard difficulty', icon: 'üíÄ', rarity: 'platinum' }
    },
    unlocked: JSON.parse(localStorage.getItem('achievements') || '{}'),
    sessionStats: { 
      stomps: 0, gold: 0, shipKills: 0, nearMisses: 0,
      jumps: 0, ducks: 0, powerupsCollected: 0, timeSurvived: 0, meadCollected: 0,
      bossKills: 0
    },
    totalStats: {
      gold: parseInt(localStorage.getItem('totalGold') || '0'),
      mead: parseInt(localStorage.getItem('totalMead') || '0'),
      nearMisses: parseInt(localStorage.getItem('totalNearMisses') || '0'),
      playtime: parseInt(localStorage.getItem('totalPlaytime') || '0')
    },
    unlock(id) {
      if (this.unlocked[id]) return false;
      this.unlocked[id] = Date.now();
      localStorage.setItem('achievements', JSON.stringify(this.unlocked));
      showAchievement(this.list[id]);
      // Award points for achievement unlock
      const achievement = this.list[id];
      if (achievement) {
        const points = achievement.rarity === 'platinum' ? 10000 : 
                      achievement.rarity === 'gold' ? 5000 :
                      achievement.rarity === 'silver' ? 2000 : 1000;
        world.score += points;
        updateHUD();
      }
      return true;
    },
    check() {
      const s = this.sessionStats;
      const t = this.totalStats;
      
      // Beginner achievements (instant gratification)
      if (s.jumps >= 1) this.unlock('firstJump');
      if (s.ducks >= 1) this.unlock('firstDuck');
      if (s.meadCollected >= 1) this.unlock('firstMead');
      if (s.gold >= 1) this.unlock('firstGold');
      if (s.powerupsCollected >= 1) this.unlock('firstPowerup');
      if (s.jumps >= 10) this.unlock('tenJumps');
      if (s.timeSurvived >= 60) this.unlock('surviveMinute');
      
      // Score milestones (1k, 5k, 10k, 25k, 50k, 100k, 500k, 1M, 5M, 10M)
      if (world.score >= 1000) this.unlock('score1k');
      if (world.score >= 5000) this.unlock('score5k');
      if (world.score >= 10000) this.unlock('score10k');
      if (world.score >= 25000) this.unlock('score25k');
      if (world.score >= 50000) this.unlock('score50k');
      if (world.score >= 100000) this.unlock('score100k');
      if (world.score >= 500000) this.unlock('score500k');
      if (world.score >= 1000000) this.unlock('score1m');
      if (world.score >= 5000000) this.unlock('score5m');
      if (world.score >= 10000000) this.unlock('score10m');
      
      // Bronze achievements
      if (s.stomps >= 1) this.unlock('firstBlood');
      if (s.gold >= 10) this.unlock('goldRush');
      if (world.mead >= 50) this.unlock('meadLover');
      if (s.nearMisses >= 10) this.unlock('closeCall');
      if (LevelSystem.unlocked.includes(2)) this.unlock('level2');
      if (LevelSystem.unlocked.includes(3)) this.unlock('level3');
      
      // Silver achievements
      if (engagement.combo.maxCombo >= 10) this.unlock('comboMaster');
      if (s.shipKills >= 5) this.unlock('captain');
      if (LevelSystem.unlocked.includes(4)) this.unlock('level4');
      if (engagement.combo.maxCombo >= 20) this.unlock('combo20');
      if (t.gold >= 100) this.unlock('goldCollector');
      if (t.mead >= 500) this.unlock('meadMaster');
      if (world.score >= 50000 && world.difficulty === 'hard') this.unlock('hardMode');
      
      // Gold achievements
      if (LevelSystem.unlocked.includes(5)) this.unlock('level5');
      if (engagement.combo.maxCombo >= 50) this.unlock('combo50');
      if (LevelSystem.unlocked.includes(6)) this.unlock('level6');
      // Check boss kills achievement - must kill 5 bosses in one run
      if (s.bossKills >= 5) this.unlock('boss5');
      const streak = parseInt(localStorage.getItem('loginStreak') || '0');
      if (streak >= 5) this.unlock('streak5');
      if (t.playtime >= 3600) this.unlock('playtime1h');
      if (t.nearMisses >= 50) this.unlock('nearMissMaster');
      
      // Platinum achievements
      if (engagement.combo.maxCombo >= 100) this.unlock('combo100');
      if (streak >= 30) this.unlock('streak30');
      if (t.playtime >= 36000) this.unlock('playtime10h');
      if (LevelSystem.unlocked.length >= LevelSystem.levels.length) this.unlock('allLevels');
      if (world.score >= 100000 && world.difficulty === 'hard') this.unlock('hardLegend');
    },
    reset() {
      this.sessionStats = { 
        stomps: 0, gold: 0, shipKills: 0, nearMisses: 0,
        jumps: 0, ducks: 0, powerupsCollected: 0, timeSurvived: 0, meadCollected: 0
      };
    }
  };
  
  // Show achievement popup with rarity-based styling
  const showAchievement = (achievement) => {
    const rarityColors = {
      bronze: '#cd7f32',
      silver: '#c0c0c0',
      gold: '#ffd700',
      platinum: '#e5e4e2'
    };
    const color = rarityColors[achievement.rarity] || '#ffd700';
    const popup = document.createElement('div');
    popup.className = 'achievement-popup';
    popup.style.borderColor = color;
    popup.innerHTML = `<span class="achievement-icon">${achievement.icon}</span><div><strong style="color:${color}">${achievement.name}</strong><br><small>${achievement.desc}</small></div>`;
    document.body.appendChild(popup);
    setTimeout(() => popup.classList.add('show'), 10);
    setTimeout(() => {
      popup.classList.remove('show');
      setTimeout(() => popup.remove(), 300);
    }, 3000);
    playSFX('powerup');
  };
  
  const world = { 
    started: false, paused: false, over: false, 
    score: 0, mead: 0, speed: 200, t: 0, groundY: 0, camX: 0,
    lives: 3, screenShake: 0, goldenRun: false, goldenRunTimer: 0,
    difficulty: 'normal', currentLevel: 1,
    nextObstacleAt: 0, nextMeadAt: 0, nextPowerupAt: 0, nextPlatformAt: 0, nextEnemyAt: 0, nextBirdAt: 0, nextHeartAt: 0, nextGoldAt: 0,
    bossSpawnsThisLevel: {}, // Track which bosses have spawned this level
    powerups: {
      speedBoost: { active: false, timeLeft: 0 },
      invincibility: { active: false, timeLeft: 0 },
      scoreMultiplier: { active: false, timeLeft: 0, multiplier: 1 },
      vikingShip: { active: false, timeLeft: 0 },
      respawn: { count: 0 }, // Count of respawns collected (each gives 1 life)
      respawnPlus: { count: 0 } // Rare respawn that gives 3 lives
    }
  };

  const viking = {
    x: 100, y: 0, vy: 0, w: 50, h: 70, 
    onGround: false, ducking: false, faceplant: 0,
    jumpsUsed: 0, maxJumps: 1
  };

  const Obstacles = [];
  const DuckObstacles = []; // Flying obstacles that require ducking
  const Meads = [];
  const Powerups = [];
  const Particles = [];
  const Platforms = [];
  const Enemies = [];
  const Hearts = [];
  const Golds = [];
  const Bosses = []; // Active bosses

  const spawnObstacle = (x) => {
    const theme = LevelThemes.getCurrent();
    const availableObstacles = theme.obstacles || ['tree', 'rock'];
    
    // Map obstacle names to types
    const obstacleTypes = {
      'tree': 'tree',
      'log': 'log',
      'rock': 'rock',
      'branch': 'branch',
      'debris': 'rock',
      'building': 'shield',
      'firePit': 'rock',
      'iceBlock': 'rock',
      'snowDrift': 'rock',
      'icicle': 'rock',
      'lavaPool': 'rock',
      'fireGeyser': 'rock',
      'volcanicRock': 'rock',
      'lightning': 'rock',
      'goldenBarrier': 'shield',
      'pillar': 'shield',
      'fireIce': 'rock',
      'chaosPortal': 'shield',
      'destruction': 'rock',
      'starBarrier': 'shield',
      'blackHole': 'shield',
      'cosmicStorm': 'rock',
      'divineBarrier': 'shield',
      'rainbowPortal': 'shield',
      'godlyObstacle': 'shield'
    };
    
    const obstacleType = availableObstacles[Math.floor(Math.random() * availableObstacles.length)];
    const type = obstacleTypes[obstacleType] || 'rock';
    Obstacles.push({ x, type, themeType: obstacleType, w: 45, h: 45, hit: false });
  };
  
  const spawnDuckObstacle = (x) => {
    // Only Viking-themed weapons - removed fireball (not Viking-themed)
    const types = ['raven', 'arrow', 'branch', 'axe', 'spear'];
    const type = types[Math.floor(Math.random() * types.length)];
    const y = world.groundY - 70; // Fixed head height - requires ducking
    DuckObstacles.push({ 
      x, 
      y, 
      type, 
      w: type === 'arrow' ? 30 : type === 'spear' ? 50 : 40, 
      h: type === 'branch' ? 25 : 20,
      vx: -world.speed * 0.8, // Slightly slower than ground obstacles
      hit: false 
    });
  };

  const spawnMead = (x) => {
    Meads.push({ x, y: world.groundY - rand(40, 160), taken: false, rotation: 0 });
  };

  const spawnPowerup = (x) => {
    const theme = LevelThemes.getCurrent();
    const availablePowerups = theme.powerups || ['speed', 'invincibility', 'scoreMultiplier'];
    
    // Map theme powerup names to actual powerup types
    const powerupMap = {
      'speed': 'speedBoost',
      'invincibility': 'invincibility',
      'scoreMultiplier': 'scoreMultiplier',
      'fireResistance': 'speedBoost', // Use speedBoost as placeholder
      'doubleJump': 'invincibility',
      'iceResistance': 'speedBoost',
      'slideBoost': 'speedBoost',
      'lavaWalk': 'speedBoost',
      'fireImmunity': 'invincibility',
      'lightningDash': 'speedBoost',
      'goldenShield': 'invincibility',
      'chaosMode': 'scoreMultiplier',
      'elementMastery': 'scoreMultiplier',
      'cosmicDash': 'speedBoost',
      'starShield': 'invincibility',
      'timeSlow': 'scoreMultiplier',
      'all': 'vikingShip',
      'godMode': 'vikingShip',
      'infiniteDash': 'speedBoost'
    };
    
    // Weighted selection from available powerups
    const weights = {};
    availablePowerups.forEach(p => {
      const mappedType = powerupMap[p] || 'speedBoost';
      weights[mappedType] = (weights[mappedType] || 0) + 1;
    });
    
    // Always include vikingShip as rare option
    weights.vikingShip = (weights.vikingShip || 0) + 5;
    // Always include respawn as rare option
    weights.respawn = (weights.respawn || 0) + 3;
    // Very rare respawnPlus (gives 3 lives)
    weights.respawnPlus = (weights.respawnPlus || 0) + 1;
    // Score powerup - instant points (weighted values)
    weights.scorePowerup = 8; // Common powerup
    
    const total = Object.values(weights).reduce((a, b) => a + b, 0);
    let roll = Math.random() * total;
    let type = 'speedBoost';
    for (const [key, weight] of Object.entries(weights)) {
      roll -= weight;
      if (roll <= 0) { type = key; break; }
    }
    
    // For score powerup, assign weighted value
    let scoreValue = 500; // Default
    if (type === 'scorePowerup') {
      const scoreRoll = Math.random();
      if (scoreRoll < 0.40) scoreValue = 500;      // 40% chance - 500 points
      else if (scoreRoll < 0.80) scoreValue = 1000; // 40% chance - 1000 points
      else if (scoreRoll < 0.95) scoreValue = 5000; // 15% chance - 5000 points (rare)
      else scoreValue = 10000;                       // 5% chance - 10000 points (very rare)
    }
    
    Powerups.push({ 
      x, 
      y: world.groundY - rand(60, 180), 
      type, 
      value: type === 'scorePowerup' ? scoreValue : undefined, // Store score value
      taken: false,
      rotation: 0,
      pulse: 0
    });
  };

  const spawnPlatform = (x) => {
    const width = rand(80, 150);
    const height = 20;
    // Sometimes spawn low platforms that require ducking (at ground level or slightly above)
    const isLowPlatform = Math.random() < 0.5; // 50% chance - more duck scenarios
    const y = isLowPlatform ? world.groundY - rand(30, 50) : world.groundY - rand(100, 250);
    // Randomly select Viking-themed platform type
    const platformTypes = ['shield', 'log', 'barrel', 'stone'];
    const type = platformTypes[Math.floor(Math.random() * platformTypes.length)];
    Platforms.push({ x, y, width, height, isLow: isLowPlatform, type });
  };

  // Viking enemy properties - unique Viking warriors per level
  // Moved to global scope so both spawnEnemy() and drawEnemy() can access it
  const enemyProps = {
    // Level 1: Basic Viking raiders
    vikingScout: { w: 75, h: 90, speed: 0.8, color: '#8B4513', tier: 1, weapon: 'axe' },
    vikingRaider: { w: 75, h: 90, speed: 0.9, color: '#654321', tier: 1, weapon: 'sword' },
    vikingBerserker: { w: 85, h: 95, speed: 1.1, color: '#8B0000', tier: 1, weapon: 'axe' },
    
    // Level 2: Viking warriors
    vikingWarrior: { w: 85, h: 100, speed: 1.0, color: '#4A5568', tier: 2, weapon: 'sword' },
    vikingAxeman: { w: 85, h: 100, speed: 0.9, color: '#2D3748', tier: 2, weapon: 'axe' },
    vikingSpearman: { w: 80, h: 100, speed: 1.0, color: '#1A202C', tier: 2, weapon: 'spear' },
    
    // Level 3: Experienced Vikings
    vikingShieldMaiden: { w: 80, h: 100, speed: 1.1, color: '#553C9A', tier: 3, weapon: 'sword' },
    vikingVeteran: { w: 90, h: 105, speed: 0.8, color: '#4A5568', tier: 3, weapon: 'axe' },
    vikingChampion: { w: 90, h: 110, speed: 1.0, color: '#2D3748', tier: 3, weapon: 'sword' },
    
    // Level 4: Elite Vikings
    vikingEliteWarrior: { w: 95, h: 115, speed: 0.9, color: '#1A202C', tier: 4, weapon: 'sword' },
    vikingJarl: { w: 95, h: 115, speed: 0.8, color: '#FFD700', tier: 4, weapon: 'axe' },
    vikingBerserkerElite: { w: 95, h: 110, speed: 1.2, color: '#DC2626', tier: 4, weapon: 'axe' },
    
    // Level 5: Legendary Vikings
    vikingRoyalGuard: { w: 95, h: 115, speed: 0.9, color: '#4A5568', tier: 5, weapon: 'sword' },
    vikingWarlord: { w: 100, h: 120, speed: 0.8, color: '#2D3748', tier: 5, weapon: 'axe' },
    vikingLegend: { w: 100, h: 120, speed: 1.0, color: '#FFD700', tier: 5, weapon: 'sword' },
    
    // Level 6+: Mythical Vikings
    vikingMythicalWarrior: { w: 100, h: 120, speed: 1.0, color: '#4B0082', tier: 6, weapon: 'sword' },
    vikingGodWarrior: { w: 105, h: 125, speed: 1.1, color: '#FFD700', tier: 6, weapon: 'axe' },
    vikingRagnarok: { w: 110, h: 130, speed: 1.2, color: '#DC2626', tier: 6, weapon: 'axe' }
  };

  // Historical enemies Vikings fought - unique per level
  const spawnEnemy = (x) => {
    const theme = LevelThemes.getCurrent();
    const currentLevel = world.currentLevel || 1;
    const enemyTypes = theme.enemies || [];
    if (enemyTypes.length === 0) {
      console.warn('No enemies defined for level', currentLevel);
      return; // No enemies if array is empty
    }
    
    const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
    
    const props = enemyProps[enemyType];
    if (!props) {
      console.warn('Enemy type not found:', enemyType, 'for level', currentLevel);
      return; // Skip if enemy type not found
    }
    
    // All ground enemies spawn at ground level
    const enemy = {
      x,
      y: world.groundY,
      w: props.w,
      h: props.h,
      type: enemyType,
      speed: props.speed,
      color: props.color,
      tier: props.tier,
      weapon: props.weapon || 'axe', // Viking weapon type
      defeated: false,
      hit: false,
      isBird: false // Ground enemies are not birds
    };
    
    Enemies.push(enemy);
    console.log('Spawned enemy:', enemyType, 'at x:', x, 'y:', enemy.y);
  };
  
  // Bird enemies - level-specific, can duck under, jump over, or kill
  const spawnBirdEnemy = (x) => {
    const currentLevel = world.currentLevel || 1;
    const theme = LevelThemes.getCurrent();
    const birdTypes = theme.birdEnemies || [];
    if (birdTypes.length === 0) return;
    
    const birdType = birdTypes[Math.floor(Math.random() * birdTypes.length)];
    
    // Bird properties per level
    const birdProps = {
      // Level 1: Crows (small, slow)
      crow: { w: 50, h: 40, speed: 1.2, color: '#000000', height: 'low', level: 1 },
      // Level 2: Ravens (medium, medium speed)
      raven: { w: 60, h: 50, speed: 1.5, color: '#000000', height: 'medium', level: 2 },
      // Level 3: Seagulls (medium, fast)
      seagull: { w: 55, h: 45, speed: 1.8, color: '#FFFFFF', height: 'medium', level: 3 },
      // Level 4: Eagles (large, very fast)
      eagle: { w: 80, h: 70, speed: 2.0, color: '#8B4513', height: 'high', level: 4 },
      // Level 5: Hawks (medium, very fast, aggressive)
      hawk: { w: 65, h: 55, speed: 2.2, color: '#654321', height: 'high', level: 5 },
      // Level 6+: Mythical birds
      mythicalRaven: { w: 90, h: 80, speed: 2.5, color: '#4B0082', height: 'high', level: 6 },
      phoenix: { w: 100, h: 90, speed: 2.3, color: '#FF4500', height: 'medium', level: 6 }
    };
    
    const props = birdProps[birdType];
    if (!props) return;
    
    // Determine spawn height based on bird type
    let spawnY;
    if (props.height === 'low') {
      spawnY = world.groundY - rand(40, 60); // Duck under
    } else if (props.height === 'medium') {
      spawnY = world.groundY - rand(80, 120); // Jump over or duck
    } else {
      spawnY = world.groundY - rand(140, 180); // Must jump over
    }
    
    Enemies.push({
      x,
      y: spawnY,
      w: props.w,
      h: props.h,
      type: birdType,
      speed: props.speed,
      color: props.color,
      isBird: true,
      defeated: false,
      hit: false
    });
  };


  const spawnHeart = (x) => {
    Hearts.push({
      x,
      y: world.groundY - rand(50, 150),
      taken: false,
      pulse: 0,
      rotation: 0
    });
  };

  const spawnGold = (x) => {
    Golds.push({
      x,
      y: world.groundY - rand(60, 200),
      taken: false,
      rotation: 0,
      value: Math.floor(rand(500, 5000))
    });
  };

  const addParticle = (x, y, color, count = 5) => {
    for (let i = 0; i < count; i++) {
      Particles.push({
        x, y,
        vx: rand(-120, 120),
        vy: rand(-180, -60),
        life: 1,
        color,
        size: rand(4, 10)
      });
    }
  };

  const resetWorld = () => {
    try {
      // Stop all powerup sounds when resetting
      for (const key in powerupSounds) {
        try {
          stopPowerupSound(key);
        } catch (e) {
          console.warn("Error stopping powerup sound:", e);
        }
      }
      
      // Stop boss music
      try {
        stopBossMusic();
        bossMusicActive = false;
      } catch (e) {
        console.warn("Error stopping boss music:", e);
      }
      
      // Stop Viking music
      try {
        stopVikingMusic();
      } catch (e) {
        console.warn("Error stopping Viking music:", e);
      }
      
      resize(); // Always resize to ensure H is set
      if (!H || H === 0) {
        setTimeout(resetWorld, 10);
        return;
      }
      
      world.started = false;
      world.paused = false;
      world.over = false;
      world.score = 0; 
      world.mead = 0;
      world.timeInCurrentLevel = 0; // Track time in current level for boss spawning
      world.previousLevel = world.currentLevel || 1;
      
      // Apply difficulty preset
      const diff = DifficultyModes.getCurrent();
      world.speed = diff.baseSpeed;
      world.t = 0;
      world.screenShake = 0;
      world.goldenRun = false;
      world.goldenRunTimer = 0;
      
      // Reset engagement systems
      engagement.combo = { count: 0, timer: 0, maxCombo: 0 };
      engagement.nearMiss = { count: 0, lastTime: 0 };
      engagement.milestones = { last: 0, nextAt: 10000 };
      engagement.notifiedApproaching = false;
      engagement.newRecordShown = false;
      engagement.streakBonus = 1.0;
      
      // Hide personal best alert
      const pbAlert = $("pbAlert");
      if (pbAlert) {
        pbAlert.style.display = 'none';
      }
      engagement.totalSessionScore = 0;
      engagement.lastMilestoneTime = 0;
      engagement.gamesPlayed++;
      engagement.sessionStartTime = Date.now();
      engagement.combo.maxCombo = 0; // Reset for this session
      localStorage.setItem('gamesPlayed', engagement.gamesPlayed.toString());
      Achievements.reset();
      
      // Sync world.currentLevel with LevelSystem.currentLevel
      world.currentLevel = LevelSystem.currentLevel || 1;
      
    world.groundY = H * 0.8;
      world.camX = 0;
      viking.x = 100;
      viking.y = world.groundY; 
      viking.vy = 0; 
      viking.faceplant = 0;
      viking.ducking = false;
      viking.onGround = true;
      Obstacles.length = 0;
      DuckObstacles.length = 0;
      Meads.length = 0; 
      Powerups.length = 0;
      Particles.length = 0;
      Platforms.length = 0;
      Enemies.length = 0;
      Hearts.length = 0;
      Golds.length = 0;
      Bosses.length = 0;
    world.nextObstacleAt = viking.x + 600;
      world.nextDuckObstacleAt = viking.x + 800;
      world.nextMeadAt = viking.x + 400;
      world.nextPowerupAt = viking.x + 6000;
      world.nextPlatformAt = viking.x + 500;
      world.nextEnemyAt = viking.x + 800;
      world.nextBirdAt = viking.x + 1200;
      world.nextHeartAt = viking.x + 1200;
      world.nextGoldAt = viking.x + 2000;
      
      // Comeback mechanic: extra life for struggling players (on top of difficulty base)
      let startingLives = diff.startingLives;
      if (engagement.sessionDeaths >= 10) {
        startingLives += 2;
      } else if (engagement.sessionDeaths >= 5) {
        startingLives += 1;
      }
      // Add prestige bonus
      startingLives += PrestigeSystem.getStartingLivesBonus();
      world.lives = Math.min(startingLives, 10); // Cap at 10 lives max
      
      world.powerups = {
        speedBoost: { active: false, timeLeft: 0 },
        invincibility: { active: false, timeLeft: 0 },
        scoreMultiplier: { active: false, timeLeft: 0, multiplier: 1 },
        vikingShip: { active: false, timeLeft: 0 },
        respawn: { count: 0 }, // Count of respawns collected (each gives 1 life)
      respawnPlus: { count: 0 } // Rare respawn that gives 3 lives
      };
      world.bossSpawnsThisLevel = {}; // Reset boss spawn tracking on reset
      viking.jumpsUsed = 0;
      viking.maxJumps = 1;
      Input.jump = false;
      Input.duck = false;
      Input.jumpJustPressed = false;
      
      // Force overlay to show
      if (overlay) {
        overlay.style.display = "grid";
        overlay.style.visibility = "visible";
        overlay.style.opacity = "1";
      }
      const overlayTitle = $("overlayTitle");
      const overlayText = $("overlayText");
      if (overlayTitle) overlayTitle.textContent = "Viking Run";
      renderLevelGrid();
      if (overlayText) overlayText.textContent = "Jump on platforms, avoid enemies, collect powerups, and survive.";
      const startBtn = $("startBtn");
      if (startBtn) {
        startBtn.textContent = "Start Game";
        startBtn.style.display = "block";
      }
      if (statePill) statePill.textContent = "Ready";
      const pauseBtn = $("pauseBtn");
      if (pauseBtn) pauseBtn.textContent = "Pause";
    updateHUD();
      
      // Force a redraw
      draw();
    } catch (e) {
      console.error("Error in resetWorld:", e);
    }
  };

  // Activate respawn on death
  const activateRespawn = () => {
    let livesToGive = 0;
    let isRare = false;
    
    // Check for rare respawn+ first (gives 3 lives)
    if (world.powerups.respawnPlus.count > 0) {
      world.powerups.respawnPlus.count--;
      livesToGive = 3;
      isRare = true;
    } else if (world.powerups.respawn.count > 0) {
      // Check for regular respawn (gives 1 life)
      world.powerups.respawn.count--;
      livesToGive = 1;
    } else {
      return false; // No respawns available
    }
    
    world.lives = livesToGive;
    world.over = false;
    viking.faceplant = 0;
    viking.vy = 0;
    viking.y = world.groundY;
    viking.onGround = true;
    
    // Large, visible respawn notification
    const respawnNotification = document.createElement('div');
    const bgGradient = isRare ? 'linear-gradient(135deg, #FFD700, #FFA500)' : 'linear-gradient(135deg, #9B59B6, #8E44AD)';
    const flashColor = isRare ? 'rgba(255, 215, 0, 0.4)' : 'rgba(155, 89, 182, 0.4)';
    respawnNotification.style.cssText = 
      'position: fixed;' +
      'top: 50%;' +
      'left: 50%;' +
      'transform: translate(-50%, -50%);' +
      'z-index: 10001;' +
      'background: ' + bgGradient + ';' +
      'color: white;' +
      'font-size: 48px;' +
      'font-weight: 900;' +
      'padding: 40px 60px;' +
      'border-radius: 20px;' +
      'box-shadow: 0 0 50px rgba(155, 89, 182, 0.8), 0 0 100px rgba(155, 89, 182, 0.5);' +
      'text-align: center;' +
      'animation: respawnPulse 0.3s ease-out;' +
      'pointer-events: none;';
    respawnNotification.textContent = isRare ? '‚≠ê RARE RESPAWN+ ACTIVATED! 3 Lives!' : 'üîÑ RESPAWN ACTIVATED! 1 Life!';
    document.body.appendChild(respawnNotification);
    
    // Screen shake and flash
    world.screenShake = 0.5;
    const flash = document.createElement('div');
    flash.style.cssText = 
      'position: fixed;' +
      'inset: 0;' +
      'background: radial-gradient(circle, ' + flashColor + ' 0%, transparent 70%);' +
      'z-index: 10000;' +
      'pointer-events: none;' +
      'animation: fadeOut 1s ease-out forwards;';
    document.body.appendChild(flash);
    
    // Particle effects
    for (let i = 0; i < 30; i++) {
      addParticle(viking.x, viking.y, isRare ? "#FFD700" : "#9B59B6", 20);
    }
    
    playSFX('warhorn');
    updateHUD();
    if (statePill) statePill.textContent = "Playing";
    
    // Remove notification after 3 seconds
    setTimeout(() => {
      respawnNotification.style.animation = 'fadeOut 0.5s ease-out forwards';
      setTimeout(() => respawnNotification.remove(), 500);
    }, 3000);
    setTimeout(() => flash.remove(), 1000);
    
    return true;
  };

  const updateHUD = () => {
    try {
      // Ensure all numeric values are properly initialized
      const score = Number(world.score) || 0;
      const mead = Number(world.mead) || 0;
      const lives = Number(world.lives) || 0;
      
      if (scoreV) scoreV.textContent = Math.floor(score).toLocaleString();
      if (meadV) meadV.textContent = mead.toString();
      
      const multStat = $("multiplierStat");
      const multV = $("multiplierV");
      if (multStat && multV) {
        if (world.powerups && world.powerups.scoreMultiplier && world.powerups.scoreMultiplier.active) {
          const multiplier = Number(world.powerups.scoreMultiplier.multiplier) || 1;
          multStat.style.display = "flex";
          multV.textContent = multiplier + "x";
        } else {
          multStat.style.display = "none";
        }
      }
      

      const livesCount = $("livesCount");
      if (livesCount) {
        livesCount.textContent = lives.toString();
      }
      
      // Respawn counter - always visible, shows count of respawns collected
      const respawnDisplay = $("respawnDisplay");
      const respawnCount = $("respawnCount");
      if (respawnDisplay && respawnCount) {
        respawnDisplay.style.display = "flex"; // Always visible
        const respawnCountVal = Number(world.powerups?.respawn?.count) || 0;
        const respawnPlusCountVal = Number(world.powerups?.respawnPlus?.count) || 0;
        const totalRespawns = (isNaN(respawnCountVal) ? 0 : respawnCountVal) + (isNaN(respawnPlusCountVal) ? 0 : respawnPlusCountVal);
        respawnCount.textContent = totalRespawns.toString();
      }
    } catch (e) {
      console.error("Error in updateHUD:", e);
    }
  };

  const updatePowerupCountdowns = () => {
    try {
      const container = $("powerupIndicators");
      if (!container) return;

      if (!world.started || world.paused || world.over) {
        container.innerHTML = "";
        return;
      }

      const powerupConfigs = {
        speedBoost: { name: "Speed Boost", icon: "‚ö°", color: "#FFD700" },
        invincibility: { name: "Invincibility", icon: "üõ°Ô∏è", color: "#00FF00" },
        scoreMultiplier: { name: "Score Multiplier", icon: "‚≠ê", color: "#FF69B4" },
        vikingShip: { name: "Viking Ship", icon: "‚õµ", color: "#4A90D9" },
        respawn: { name: "Respawn", icon: "üîÑ", color: "#9B59B6" },
        respawnPlus: { name: "Rare Respawn+", icon: "‚≠ê", color: "#FFD700" }
      };

      container.innerHTML = "";

      for (const [key, powerup] of Object.entries(world.powerups)) {
        // Show respawn counts if available
        if (key === "respawn" && powerup.count > 0) {
          const config = powerupConfigs[key];
          if (!config) continue;
          
          const indicator = document.createElement("div");
          indicator.className = "powerup-indicator";
          indicator.innerHTML = `
            <div class="powerup-icon" style="background: ${config.color}20; border: 1px solid ${config.color}40;">
              ${config.icon}
            </div>
            <div class="powerup-info">
              <div class="powerup-name">${config.name}</div>
              <div class="powerup-timer" style="color: #00FF00;">${powerup.count}x (1 life each)</div>
            </div>
          `;
          container.appendChild(indicator);
          continue;
        }
        
        // Show respawnPlus counts if available
        if (key === "respawnPlus" && powerup.count > 0) {
          const config = powerupConfigs[key] || { name: "Rare Respawn+", icon: "‚≠ê", color: "#FFD700" };
          
          const indicator = document.createElement("div");
          indicator.className = "powerup-indicator";
          indicator.innerHTML = `
            <div class="powerup-icon" style="background: ${config.color}30; border: 2px solid ${config.color}; box-shadow: 0 0 10px ${config.color}80;">
              ${config.icon}
            </div>
            <div class="powerup-info">
              <div class="powerup-name" style="color: ${config.color};">${config.name}</div>
              <div class="powerup-timer" style="color: #FFD700; font-weight: 700;">${powerup.count}x (3 lives each!)</div>
            </div>
          `;
          container.appendChild(indicator);
          continue;
        }
        
        if (powerup.active) {
          
          if (powerup.timeLeft > 0) {
          const config = powerupConfigs[key];
          if (!config) continue;

          const timeLeft = Math.ceil(powerup.timeLeft);
          const indicator = document.createElement("div");
          indicator.className = "powerup-indicator";
          
          // Add warning/danger classes based on time left
          if (timeLeft <= 3) {
            indicator.classList.add("danger");
          } else if (timeLeft <= 5) {
            indicator.classList.add("warning");
          }

          const timerClass = timeLeft <= 3 ? "danger" : timeLeft <= 5 ? "warning" : "";
          
          // Get current level theme for visibility adjustments
          const theme = LevelThemes.getCurrent();
          const isFireLevel = theme.name && (theme.name.includes('Fire') || theme.name.includes('Dragon'));
          
          // Add background and outline for visibility, especially in fire levels
          const timerStyle = isFireLevel 
            ? 'background: rgba(0, 0, 0, 0.9); color: #FFFFFF; padding: 4px 8px; border-radius: 6px; border: 2px solid #FFD700; text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 8px #FFD700; font-weight: 700;'
            : 'background: rgba(0, 0, 0, 0.7); color: #FFFFFF; padding: 4px 8px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.3); text-shadow: 1px 1px 2px rgba(0,0,0,0.8);';
          
          indicator.innerHTML = `
            <div class="powerup-icon" style="background: ${config.color}20; border: 1px solid ${config.color}40;">
              ${config.icon}
            </div>
            <div class="powerup-info">
              <div class="powerup-name">${config.name}</div>
              <div class="powerup-timer ${timerClass}" style="${timerStyle}">${timeLeft}s</div>
            </div>
          `;

          container.appendChild(indicator);

          // Play warning sounds
          if (timeLeft === 5 && OPT.sound) {
            playSFX('powerup'); // Subtle warning
          } else if (timeLeft === 3 && OPT.sound) {
            playSFX('powerup'); // More urgent
          } else if (timeLeft === 1 && OPT.sound) {
            playSFX('powerup'); // Final warning
          }
          }
        }
      }
    } catch (e) {
      console.error("Error in updatePowerupCountdowns:", e);
    }
  };


  // Enhanced Stickiness Notifications - Maximum Addiction Potential
  let lastStickinessNotification = 0;
  const notificationLog = [];
  
  const showStickinessNotification = (message, type = 'info', soundType = null) => {
    const now = Date.now();
    if (now - lastStickinessNotification < 2000) return; // Throttle notifications
    lastStickinessNotification = now;
    
    // Play sound based on type
    if (soundType) {
      playSFX(soundType);
    } else {
      switch(type) {
        case 'achievement': playSFX('powerup'); break;
        case 'milestone': playSFX('warhorn'); break;
        case 'unlock': playSFX('powerup'); break;
        case 'event': playSFX('powerup'); break;
        case 'warning': playSFX('powerup'); break;
        default: playSFX('powerup'); break;
      }
    }
    
    const notification = document.createElement('div');
    const colors = {
      info: 'rgba(59, 130, 246, 0.95)',
      warning: 'rgba(251, 191, 36, 0.95)',
      danger: 'rgba(239, 68, 68, 0.95)',
      achievement: 'rgba(168, 85, 247, 0.95)',
      milestone: 'rgba(34, 197, 94, 0.95)',
      unlock: 'rgba(251, 191, 36, 0.95)',
      event: 'rgba(236, 72, 153, 0.95)'
    };
    
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: ${colors[type] || colors.info};
      color: white;
      padding: 14px 24px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 700;
      z-index: 10001;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      animation: slideDown 0.3s ease;
      text-align: center;
      max-width: 90%;
      word-wrap: break-word;
    `;
    notification.textContent = message;
    document.body.appendChild(notification);
    
    // Add to notification log
    notificationLog.push({ message, type, timestamp: new Date().toISOString() });
    if (notificationLog.length > 50) notificationLog.shift(); // Keep last 50
    
    setTimeout(() => {
      notification.style.animation = 'slideUp 0.3s ease';
      setTimeout(() => notification.remove(), 300);
    }, type === 'event' ? 4000 : 2500); // Events show longer
  };
  
  // "Almost there" notifications
  const checkAlmostThereNotifications = () => {
    if (!world.started || world.paused || world.over) return;
    
    const score = world.score;
    
    // "50 points until next level!"
    const nextLevel = LevelSystem.levels.find(l => l.unlockScore > score);
    if (nextLevel) {
      const remaining = nextLevel.unlockScore - score;
      if (remaining > 0 && remaining <= 50 && Math.random() < 0.1) {
        showStickinessNotification(`‚ö° Only ${remaining} points until ${nextLevel.name}!`, 'warning');
      }
    }
    
    // "One more enemy for daily challenge!"
    if (DailyChallenges && DailyChallenges.challenges) {
      const activeChallenge = DailyChallenges.challenges.find(c => !c.completed && c.type === 'enemyKills');
      if (activeChallenge) {
        const remaining = activeChallenge.target - activeChallenge.progress;
        if (remaining === 1 && Math.random() < 0.3) {
          showStickinessNotification(`üéØ One more enemy for daily challenge!`, 'warning');
        }
      }
    }
    
    // "10 seconds until powerup expires!"
    for (const key in world.powerups) {
      const powerup = world.powerups[key];
      if (powerup.active && powerup.timeLeft <= 10 && powerup.timeLeft > 9 && Math.random() < 0.2) {
        showStickinessNotification(`‚è∞ ${key} expires in ${Math.ceil(powerup.timeLeft)}s!`, 'warning');
      }
    }
  };

  const updateProgressVisualization = () => {
    try {
      if (!world.started || world.paused || world.over) {
        const progressContainer = $("progressContainer");
        const futureRewards = $("futureRewards");
        if (progressContainer) progressContainer.style.display = "none";
        if (futureRewards) futureRewards.style.display = "none";
        return;
      }
      
      // Stickiness features: Completion urgency and loss aversion
      const score = world.score;
      const personalBest = engagement.personalBest || 0;
      
      // Loss aversion: "You're 90% to your personal best!"
      if (personalBest > 0 && score >= personalBest * 0.9 && score < personalBest && !engagement.notifiedApproaching) {
        showStickinessNotification(`üî• You're ${Math.round((score / personalBest) * 100)}% to your personal best!`, 'warning');
        engagement.notifiedApproaching = true;
      }
      
      // Completion urgency: "Only X points until next level!"
      const nextLevel = LevelSystem.levels.find(l => l.unlockScore > score);
      if (nextLevel) {
        const remaining = nextLevel.unlockScore - score;
        if (remaining <= 500 && remaining > 0 && Math.random() < 0.01) {
          showStickinessNotification(`‚ö° Only ${remaining.toLocaleString()} points until ${nextLevel.name}!`, 'info');
        }
      }
      
      // Completion urgency: "Boss spawning in X points!"
      const theme = LevelThemes.getCurrent();
      if (theme && theme.bossSpawnScore) {
        const bossRemaining = theme.bossSpawnScore - score;
        if (bossRemaining <= 1000 && bossRemaining > 0 && Math.random() < 0.01) {
          showStickinessNotification(`üëπ Boss spawning in ${bossRemaining.toLocaleString()} points!`, 'warning');
        }
      }
      
      // Streak protection: Daily login streak warning
      const { streak } = DailyBonus.getStreak();
      if (streak >= 3) {
        const lastLogin = localStorage.getItem('lastLoginDate');
        const today = new Date().toDateString();
        if (lastLogin !== today) {
          const hoursUntilReset = 24 - (new Date().getHours());
          if (hoursUntilReset <= 3 && Math.random() < 0.005) {
            showStickinessNotification(`‚è∞ Don't lose your ${streak}-day streak! Login in ${hoursUntilReset} hours!`, 'danger');
          }
        }
      }
      
      // Daily challenge completion urgency
      if (DailyChallenges && DailyChallenges.challenges) {
        const activeChallenge = DailyChallenges.challenges.find(c => !c.completed);
        if (activeChallenge) {
          const remaining = activeChallenge.target - activeChallenge.progress;
          if (remaining <= 3 && remaining > 0 && Math.random() < 0.02) {
            showStickinessNotification(`üéØ Only ${remaining} ${activeChallenge.type} for daily challenge!`, 'info');
          }
        }
      }

      // Boss countdown display
      const bossTheme = LevelThemes.getCurrent();
      if (bossTheme && bossTheme.boss) {
        const currentLevel = LevelSystem.levels.slice().reverse().find(l => world.score >= l.unlockScore) || LevelSystem.levels[0];
        const nextLevel = LevelSystem.levels.find(l => l.unlockScore > world.score);
        const levelStart = currentLevel.unlockScore;
        const levelEnd = nextLevel ? nextLevel.unlockScore : Infinity;
        const levelRange = levelEnd - levelStart;
        const spawnsPerLevel = currentLevel.id <= 3 ? 1 : currentLevel.id - 2;
        const spawnInterval = levelRange / (spawnsPerLevel + 1);
        
        // Find next boss spawn point
        let nextBossScore = null;
        for (let i = 1; i <= spawnsPerLevel; i++) {
          const spawnScore = levelStart + (spawnInterval * i);
          const spawnKey = `${currentLevel.id}_${i}`;
          if (world.score < spawnScore && !world.bossSpawnsThisLevel[spawnKey]) {
            nextBossScore = spawnScore;
            break;
          }
        }
        
        const bossProgressText = $("bossProgressText");
        const bossProgressFill = $("bossProgressFill");
        const bossProgressBar = $("bossProgressBar");
        
        if (nextBossScore !== null && nextBossScore > world.score) {
          const remaining = Math.max(0, nextBossScore - world.score);
          const progress = Math.max(0, Math.min(100, ((world.score - levelStart) / (nextBossScore - levelStart)) * 100));
          
          if (bossProgressBar) bossProgressBar.style.display = "block";
          if (bossProgressText) {
            bossProgressText.textContent = `${remaining.toLocaleString()} points`;
          }
          if (bossProgressFill) {
            bossProgressFill.style.width = progress + "%";
          }
        } else {
          if (bossProgressBar) bossProgressBar.style.display = "none";
          if (bossProgressText) {
            bossProgressText.textContent = "--";
          }
        }
      } else {
        const bossProgressBar = $("bossProgressBar");
        if (bossProgressBar) bossProgressBar.style.display = "none";
      }

      // Achievement Progress - REMOVED (only show until bosses)

      // Daily Challenge Progress (if challenges exist)
      if (DailyChallenges && DailyChallenges.challenges) {
        const activeChallenge = DailyChallenges.challenges.find(c => !c.completed);
        if (activeChallenge) {
          const challengeProgress = (activeChallenge.progress / activeChallenge.target) * 100;
          const remaining = Math.ceil(activeChallenge.target - activeChallenge.progress);
          
          const challengeProgressBar = $("challengeProgressBar");
          const challengeProgressFill = $("challengeProgressFill");
          const challengeProgressText = $("challengeProgressText");
          
          if (challengeProgressBar) challengeProgressBar.style.display = "block";
          if (challengeProgressFill) {
            challengeProgressFill.style.width = challengeProgress + "%";
            if (remaining <= 3) challengeProgressFill.classList.add("warning");
            else challengeProgressFill.classList.remove("warning");
          }
          if (challengeProgressText) {
            challengeProgressText.textContent = `${remaining} ${activeChallenge.type} remaining`;
          }
        } else {
          const challengeProgressBar = $("challengeProgressBar");
          if (challengeProgressBar) challengeProgressBar.style.display = "none";
        }
      }
    } catch (e) {
      console.error("Error in updateProgressVisualization:", e);
    }
  };

  const HighScoreManager = {
    getPeriodKey: (period) => {
      const now = new Date();
      const year = now.getFullYear();
      const month = now.getMonth();
      const day = now.toDateString(); // Get day BEFORE any mutations
      
      // Clone date for week calculation to avoid mutating 'now'
      const weekCalc = new Date(now.getTime());
      weekCalc.setDate(weekCalc.getDate() - weekCalc.getDay());
      const weekNum = Math.ceil(weekCalc.getDate() / 7);
      
      switch(period) {
        case 'daily': return `highscore_daily_${day}`;
        case 'weekly': return `highscore_weekly_${year}_W${weekNum}`;
        case 'monthly': return `highscore_monthly_${year}_${month}`;
        case 'yearly': return `highscore_yearly_${year}`;
        case 'alltime': return 'highscore_alltime';
        default: return 'highscore_alltime';
      }
    },

    async saveScore(score, playerName = null) {
      const now = new Date();
      const playerId = localStorage.getItem('playerId') || `player_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const name = playerName || localStorage.getItem('playerName') || `Player${playerId.substring(7, 11)}`;
      
      const scoreEntry = { 
        score, 
        date: now.toISOString(),
        playerId: playerId,
        playerName: name
      };
      
      // Generate player ID if not exists
      if (!localStorage.getItem('playerId')) {
        localStorage.setItem('playerId', playerId);
      }
      
      // Save player name if provided
      if (playerName) {
        localStorage.setItem('playerName', playerName);
      }
      
      // Save to all periods
      for (const period of ['daily', 'weekly', 'monthly', 'yearly', 'alltime']) {
        const key = HighScoreManager.getPeriodKey(period) + `_${world.difficulty}`;
        let scores = HighScoreManager.getScoresLocal(period, world.difficulty);
        scores.push(scoreEntry);
        scores.sort((a, b) => b.score - a.score);
        scores = scores.slice(0, 10);
        localStorage.setItem(key, JSON.stringify(scores));
      }
      
    },

    getScoresLocal(period = 'alltime', difficulty = 'normal') {
      const key = HighScoreManager.getPeriodKey(period) + `_${difficulty}`;
      return JSON.parse(localStorage.getItem(key) || '[]');
    },

    async getScores(period = 'alltime', difficulty = 'normal') {
      return HighScoreManager.getScoresLocal(period, difficulty);
    },

    async displayScores(period = 'alltime', difficulty = 'normal') {
      const scores = await HighScoreManager.getScores(period, difficulty);
      const list = $("highscoreList");
      if (!list) return;
      
      list.innerHTML = '';
      
      // Show difficulty in header
      const modalTitle = document.querySelector('#highscoreModal h2');
      if (modalTitle) {
        const diffPreset = DifficultyModes.presets[difficulty];
        const diffName = diffPreset?.name || difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
        const diffIcon = diffPreset?.icon || '‚öîÔ∏è';
        modalTitle.textContent = `üèÜ High Scores - ${diffIcon} ${diffName}`;
      }
      
      if (scores.length === 0) {
        list.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">No scores yet for this difficulty</div>';
        return;
      }
      
      const currentPlayerId = localStorage.getItem('playerId');
      const currentPlayerName = localStorage.getItem('playerName') || 'You';
      
      scores.forEach((item, index) => {
        const div = document.createElement('div');
        const isCurrentPlayer = item.playerId === currentPlayerId;
        div.className = `highscore-item ${index === 0 ? 'rank-1' : ''} ${isCurrentPlayer ? 'current-player' : ''}`;
        const date = new Date(item.date);
        const playerName = item.playerName || item.playerId?.substring(0, 8) || 'Player';
        const displayName = isCurrentPlayer ? `${playerName} (You)` : playerName;
        div.innerHTML = `
          <div>
            <div class="highscore-rank">#${index + 1}</div>
            <div class="highscore-date">${displayName} ‚Ä¢ ${date.toLocaleDateString()}</div>
          </div>
          <div class="highscore-score">${Math.floor(item.score).toLocaleString()}</div>
        `;
        list.appendChild(div);
      });
    }
  };

  const Input = { jump: false, duck: false, jumpJustPressed: false };
  
  window.addEventListener("keydown", (e) => {
    if (e.code === "Space") { 
      if (!Input.jump) {
        Input.jumpJustPressed = true;
      }
      Input.jump = true;
      if(!world.started && !world.over) start(); 
    }
    if (e.code === "ArrowDown") Input.duck = true;
    e.preventDefault();
  });
  
  window.addEventListener("keyup", (e) => {
    if (e.code === "Space") {
      Input.jump = false;
      Input.jumpJustPressed = false;
    }
    if (e.code === "ArrowDown") Input.duck = false;
    e.preventDefault();
  });
  
  canvas.addEventListener("pointerdown", (e) => { 
    if (!Input.jump) {
      Input.jumpJustPressed = true;
    }
    Input.jump = true;
    // Attack system removed
    if(!world.started && !world.over) start(); 
    e.preventDefault();
  });
  
  window.addEventListener("pointerup", () => {
    Input.jump = false;
    Input.jumpJustPressed = false;
  });

  let sessionStartTime = 0;

  const start = () => {
    if (world.started && !world.over) return; // Allow restart if game is over
    try {
      console.log("Game starting...");
      
      // Ensure clean state before starting
      if (world.over) {
        resetWorld();
        // Wait a frame for reset to complete
        setTimeout(() => {
          try {
    world.started = true;
            world.over = false;
            world.paused = false;
            sessionStartTime = Date.now();
            
            // Sync world.currentLevel with LevelSystem.currentLevel
            world.currentLevel = LevelSystem.currentLevel || 1;
            console.log("Current level:", world.currentLevel);
            
            // Apply difficulty settings
            const diff = DifficultyModes.getCurrent();
            world.speed = diff.baseSpeed;
            console.log("Difficulty:", diff.name, "Speed:", world.speed);
            
            if (overlay) {
    overlay.style.display = "none";
              overlay.style.visibility = "hidden";
            }
            if (statePill) statePill.textContent = "Playing";
            const pauseBtn = $("pauseBtn");
      if (pauseBtn) pauseBtn.textContent = "Pause";
            
            // Stop menu music when game starts
            try {
              stopMenuMusic();
            } catch (e) {
              console.warn("Error stopping menu music:", e);
            }
            
            // Apply any pending daily bonus reward
            try {
              applyPendingReward();
            } catch (e) {
              console.warn("Error applying pending reward:", e);
            }
            
            try {
              playSFX('warhorn');
            } catch (e) {
              console.warn("Error playing warhorn:", e);
            }
            console.log("Game started successfully");
          } catch (e) {
            console.error("Error in delayed start:", e);
            world.started = false;
          }
        }, 50);
        return;
      }
      
      world.started = true;
      world.over = false;
      world.paused = false;
      sessionStartTime = Date.now();
      
      // Sync world.currentLevel with LevelSystem.currentLevel
      world.currentLevel = LevelSystem.currentLevel || 1;
      console.log("Current level:", world.currentLevel);
      
      // Apply difficulty settings
      const diff = DifficultyModes.getCurrent();
      world.speed = diff.baseSpeed;
      console.log("Difficulty:", diff.name, "Speed:", world.speed);
      
      if (overlay) {
        overlay.style.display = "none";
        overlay.style.visibility = "hidden";
      }
      if (statePill) statePill.textContent = "Playing";
      const pauseBtn = $("pauseBtn");
      if (pauseBtn) pauseBtn.textContent = "Pause";
      
      // Stop menu music when game starts
      try {
        stopMenuMusic();
      } catch (e) {
        console.warn("Error stopping menu music:", e);
      }
      
      // Apply any pending daily bonus reward
      try {
        applyPendingReward();
      } catch (e) {
        console.warn("Error applying pending reward:", e);
      }
      
      try {
        playSFX('warhorn');
      } catch (e) {
        console.warn("Error playing warhorn:", e);
      }
      console.log("Game started successfully");
    } catch (e) {
      console.error("Error in start:", e);
      // Reset on error
      world.started = false;
      world.over = false;
      world.paused = false;
    }
  };

  // Draw realistic Viking longship (when ship powerup is active) - optimized for performance
  const drawVikingShip = (x, y) => {
    ctx.save();
    ctx.translate(x, y + 20);
    
    const bob = Math.sin(world.t * 4) * 3;
    const oarPhase = Math.sin(world.t * 8);
    
    // Reduced particle generation - only 20% chance, 1-2 particles max (was 50%, 3 each)
    if (Math.random() < 0.2 && Math.floor(world.t * 10) % 3 === 0) {
      addParticle(x - 85, y + 8, "#4A90D9", 8);
      if (Math.random() < 0.5) addParticle(x - 90, y + 12, "#87CEEB", 5);
    }
    
    // Realistic hull with proper proportions (7:1 length:width ratio)
    const hullLength = 140;
    const hullWidth = 20;
    const hullDepth = 35;
    
    // Main hull - detailed wooden planks with realistic shading
    const hullGradient = ctx.createLinearGradient(0, -hullDepth + bob, 0, bob);
    hullGradient.addColorStop(0, "#5A4B37"); // Darker at top
    hullGradient.addColorStop(0.5, "#6B5B47"); // Medium
    hullGradient.addColorStop(1, "#7A6B57"); // Lighter at waterline
    
    ctx.fillStyle = hullGradient;
    ctx.beginPath();
    ctx.moveTo(-hullLength/2, bob);
    ctx.quadraticCurveTo(-hullLength/2 - 5, -hullDepth/3 + bob, -hullLength/2 + 10, -hullDepth + bob);
    ctx.lineTo(hullLength/2 - 10, -hullDepth + bob);
    ctx.quadraticCurveTo(hullLength/2 + 5, -hullDepth/3 + bob, hullLength/2, bob + 3);
    ctx.quadraticCurveTo(0, hullWidth/2 + bob, -hullLength/2, bob);
    ctx.fill();
    
    // Simplified wood grain texture - fewer planks, no nested loops
    ctx.strokeStyle = "#4A3B27";
    ctx.lineWidth = 1;
    for (let i = -hullLength/2 + 20; i < hullLength/2 - 20; i += 20) { // Reduced from 12 to 20 spacing
      // Plank outline only (removed grain lines loop)
      ctx.beginPath();
      ctx.moveTo(i, -hullDepth/2 + bob);
      ctx.quadraticCurveTo(i + 2, -hullDepth/3 + bob, i + 4, -hullDepth/4 + bob);
      ctx.lineTo(i + 20, -hullDepth/4 + bob);
      ctx.quadraticCurveTo(i + 22, -hullDepth/3 + bob, i + 20, -hullDepth/2 + bob);
      ctx.stroke();
    }
    
    // Rivets/plank joints - more realistic metal
    ctx.fillStyle = "#3A2C1A";
    for (let i = -hullLength/2 + 20; i < hullLength/2 - 20; i += 25) {
      // Metal rivet with highlight
      ctx.beginPath();
      ctx.arc(i, -hullDepth/2 + bob, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#5A4C3A";
      ctx.beginPath();
      ctx.arc(i - 0.5, -hullDepth/2 - 0.5 + bob, 0.8, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#3A2C1A";
    }
    
    // Weathering and battle damage - scratches and dents
    ctx.strokeStyle = "#4A3B27";
    ctx.lineWidth = 1;
    const damagePositions = [-45, -20, 20, 45];
    damagePositions.forEach(dx => {
      if (Math.random() < 0.3) {
        ctx.beginPath();
        ctx.moveTo(dx, -hullDepth/2 + bob);
        ctx.lineTo(dx + 3, -hullDepth/3 + bob);
        ctx.stroke();
      }
    })
    
    // Detailed dragon head prow - highly realistic carving with shading
    const dragonGradient = ctx.createLinearGradient(hullLength/2, -hullDepth + bob, hullLength/2 + 25, -hullDepth - 50 + bob);
    dragonGradient.addColorStop(0, "#8A6B4A");
    dragonGradient.addColorStop(0.5, "#7A5B3A");
    dragonGradient.addColorStop(1, "#6A4B2A");
    
    ctx.fillStyle = dragonGradient;
    ctx.beginPath();
    ctx.moveTo(hullLength/2, -hullDepth + bob);
    ctx.bezierCurveTo(hullLength/2 + 15, -hullDepth - 10 + bob, hullLength/2 + 25, -hullDepth - 25 + bob, hullLength/2 + 22, -hullDepth - 48 + bob);
    ctx.bezierCurveTo(hullLength/2 + 20, -hullDepth - 52 + bob, hullLength/2 + 17, -hullDepth - 50 + bob, hullLength/2 + 14, -hullDepth - 54 + bob);
    ctx.bezierCurveTo(hullLength/2 + 12, -hullDepth - 52 + bob, hullLength/2 + 10, -hullDepth - 48 + bob, hullLength/2 + 7, -hullDepth - 42 + bob);
    ctx.bezierCurveTo(hullLength/2 + 4, -hullDepth - 32 + bob, hullLength/2 + 2, -hullDepth - 18 + bob, hullLength/2 - 3, -hullDepth + bob);
    ctx.fill();
    
    // Dragon snout detail
    ctx.fillStyle = "#6A4B2A";
    ctx.beginPath();
    ctx.ellipse(hullLength/2 + 18, -hullDepth - 40 + bob, 6, 4, 0.3, 0, Math.PI * 2);
    ctx.fill();
    
    // Simplified dragon scales - single loop (removed nested loop)
    ctx.strokeStyle = "#5A3B1A";
    ctx.lineWidth = 1;
    for (let i = 0; i < 5; i++) {
      ctx.beginPath();
      ctx.moveTo(hullLength/2 + 8 + i * 3.5, -hullDepth - 28 - i * 4.5 + bob);
      ctx.lineTo(hullLength/2 + 10 + i * 3.5, -hullDepth - 32 - i * 4.5 + bob);
      ctx.lineTo(hullLength/2 + 12 + i * 3.5, -hullDepth - 30 - i * 4.5 + bob);
      ctx.closePath();
      ctx.stroke();
    }
    
    // Dragon eye - realistic glowing with depth
    const eyeGradient = ctx.createRadialGradient(hullLength/2 + 16, -hullDepth - 37 + bob, 0, hullLength/2 + 16, -hullDepth - 37 + bob, 6);
    eyeGradient.addColorStop(0, "#FFD700");
    eyeGradient.addColorStop(0.5, "#FFA500");
    eyeGradient.addColorStop(1, "#FF8C00");
    
    ctx.fillStyle = eyeGradient;
    ctx.shadowBlur = 12;
    ctx.shadowColor = "#FFD700";
    ctx.beginPath();
    ctx.arc(hullLength/2 + 16, -hullDepth - 37 + bob, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // Eye pupil with highlight
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.arc(hullLength/2 + 17, -hullDepth - 37 + bob, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#FFF";
    ctx.beginPath();
    ctx.arc(hullLength/2 + 17.5, -hullDepth - 37.5 + bob, 1, 0, Math.PI * 2);
    ctx.fill();
    
    // Dragon mouth - open with teeth
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(hullLength/2 + 12, -hullDepth - 32 + bob, 4, 2, 0.2, 0, Math.PI * 2);
    ctx.fill();
    // Teeth
    ctx.fillStyle = "#FFF";
    for (let t = 0; t < 3; t++) {
      ctx.beginPath();
      ctx.moveTo(hullLength/2 + 10 + t * 2, -hullDepth - 32 + bob);
      ctx.lineTo(hullLength/2 + 11 + t * 2, -hullDepth - 34 + bob);
      ctx.lineTo(hullLength/2 + 12 + t * 2, -hullDepth - 32 + bob);
      ctx.fill();
    }
    
    // Dragon horns - curved and detailed
    ctx.strokeStyle = "#4A3B1A";
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(hullLength/2 + 20, -hullDepth - 50 + bob);
    ctx.quadraticCurveTo(hullLength/2 + 24, -hullDepth - 58 + bob, hullLength/2 + 23, -hullDepth - 62 + bob);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(hullLength/2 + 16, -hullDepth - 52 + bob);
    ctx.quadraticCurveTo(hullLength/2 + 20, -hullDepth - 60 + bob, hullLength/2 + 19, -hullDepth - 64 + bob);
    ctx.stroke();
    
    // Horn details
    ctx.fillStyle = "#3A2B0A";
    ctx.beginPath();
    ctx.arc(hullLength/2 + 23, -hullDepth - 62 + bob, 1.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(hullLength/2 + 19, -hullDepth - 64 + bob, 1.5, 0, Math.PI * 2);
    ctx.fill();
    
    // Tail curl at stern - more detailed
    ctx.fillStyle = "#7A5B3A";
    ctx.beginPath();
    ctx.moveTo(-hullLength/2, -hullDepth + bob);
    ctx.bezierCurveTo(-hullLength/2 - 12, -hullDepth - 15 + bob, -hullLength/2 - 18, -hullDepth - 35 + bob, -hullLength/2 - 15, -hullDepth - 50 + bob);
    ctx.bezierCurveTo(-hullLength/2 - 13, -hullDepth - 48 + bob, -hullLength/2 - 10, -hullDepth - 45 + bob, -hullLength/2 - 8, -hullDepth - 40 + bob);
    ctx.bezierCurveTo(-hullLength/2 - 5, -hullDepth - 25 + bob, -hullLength/2 - 2, -hullDepth - 10 + bob, -hullLength/2 + 5, -hullDepth + bob);
    ctx.fill();
    
    // Mast - realistic tapered wooden mast with grain
    const mastGradient = ctx.createLinearGradient(-3, -hullDepth + bob, 3, -hullDepth - 90 + bob);
    mastGradient.addColorStop(0, "#2A1C0A");
    mastGradient.addColorStop(0.5, "#3A2C1A");
    mastGradient.addColorStop(1, "#4A3C2A");
    
    ctx.fillStyle = mastGradient;
    ctx.beginPath();
    ctx.moveTo(-3, -hullDepth + bob);
    ctx.lineTo(3, -hullDepth + bob);
    ctx.lineTo(2, -hullDepth - 90 + bob);
    ctx.lineTo(-2, -hullDepth - 90 + bob);
    ctx.closePath();
    ctx.fill();
    
    // Mast grain lines
    ctx.strokeStyle = "#1A0C0A";
    ctx.lineWidth = 0.5;
    for (let i = 0; i < 5; i++) {
      ctx.beginPath();
      ctx.moveTo(-2 + i, -hullDepth + bob);
      ctx.lineTo(-1.5 + i, -hullDepth - 90 + bob);
      ctx.stroke();
    }
    
    // Rigging/ropes
    ctx.strokeStyle = "#4A3C2A";
    ctx.lineWidth = 1.5;
    // Fore stay
    ctx.beginPath();
    ctx.moveTo(-2, -hullDepth - 90 + bob);
    ctx.lineTo(hullLength/2 - 5, -hullDepth + bob);
    ctx.stroke();
    // Back stay
    ctx.beginPath();
    ctx.moveTo(2, -hullDepth - 90 + bob);
    ctx.lineTo(-hullLength/2 + 5, -hullDepth + bob);
    ctx.stroke();
    // Shrouds
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.moveTo(-2 + i * 2, -hullDepth - 70 + bob);
      ctx.lineTo(-hullLength/2 + 10 + i * 15, -hullDepth + bob);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(2 - i * 2, -hullDepth - 70 + bob);
      ctx.lineTo(hullLength/2 - 10 - i * 15, -hullDepth + bob);
      ctx.stroke();
    }
    
    // Sail - level-specific colors and effects
    const theme = LevelThemes.getCurrent();
    const levelId = world.currentLevel || 1;
    const sailBillow = Math.sin(world.t * 3) * 10;
    
    // Level-specific sail colors
    const sailColors = {
      1: { start: "#2D5016", mid: "#3A6B1F", end: "#4A7B2F" }, // Forest green
      2: { start: "#B41E2A", mid: "#C41E3A", end: "#D41E4A" }, // Fire red
      3: { start: "#B0E0E6", mid: "#C0F0F6", end: "#D0FFFF" }, // Ice blue
      4: { start: "#FF4500", mid: "#FF5500", end: "#FF6500" }, // Fire orange
      5: { start: "#FFD700", mid: "#FFE700", end: "#FFF700" }, // Valhalla gold
      6: { start: "#4B0082", mid: "#5B0092", end: "#6B00A2" }, // Ragnarok purple
      7: { start: "#1E3A8A", mid: "#2E4A9A", end: "#3E5AAA" }, // Odin blue
      8: { start: "#FF0000", mid: "#00FF00", end: "#0000FF" }  // Rainbow
    };
    
    const sailColor = sailColors[levelId] || sailColors[1];
    const sailGradient = ctx.createLinearGradient(0, -hullDepth - 15 + bob, 50 + sailBillow * 1.5, -hullDepth - 5 + bob);
    sailGradient.addColorStop(0, sailColor.start);
    sailGradient.addColorStop(0.5, sailColor.mid);
    sailGradient.addColorStop(1, sailColor.end);
    
    ctx.fillStyle = sailGradient;
    ctx.beginPath();
    ctx.moveTo(0, -hullDepth - 15 + bob);
    ctx.quadraticCurveTo(25 + sailBillow, -hullDepth - 35 + bob, 55 + sailBillow * 1.5, -hullDepth - 22 + bob);
    ctx.lineTo(55 + sailBillow * 1.5, -hullDepth - 3 + bob);
    ctx.quadraticCurveTo(25 + sailBillow, -hullDepth + 8 + bob, 0, -hullDepth - 5 + bob);
    ctx.closePath();
    ctx.fill();
    
    // Sail stripes - alternating red and white
    ctx.fillStyle = "#FFF";
    for (let s = 0; s < 3; s++) {
      ctx.fillRect(12 + sailBillow * 0.3 + s * 12, -hullDepth - 12 + bob + s * 3, 10 + sailBillow * 0.3, 8);
    }
    
    // Sail details - realistic seams and stitching
    ctx.strokeStyle = "#A01E2A";
    ctx.lineWidth = 1.5;
    for (let seam = 0; seam < 3; seam++) {
      ctx.beginPath();
      ctx.moveTo(8 + sailBillow * 0.2 + seam * 15, -hullDepth - 10 + bob + seam * 2);
      ctx.quadraticCurveTo(20 + sailBillow * 0.4 + seam * 15, -hullDepth - 5 + bob + seam * 2, 30 + sailBillow * 0.6 + seam * 15, -hullDepth - 2 + bob + seam * 2);
      ctx.stroke();
    }
    
    // Sail shadow for depth
    ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
    ctx.beginPath();
    ctx.moveTo(0, -hullDepth - 15 + bob);
    ctx.quadraticCurveTo(15 + sailBillow * 0.5, -hullDepth - 25 + bob, 30 + sailBillow, -hullDepth - 15 + bob);
    ctx.lineTo(30 + sailBillow, -hullDepth - 3 + bob);
    ctx.quadraticCurveTo(15 + sailBillow * 0.5, -hullDepth + 3 + bob, 0, -hullDepth - 5 + bob);
    ctx.closePath();
    ctx.fill();
    
    // Simplified oars - fewer oars, simpler drawing
    ctx.strokeStyle = "#5D4E37";
    ctx.lineWidth = 2.5;
    const oarPositions = [-40, -15, 15, 40]; // Reduced from 6 to 4 oars
    oarPositions.forEach((ox, i) => {
      const oarPhase = world.t * 8 + i * 0.5;
      const oarAngle = Math.sin(oarPhase) * 0.4;
      const oarOut = Math.abs(Math.sin(oarPhase)) > 0.5;
      const oarDepth = oarOut ? 45 : 25;
      
      ctx.save();
      ctx.translate(ox, -hullDepth/2 + bob);
      ctx.rotate(0.3 + oarAngle);
      
      // Oar shaft - simple line (removed gradient)
      ctx.strokeStyle = "#5D4E37";
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, oarDepth);
      ctx.stroke();
      
      // Oar blade - simple ellipse
      ctx.fillStyle = "#3A2C1A";
      ctx.beginPath();
      ctx.ellipse(-3, oarDepth - 2, 6, 12, 0, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    });
    
    // Simplified Viking warriors on ship - fewer details, no nested loops
    const warriorPositions = [-30, 0, 30]; // Reduced from 4 to 3 warriors
    warriorPositions.forEach((wx, i) => {
      const warriorBob = bob + Math.sin(world.t * 4 + i) * 1;
      
      // Body/armor - simple rectangle (removed gradient and chainmail pattern)
      ctx.fillStyle = "#4A5568";
      ctx.fillRect(wx - 6, -hullDepth/2 - 15 + warriorBob, 12, 18);
      ctx.strokeStyle = "#2A3548";
      ctx.lineWidth = 1;
      ctx.strokeRect(wx - 6, -hullDepth/2 - 15 + warriorBob, 12, 18);
      
      // Head - simple circle
      ctx.fillStyle = "#ffdbac";
      ctx.beginPath();
      ctx.arc(wx, -hullDepth/2 - 20 + warriorBob, 5, 0, Math.PI * 2);
      ctx.fill();
      
      // Helmet - simple arc
      ctx.fillStyle = "#6B6270";
      ctx.beginPath();
      ctx.arc(wx, -hullDepth/2 - 22 + warriorBob, 6, Math.PI, 0);
      ctx.fill();
      
      // Weapon - simple line
      ctx.strokeStyle = "#6B6355";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(wx + 8, -hullDepth/2 - 18 + warriorBob);
      ctx.lineTo(wx + 15, -hullDepth/2 - 26 + warriorBob);
      ctx.stroke();
      // Weapon tip - simple triangle
      ctx.beginPath();
      ctx.moveTo(wx + 15, -hullDepth/2 - 26 + warriorBob);
      ctx.lineTo(wx + 18, -hullDepth/2 - 28 + warriorBob);
      ctx.lineTo(wx + 12, -hullDepth/2 - 28 + warriorBob);
      ctx.closePath();
      ctx.fill();
    });
    
    // Simplified shields - fewer, simpler
    const shieldPositions = [-40, 0, 40]; // Reduced from 4 to 3
    shieldPositions.forEach((sx, i) => {
      ctx.fillStyle = i % 2 === 0 ? "#C41E3A" : "#1E3A8A";
      ctx.beginPath();
      ctx.arc(sx, -hullDepth/2 + 5 + bob, 8, 0, Math.PI * 2);
      ctx.fill();
      // Shield boss only (removed cross pattern)
      ctx.fillStyle = "#FFD700";
      ctx.beginPath();
      ctx.arc(sx, -hullDepth/2 + 5 + bob, 3, 0, Math.PI * 2);
      ctx.fill();
    });
    
    // Realistic water wake trail - multiple layers
    // Main wake
    ctx.strokeStyle = "rgba(74, 144, 217, 0.5)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(-hullLength/2 - 12, bob + 6);
    ctx.quadraticCurveTo(-hullLength/4, bob + 10, 0, bob + 8);
    ctx.quadraticCurveTo(hullLength/4, bob + 10, hullLength/2 + 12, bob + 6);
    ctx.stroke();
    
    // Secondary wake (foam)
    ctx.strokeStyle = "rgba(135, 206, 235, 0.6)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-hullLength/2 - 8, bob + 7);
    ctx.quadraticCurveTo(-hullLength/4, bob + 9, 0, bob + 7.5);
    ctx.quadraticCurveTo(hullLength/4, bob + 9, hullLength/2 + 8, bob + 7);
    ctx.stroke();
    
    // Bow wave
    ctx.fillStyle = "rgba(74, 144, 217, 0.3)";
    ctx.beginPath();
    ctx.moveTo(hullLength/2 + 20, -hullDepth + bob);
    ctx.quadraticCurveTo(hullLength/2 + 25, bob + 3, hullLength/2 + 15, bob + 5);
    ctx.lineTo(hullLength/2 + 10, bob + 4);
    ctx.closePath();
    ctx.fill();
    
    // Stern wake
    ctx.fillStyle = "rgba(74, 144, 217, 0.2)";
    ctx.beginPath();
    ctx.moveTo(-hullLength/2 - 15, -hullDepth + bob);
    ctx.quadraticCurveTo(-hullLength/2 - 20, bob + 4, -hullLength/2 - 10, bob + 6);
    ctx.lineTo(-hullLength/2 - 5, bob + 5);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
  };

  const drawViking = (x, y) => {
    // Check if Viking ship mode is active
    if (world.powerups.vikingShip.active) {
      drawVikingShip(x, y);
      return;
    }
    
    ctx.save();
    ctx.translate(x, y);
    if (viking.faceplant > 0) ctx.rotate(viking.faceplant * -1);

    const bob = viking.onGround ? Math.sin(world.t * 12) * 4 : 0;
    const duckH = viking.ducking ? 0.5 : 1; // More pronounced ducking (was 0.6)
    const duckY = viking.ducking ? 10 : 0; // Lower position when ducking

    // Visual indicator when ducking (glow effect)
    if (viking.ducking) {
      const duckGlow = ctx.createRadialGradient(0, duckY, 0, 0, duckY, 40);
      duckGlow.addColorStop(0, 'rgba(0, 255, 0, 0.3)');
      duckGlow.addColorStop(1, 'rgba(0, 255, 0, 0)');
      ctx.fillStyle = duckGlow;
      ctx.beginPath();
      ctx.arc(0, duckY, 40, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.fillStyle = "#556677";
    ctx.fillRect(-20, -50 * duckH + bob + duckY, 40, 50 * duckH);

    ctx.fillStyle = "#ffdbac";
    ctx.beginPath(); ctx.arc(0, -65 * duckH + bob + duckY, 15, 0, Math.PI * 2); ctx.fill();

    ctx.fillStyle = "#e67e22";
    ctx.beginPath(); ctx.moveTo(-12, -60 * duckH + bob + duckY); ctx.lineTo(12, -60 * duckH + bob + duckY); ctx.lineTo(0, -35 * duckH + bob + duckY); ctx.fill();

    ctx.fillStyle = "#7f8c8d";
    ctx.beginPath(); ctx.arc(0, -70 * duckH + bob + duckY, 16, Math.PI, 0); ctx.fill();
    ctx.fillStyle = "#ecf0f1";
    ctx.beginPath(); ctx.moveTo(-15, -75 * duckH + bob + duckY); ctx.lineTo(-25, -90 * duckH + bob + duckY); ctx.lineTo(-10, -80 * duckH + bob + duckY); ctx.fill();
    ctx.beginPath(); ctx.moveTo(15, -75 * duckH + bob + duckY); ctx.lineTo(25, -90 * duckH + bob + duckY); ctx.lineTo(10, -80 * duckH + bob + duckY); ctx.fill();

    ctx.restore();
  };

  // Draw Viking-themed platforms (shields, logs, barrels, stone blocks)
  const drawPlatform = (p) => {
    ctx.save();
    ctx.translate(p.x, p.y);
    
    // Randomly select platform type if not specified
    const platformType = p.type || (Math.random() < 0.25 ? 'shield' : Math.random() < 0.5 ? 'log' : Math.random() < 0.75 ? 'barrel' : 'stone');
    
    if (platformType === 'shield') {
      // Viking round shield platform
      const shieldRadius = Math.min(p.width / 2, p.height);
      ctx.fillStyle = "#DC2626"; // Red shield
      ctx.beginPath();
      ctx.arc(p.width / 2, 0, shieldRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 3;
      ctx.stroke();
      // Shield boss (center metal)
      ctx.fillStyle = "#C0C0C0";
      ctx.beginPath();
      ctx.arc(p.width / 2, 0, shieldRadius * 0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      // Viking rune pattern
      ctx.strokeStyle = "#FFD700";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(p.width / 2 - shieldRadius * 0.4, 0 - shieldRadius * 0.4);
      ctx.lineTo(p.width / 2 + shieldRadius * 0.4, 0 + shieldRadius * 0.4);
      ctx.moveTo(p.width / 2 + shieldRadius * 0.4, 0 - shieldRadius * 0.4);
      ctx.lineTo(p.width / 2 - shieldRadius * 0.4, 0 + shieldRadius * 0.4);
      ctx.stroke();
    } else if (platformType === 'log') {
      // Wooden log platform
      const logGradient = ctx.createLinearGradient(0, 0, 0, p.height);
      logGradient.addColorStop(0, "#8B4513");
      logGradient.addColorStop(0.5, "#654321");
      logGradient.addColorStop(1, "#5D4037");
      ctx.fillStyle = logGradient;
      ctx.fillRect(0, 0, p.width, p.height);
      ctx.strokeStyle = "#3E2723";
      ctx.lineWidth = 2;
      ctx.strokeRect(0, 0, p.width, p.height);
      // Wood grain lines
      ctx.strokeStyle = "#5D4037";
      ctx.lineWidth = 1;
      for (let i = 5; i < p.width; i += 8) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i + 2, p.height);
        ctx.stroke();
      }
    } else if (platformType === 'barrel') {
      // Wooden barrel platform
      const barrelGradient = ctx.createRadialGradient(p.width / 2, p.height / 2, 0, p.width / 2, p.height / 2, p.width / 2);
      barrelGradient.addColorStop(0, "#8B4513");
      barrelGradient.addColorStop(1, "#654321");
      ctx.fillStyle = barrelGradient;
      ctx.fillRect(0, 0, p.width, p.height);
      ctx.strokeStyle = "#3E2723";
      ctx.lineWidth = 3;
      ctx.strokeRect(0, 0, p.width, p.height);
      // Barrel hoops
      ctx.strokeStyle = "#1A1A1A";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, p.height * 0.3);
      ctx.lineTo(p.width, p.height * 0.3);
      ctx.moveTo(0, p.height * 0.7);
      ctx.lineTo(p.width, p.height * 0.7);
      ctx.stroke();
    } else {
      // Stone block with runes
      const stoneGradient = ctx.createLinearGradient(0, 0, 0, p.height);
      stoneGradient.addColorStop(0, "#708090");
      stoneGradient.addColorStop(1, "#2F4F4F");
      ctx.fillStyle = stoneGradient;
      ctx.fillRect(0, 0, p.width, p.height);
      ctx.strokeStyle = "#1C1C1C";
      ctx.lineWidth = 2;
      ctx.strokeRect(0, 0, p.width, p.height);
      // Carved rune symbols
      ctx.fillStyle = "#FFD700";
      ctx.font = `bold ${p.height * 0.4}px Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("·ö†", p.width / 2, p.height / 2); // Fehu rune
    }
    
    ctx.restore();
  };

  // Draw proper Viking warrior enemy - Enhanced for clarity
  const drawEnemy = (e) => {
    if (e.defeated) return;
    
    // Special handling for birds - use bird drawing function
    if (e.isBird) {
      drawBirdEnemy(e);
      return;
    }
    
    ctx.save();
    ctx.translate(e.x, e.y);
    
    // Ensure enemy has valid properties
    if (!e.type || !enemyProps[e.type]) {
      console.warn('Enemy missing type or props:', e);
      ctx.restore();
      return;
    }
    
    const groundOffset = 0;
    const bodyHeight = e.h * 0.6;
    const bodyWidth = e.w * 0.7;
    const props = enemyProps[e.type] || { weapon: 'axe', color: '#8B4513', w: 75, h: 90 };
    
    // Fur cloak (Viking style) - behind body
    ctx.fillStyle = props.color || "#654321";
    ctx.beginPath();
    ctx.moveTo(-bodyWidth/2 - 5, groundOffset);
    ctx.lineTo(-bodyWidth/2 - 8, -bodyHeight * 0.3);
    ctx.lineTo(bodyWidth/2 + 8, -bodyHeight * 0.3);
    ctx.lineTo(bodyWidth/2 + 5, groundOffset);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "#3A2C1A";
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Body/tunic - Viking colors
    const tunicColor = props.color || "#4A5568";
    ctx.fillStyle = tunicColor;
    ctx.beginPath();
    ctx.moveTo(-bodyWidth/2, groundOffset);
    ctx.lineTo(-bodyWidth/2 + 5, -bodyHeight * 0.2);
    ctx.lineTo(bodyWidth/2 - 5, -bodyHeight * 0.2);
    ctx.lineTo(bodyWidth/2, groundOffset);
    ctx.lineTo(bodyWidth/2 - 8, -bodyHeight * 0.4);
    ctx.lineTo(-bodyWidth/2 + 8, -bodyHeight * 0.4);
    ctx.closePath();
    ctx.fill();
    
    // Strong black outline
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 3;
    ctx.stroke();
    
    // Leather armor/chainmail overlay
    ctx.fillStyle = "#2D3748";
    ctx.fillRect(-bodyWidth/2 + 8, -bodyHeight * 0.35, bodyWidth - 16, bodyHeight * 0.25);
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 2;
    ctx.strokeRect(-bodyWidth/2 + 8, -bodyHeight * 0.35, bodyWidth - 16, bodyHeight * 0.25);
    
    // Leather belt with metal buckle
    ctx.fillStyle = "#1A202C";
    ctx.fillRect(-bodyWidth/2 + 5, -bodyHeight * 0.15, bodyWidth - 10, 6);
    ctx.strokeRect(-bodyWidth/2 + 5, -bodyHeight * 0.15, bodyWidth - 10, 6);
    // Buckle
    ctx.fillStyle = "#FFD700";
    ctx.fillRect(-4, -bodyHeight * 0.15, 8, 6);
    ctx.strokeRect(-4, -bodyHeight * 0.15, 8, 6);
    
    // Head - Viking face
    ctx.fillStyle = "#d4a574";
    ctx.beginPath();
    ctx.arc(0, -bodyHeight - 8, 18, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 3;
    ctx.stroke();
    
    // Horned helmet (Viking style!)
    ctx.fillStyle = "#4A5568";
    ctx.beginPath();
    ctx.arc(0, -bodyHeight - 10, 20, Math.PI, 0);
    ctx.fill();
    ctx.stroke();
    // Nose guard
    ctx.fillRect(-3, -bodyHeight - 12, 6, 20);
    ctx.strokeRect(-3, -bodyHeight - 12, 6, 20);
    // Left horn
    ctx.beginPath();
    ctx.moveTo(-18, -bodyHeight - 8);
    ctx.lineTo(-22, -bodyHeight - 20);
    ctx.lineTo(-18, -bodyHeight - 18);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    // Right horn
    ctx.beginPath();
    ctx.moveTo(18, -bodyHeight - 8);
    ctx.lineTo(22, -bodyHeight - 20);
    ctx.lineTo(18, -bodyHeight - 18);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Eyes (fierce) - blue/gray
    ctx.fillStyle = "#1E40AF";
    ctx.fillRect(-10, -bodyHeight - 8, 6, 5);
    ctx.fillRect(4, -bodyHeight - 8, 6, 5);
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 2;
    ctx.strokeRect(-10, -bodyHeight - 8, 6, 5);
    ctx.strokeRect(4, -bodyHeight - 8, 6, 5);
    
    // Beard (Viking style - long and braided)
    ctx.fillStyle = "#2A1C0A";
    ctx.beginPath();
    ctx.moveTo(-12, -bodyHeight + 5);
    ctx.quadraticCurveTo(0, -bodyHeight + 20, 12, -bodyHeight + 5);
    ctx.lineTo(10, -bodyHeight + 2);
    ctx.quadraticCurveTo(0, -bodyHeight + 12, -10, -bodyHeight + 2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    // Braid details
    ctx.strokeStyle = "#1A0C0A";
    ctx.lineWidth = 1;
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.moveTo(-8 + i * 4, -bodyHeight + 8);
      ctx.lineTo(-6 + i * 4, -bodyHeight + 15);
      ctx.stroke();
    }
    
    // Viking shield - round with Viking symbols (not cross!)
    ctx.fillStyle = "#DC2626"; // Red background
    ctx.beginPath();
    ctx.arc(-bodyWidth/2 - 12, -bodyHeight * 0.3, 24, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 3;
    ctx.stroke();
    // Shield boss (center metal)
    ctx.fillStyle = "#C0C0C0";
    ctx.beginPath();
    ctx.arc(-bodyWidth/2 - 12, -bodyHeight * 0.3, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    // Viking symbol (rune or geometric pattern, not cross)
    ctx.strokeStyle = "#FFD700";
    ctx.lineWidth = 3;
    // Draw a simple Viking rune pattern (X-like)
    ctx.beginPath();
    ctx.moveTo(-bodyWidth/2 - 12 - 10, -bodyHeight * 0.3 - 10);
    ctx.lineTo(-bodyWidth/2 - 12 + 10, -bodyHeight * 0.3 + 10);
    ctx.moveTo(-bodyWidth/2 - 12 + 10, -bodyHeight * 0.3 - 10);
    ctx.lineTo(-bodyWidth/2 - 12 - 10, -bodyHeight * 0.3 + 10);
    ctx.stroke();
    
    // Weapon - Viking weapons (axe, sword, or spear)
    const weapon = props.weapon || 'axe';
    
    if (weapon === 'spear') {
      // Viking spear
      ctx.fillStyle = "#78350f";
      ctx.fillRect(bodyWidth/2, -bodyHeight * 0.2, 4, 60);
      ctx.strokeRect(bodyWidth/2, -bodyHeight * 0.2, 4, 60);
      // Spear tip
      ctx.fillStyle = "#a1a1aa";
      ctx.beginPath();
      ctx.moveTo(bodyWidth/2 + 2, -bodyHeight * 0.2);
      ctx.lineTo(bodyWidth/2 - 4, -bodyHeight * 0.2 - 15);
      ctx.lineTo(bodyWidth/2 + 8, -bodyHeight * 0.2 - 15);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 2;
      ctx.stroke();
    } else if (weapon === 'axe') {
      // Viking axe (most common)
      ctx.fillStyle = "#78350f";
      ctx.fillRect(bodyWidth/2, -bodyHeight * 0.2, 6, 50);
      ctx.strokeRect(bodyWidth/2, -bodyHeight * 0.2, 6, 50);
      // Axe head - Viking style (larger, curved)
      ctx.fillStyle = "#a1a1aa";
      ctx.beginPath();
      ctx.moveTo(bodyWidth/2 + 3, -bodyHeight * 0.2);
      ctx.lineTo(bodyWidth/2 + 18, -bodyHeight * 0.2 - 10);
      ctx.lineTo(bodyWidth/2 + 22, -bodyHeight * 0.2 - 6);
      ctx.lineTo(bodyWidth/2 + 15, -bodyHeight * 0.2 + 4);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 2;
      ctx.stroke();
    } else {
      // Viking sword
      ctx.fillStyle = "#78350f";
      ctx.fillRect(bodyWidth/2, -bodyHeight * 0.2, 4, 55);
      ctx.strokeRect(bodyWidth/2, -bodyHeight * 0.2, 4, 55);
      // Sword blade - Viking style (slightly curved)
      ctx.fillStyle = "#C0C0C0";
      ctx.beginPath();
      ctx.moveTo(bodyWidth/2 + 2, -bodyHeight * 0.2);
      ctx.lineTo(bodyWidth/2 + 10, -bodyHeight * 0.2 - 14);
      ctx.lineTo(bodyWidth/2 - 2, -bodyHeight * 0.2 - 14);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }
    
    // Legs - Viking style (leather boots)
    ctx.fillStyle = "#1A202C";
    ctx.fillRect(-bodyWidth/2 + 5, groundOffset, 8, 20);
    ctx.fillRect(bodyWidth/2 - 13, groundOffset, 8, 20);
    ctx.strokeRect(-bodyWidth/2 + 5, groundOffset, 8, 20);
    ctx.strokeRect(bodyWidth/2 - 13, groundOffset, 8, 20);
    
    ctx.restore();
  };
  
  // Draw bird enemy (flying bird - level-specific)
  const drawBirdEnemy = (e) => {
    ctx.save();
    ctx.translate(e.x, e.y);
    
    const wingFlap = Math.sin(world.t * 10) * 0.3;
    const birdType = e.type || 'crow';
    
    // Bird-specific properties
    const birdStyles = {
      crow: { bodyColor: '#000000', beakColor: '#FFA500', size: 1.0, wingSize: 1.0 },
      raven: { bodyColor: '#000000', beakColor: '#FFA500', size: 1.2, wingSize: 1.2 },
      seagull: { bodyColor: '#FFFFFF', beakColor: '#FFD700', size: 1.1, wingSize: 1.3 },
      eagle: { bodyColor: '#8B4513', beakColor: '#FFA500', size: 1.6, wingSize: 1.8 },
      hawk: { bodyColor: '#654321', beakColor: '#FF8C00', size: 1.3, wingSize: 1.4 },
      mythicalRaven: { bodyColor: '#4B0082', beakColor: '#FFD700', size: 1.8, wingSize: 2.0, glow: true },
      phoenix: { bodyColor: '#FF4500', beakColor: '#FFD700', size: 2.0, wingSize: 2.2, glow: true }
    };
    
    const style = birdStyles[birdType] || birdStyles.crow;
    const bodySize = e.w * 0.5 * style.size;
    const headSize = bodySize * 0.6;
    const wingWidth = e.w * 0.4 * style.wingSize;
    const wingHeight = e.h * 0.3;
    
    // Glow effect for mythical birds
    if (style.glow) {
      ctx.shadowBlur = 15;
      ctx.shadowColor = style.bodyColor;
    }
    
    // Body - oval
    ctx.fillStyle = style.bodyColor;
    ctx.beginPath();
    ctx.ellipse(0, 0, bodySize, bodySize * 1.5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Wings - animated flapping
    ctx.fillStyle = style.bodyColor;
    ctx.beginPath();
    ctx.ellipse(-wingWidth, 0, wingWidth, wingHeight, -0.5 + wingFlap, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.beginPath();
    ctx.ellipse(wingWidth, 0, wingWidth, wingHeight, 0.5 - wingFlap, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    
    // Head
    ctx.beginPath();
    ctx.arc(0, -bodySize - 5, headSize, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    
    // Beak
    ctx.fillStyle = style.beakColor;
    ctx.beginPath();
    ctx.moveTo(0, -bodySize - headSize);
    ctx.lineTo(-headSize * 0.4, -bodySize - headSize * 1.5);
    ctx.lineTo(headSize * 0.4, -bodySize - headSize * 1.5);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 1;
    ctx.stroke();
    
    // Eye
    ctx.fillStyle = "#FF0000";
    ctx.beginPath();
    ctx.arc(-headSize * 0.3, -bodySize - headSize * 0.7, headSize * 0.2, 0, Math.PI * 2);
    ctx.fill();
    
    // Tail
    ctx.fillStyle = style.bodyColor;
    ctx.beginPath();
    ctx.moveTo(0, bodySize);
    ctx.quadraticCurveTo(-wingWidth * 0.5, bodySize * 1.5, -wingWidth, bodySize * 2);
    ctx.quadraticCurveTo(-wingWidth * 0.3, bodySize * 1.8, 0, bodySize * 1.3);
    ctx.quadraticCurveTo(wingWidth * 0.3, bodySize * 1.8, wingWidth, bodySize * 2);
    ctx.quadraticCurveTo(wingWidth * 0.5, bodySize * 1.5, 0, bodySize);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    ctx.shadowBlur = 0;
    ctx.restore();
  };


  // Draw Viking-themed health item (mead horn, not abstract heart)
  const drawHeart = (x, y, pulse, rotation) => {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    const size = 20 * pulse;
    
    // Glow effect
    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 2);
    gradient.addColorStop(0, "#ef4444AA");
    gradient.addColorStop(0.5, "#ef444460");
    gradient.addColorStop(1, "#ef444400");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(0, 0, size * 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Viking drinking horn (mead horn) - healing item
    ctx.shadowBlur = 15;
    ctx.shadowColor = "#ef4444";
    
    // Horn body (curved shape)
    ctx.fillStyle = "#8B4513"; // Brown leather/horn color
    ctx.beginPath();
    ctx.moveTo(-size * 0.3, size * 0.4);
    ctx.quadraticCurveTo(-size * 0.6, -size * 0.2, -size * 0.2, -size * 0.6);
    ctx.quadraticCurveTo(0, -size * 0.8, size * 0.2, -size * 0.6);
    ctx.quadraticCurveTo(size * 0.6, -size * 0.2, size * 0.3, size * 0.4);
    ctx.lineTo(size * 0.1, size * 0.5);
    ctx.quadraticCurveTo(0, size * 0.6, -size * 0.1, size * 0.5);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "#654321";
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Mead/health liquid inside (red/gold)
    ctx.fillStyle = "#f1c40f"; // Golden mead
    ctx.beginPath();
    ctx.moveTo(-size * 0.2, size * 0.2);
    ctx.quadraticCurveTo(-size * 0.4, -size * 0.1, -size * 0.15, -size * 0.4);
    ctx.quadraticCurveTo(0, -size * 0.5, size * 0.15, -size * 0.4);
    ctx.quadraticCurveTo(size * 0.4, -size * 0.1, size * 0.2, size * 0.2);
    ctx.closePath();
    ctx.fill();
    
    // Metal rim at top
    ctx.fillStyle = "#C0C0C0";
    ctx.beginPath();
    ctx.arc(0, -size * 0.6, size * 0.15, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 1;
    ctx.stroke();
    
    ctx.shadowBlur = 0;
    ctx.restore();
  };

  // Draw Viking coin/treasure (not abstract ball)
  const drawGold = (g) => {
    ctx.save();
    ctx.translate(g.x, g.y);
    ctx.rotate(g.rotation);
    const size = 18;
    
    // Glow effect (golden treasure glow)
    const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 2);
    glow.addColorStop(0, "#ffd70080");
    glow.addColorStop(0.5, "#ffd70040");
    glow.addColorStop(1, "#ffd70000");
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(0, 0, size * 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Viking coin - round with decorative border
    ctx.fillStyle = "#ffd700";
    ctx.shadowBlur = 15;
    ctx.shadowColor = "#ffd700";
    ctx.beginPath();
    ctx.arc(0, 0, size, 0, Math.PI * 2);
    ctx.fill();
    
    // Decorative border (Viking style)
    ctx.strokeStyle = "#b8860b";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, size - 2, 0, Math.PI * 2);
    ctx.stroke();
    
    // Inner shine
    ctx.fillStyle = "#fff8dc";
    ctx.beginPath();
    ctx.arc(-size * 0.3, -size * 0.3, size * 0.4, 0, Math.PI * 2);
    ctx.fill();
    
    // Viking rune symbol instead of $ (Fehu rune for wealth)
    ctx.fillStyle = "#b8860b";
    ctx.font = `bold ${size * 0.8}px Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("·ö†", 0, 2); // Fehu rune (wealth/treasure)
    
    ctx.shadowBlur = 0;
    ctx.restore();
  };

  // Draw Viking shield obstacle (proper round shield, not abstract)
  const drawShield = (x, y) => {
    ctx.save();
    ctx.translate(x, world.groundY);
    
    // Round Viking shield
    ctx.fillStyle = "#DC2626"; // Red shield background
    ctx.beginPath();
    ctx.arc(0, -22, 22, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 3;
    ctx.stroke();
    
    // Shield boss (center metal)
    ctx.fillStyle = "#C0C0C0";
    ctx.beginPath();
    ctx.arc(0, -22, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    
    // Viking rune pattern (not cross)
    ctx.strokeStyle = "#FFD700";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-10, -22 - 10);
    ctx.lineTo(10, -22 + 10);
    ctx.moveTo(10, -22 - 10);
    ctx.lineTo(-10, -22 + 10);
    ctx.stroke();
    
    ctx.restore();
  };

  // Draw Viking stone/rock obstacle (carved stone, not abstract triangle)
  const drawRock = (x, y) => {
    ctx.save();
    ctx.translate(x, world.groundY);
    
    // Stone block shape (more realistic than triangle)
    const stoneWidth = 50;
    const stoneHeight = 45;
    const stoneGradient = ctx.createLinearGradient(-stoneWidth/2, -stoneHeight, -stoneWidth/2, 0);
    stoneGradient.addColorStop(0, "#708090");
    stoneGradient.addColorStop(1, "#2F4F4F");
    ctx.fillStyle = stoneGradient;
    ctx.beginPath();
    ctx.moveTo(-stoneWidth/2, 0);
    ctx.lineTo(-stoneWidth/2 + 5, -stoneHeight);
    ctx.lineTo(stoneWidth/2 - 5, -stoneHeight);
    ctx.lineTo(stoneWidth/2, 0);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "#1C1C1C";
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Carved rune on stone
    ctx.fillStyle = "#FFD700";
    ctx.font = "bold 16px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("·ö†", 0, -stoneHeight/2); // Fehu rune
    
    ctx.restore();
  };

  const drawMead = (x, y) => {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = "#f1c40f";
    ctx.fillRect(-10, -15, 20, 25);
    ctx.fillStyle = "#fff";
    ctx.beginPath(); ctx.arc(-5, -15, 6, 0, Math.PI*2); ctx.arc(5, -15, 6, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = "#f1c40f"; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.arc(10, -2, 8, -Math.PI/2, Math.PI/2); ctx.stroke();
    ctx.restore();
  };

  const getPowerupColor = (type) => {
    const theme = LevelThemes.getCurrent();
    const levelId = world.currentLevel || 1;
    
    // Base colors
    const baseColors = {
      speedBoost: "#FF6B6B",
      invincibility: "#4ECDC4",
      scoreMultiplier: "#FFD93D",
      vikingShip: "#8B4513",
      respawn: "#9B59B6",
      respawnPlus: "#FFD700" // Gold color for rare respawn
    };
    
    // Level-specific color tints
    const levelTints = {
      1: { r: 0.2, g: 0.8, b: 0.2 }, // Forest green
      2: { r: 0.9, g: 0.3, b: 0.1 }, // Fire red/orange
      3: { r: 0.5, g: 0.7, b: 1.0 }, // Ice blue
      4: { r: 1.0, g: 0.4, b: 0.0 }, // Fire red
      5: { r: 0.9, g: 0.7, b: 0.2 }, // Valhalla gold
      6: { r: 0.6, g: 0.2, b: 0.8 }, // Ragnarok purple
      7: { r: 0.3, g: 0.3, b: 0.9 }, // Odin blue
      8: { r: 1.0, g: 0.0, b: 1.0 }  // Rainbow magenta
    };
    
    const tint = levelTints[levelId] || levelTints[1];
    const baseColor = baseColors[type] || "#FFF";
    
    // Apply tint to base color
    if (baseColor.startsWith("#")) {
      const r = parseInt(baseColor.slice(1, 3), 16);
      const g = parseInt(baseColor.slice(3, 5), 16);
      const b = parseInt(baseColor.slice(5, 7), 16);
      
      const newR = Math.min(255, Math.floor(r * (1 - tint.r * 0.3) + 255 * tint.r * 0.3));
      const newG = Math.min(255, Math.floor(g * (1 - tint.g * 0.3) + 255 * tint.g * 0.3));
      const newB = Math.min(255, Math.floor(b * (1 - tint.b * 0.3) + 255 * tint.b * 0.3));
      
      return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
    }
    
    return baseColor;
  };

  const getPowerupSymbol = (type) => {
    const symbols = {
      speedBoost: "‚ö°",
      invincibility: "üõ°",
      scoreMultiplier: "‚≠ê",
      scorePowerup: "üí∞", // Coin symbol for score powerup
      vikingShip: "‚õµ",
      respawn: "üîÑ",
      respawnPlus: "‚≠ê" // Star for rare respawn (different from scoreMultiplier due to gold color)
    };
    return symbols[type] || "?";
  };

  const activatePowerup = (type, powerupValue) => {
    // Handle score powerup - instant points (no timer)
    if (type === "scorePowerup" && powerupValue) {
      world.score += powerupValue;
      updateHUD();
      playSFX('powerup');
      showStickinessNotification(`üí∞ +${powerupValue.toLocaleString()} Points!`, 'success');
      return; // Score powerup doesn't activate a timer
    }
    
    const p = world.powerups[type];
    if (!p) return; // Powerup type doesn't exist
    p.active = true;
    
    if (type === "vikingShip") {
      p.timeLeft = rand(5, 10); // Random 5-10 seconds
      playSFX('shipStart'); // Initial activation sound
      startPowerupSound('vikingShip'); // Start looping sound
    } else if (type === "speedBoost") {
      p.timeLeft = 10;
      playSFX('speedBoost'); // Initial activation sound
      startPowerupSound('speedBoost'); // Start looping sound
    } else if (type === "invincibility") {
      p.timeLeft = 10;
      playSFX('invincibility'); // Initial activation sound
      startPowerupSound('invincibility'); // Start looping sound
    } else if (type === "scoreMultiplier") {
      p.timeLeft = 10;
      playSFX('powerup'); // Initial activation sound
      startPowerupSound('scoreMultiplier'); // Start looping sound
    } else if (type === "respawn") {
      // Increment respawn count (each gives 1 life when used)
      world.powerups.respawn.count = (world.powerups.respawn.count || 0) + 1;
      playSFX('powerup');
      showStickinessNotification(`üîÑ RESPAWN COLLECTED! (${world.powerups.respawn.count} total)`, 'info');
      updateHUD();
    } else if (type === "respawnPlus") {
      // Rare respawn that gives 3 lives (very rare)
      world.powerups.respawnPlus.count = (world.powerups.respawnPlus.count || 0) + 1;
      playSFX('powerup');
      showStickinessNotification(`‚≠ê RARE RESPAWN+ COLLECTED! (${world.powerups.respawnPlus.count} total - gives 3 lives!)`, 'info');
      updateHUD();
    } else {
      p.timeLeft = 10;
    }
    
    if (type === "scoreMultiplier") {
      p.multiplier = 2;
    }
    updateHUD();
  };

  const drawPowerup = (x, y, type, rotation, pulse) => {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    const isRare = type === "respawnPlus";
    const size = isRare ? 28 * pulse : 22 * pulse; // Larger for rare respawn
    const color = getPowerupColor(type);
    const theme = LevelThemes.getCurrent();
    const levelId = world.currentLevel || 1;
    
    // Special glow for rare respawn
    if (isRare) {
      const rareGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 3);
      rareGlow.addColorStop(0, color + "FF");
      rareGlow.addColorStop(0.3, color + "AA");
      rareGlow.addColorStop(0.6, color + "60");
      rareGlow.addColorStop(1, color + "00");
      ctx.fillStyle = rareGlow;
      ctx.beginPath();
      ctx.arc(0, 0, size * 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 20;
      ctx.shadowColor = color;
    } else {
      // Level-specific glow intensity
      const glowIntensity = levelId >= 6 ? 15 : levelId >= 4 ? 10 : 5;
      ctx.shadowBlur = glowIntensity;
      ctx.shadowColor = color;
    }
    
    // Draw Viking-themed shape instead of circle
    ctx.fillStyle = color;
    ctx.strokeStyle = isRare ? "#FFD700" : "#FFF";
    ctx.lineWidth = isRare ? 4 : 3;
    
    if (type === 'speedBoost') {
      // Draw Fehu rune (F) for speed - Viking rune symbol
      ctx.beginPath();
      // Vertical line
      ctx.moveTo(0, -size);
      ctx.lineTo(0, size);
      // Top horizontal
      ctx.moveTo(-size * 0.6, -size * 0.7);
      ctx.lineTo(size * 0.6, -size * 0.7);
      // Middle diagonal
      ctx.moveTo(-size * 0.4, 0);
      ctx.lineTo(size * 0.4, 0);
      ctx.stroke();
    } else if (type === 'invincibility') {
      // Draw round Viking shield
      ctx.beginPath();
      ctx.arc(0, 0, size, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      // Shield boss (center decoration)
      ctx.fillStyle = "#FFD700";
      ctx.beginPath();
      ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#FFF";
      ctx.stroke();
    } else if (type === 'scoreMultiplier') {
      // Draw Viking axe
      ctx.beginPath();
      // Axe head (triangle)
      ctx.moveTo(0, -size * 0.8);
      ctx.lineTo(size * 0.6, -size * 0.3);
      ctx.lineTo(size * 0.3, size * 0.2);
      ctx.lineTo(0, -size * 0.2);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      // Axe handle
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(-size * 0.15, size * 0.2, size * 0.3, size * 0.8);
      ctx.strokeRect(-size * 0.15, size * 0.2, size * 0.3, size * 0.8);
    } else if (type === 'vikingShip') {
      // Draw ship silhouette
      ctx.beginPath();
      // Hull (curved bottom)
      ctx.moveTo(-size * 0.8, size * 0.3);
      ctx.quadraticCurveTo(0, -size * 0.2, size * 0.8, size * 0.3);
      ctx.lineTo(size * 0.8, size * 0.5);
      ctx.quadraticCurveTo(0, size * 0.1, -size * 0.8, size * 0.5);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      // Mast
      ctx.strokeStyle = "#8B4513";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, -size * 0.2);
      ctx.lineTo(0, -size * 1.2);
      ctx.stroke();
      // Sail
      ctx.fillStyle = color + "CC";
      ctx.beginPath();
      ctx.moveTo(0, -size * 1.2);
      ctx.lineTo(size * 0.6, -size * 0.6);
      ctx.lineTo(size * 0.6, -size * 0.2);
      ctx.lineTo(0, -size * 0.2);
      ctx.closePath();
      ctx.fill();
    } else if (type === 'respawn' || type === 'respawnPlus') {
      // Draw Viking horn (drinking horn)
      ctx.beginPath();
      // Horn shape (curved)
      ctx.moveTo(-size * 0.3, size * 0.5);
      ctx.quadraticCurveTo(0, -size * 0.5, size * 0.3, size * 0.5);
      ctx.lineTo(size * 0.2, size * 0.7);
      ctx.quadraticCurveTo(0, size * 0.3, -size * 0.2, size * 0.7);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      // Horn rim
      ctx.strokeStyle = "#FFD700";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, size * 0.6, size * 0.25, 0, Math.PI * 2);
      ctx.stroke();
    } else {
      // Fallback: draw rune symbol
      ctx.font = `bold ${size * 1.2}px Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("·ö†", 0, 0); // Fehu rune
    }
    
    ctx.shadowBlur = 0;
    ctx.restore();
  };

  const drawParticle = (p) => {
    // Particles disabled - no abstract balls
    return;
    /*
    ctx.save();
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.shadowBlur = 10;
    ctx.shadowColor = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    */
  };

  const checkPlatformCollision = (dt) => {
    // Platforms disabled - no collision checking
    return false;
    
    // OLD CODE - Platforms disabled
    /*
    const vikingHeight = viking.ducking ? 42 : 70; // Ducking makes viking shorter
    const vikingWidth = 40;
    const vikingLeft = viking.x - vikingWidth/2;
    const vikingRight = viking.x + vikingWidth/2;
    const vikingTop = viking.y - vikingHeight;
    const vikingBottom = viking.y;
    
    for (const p of Platforms) {
      const platformLeft = p.x;
      const platformRight = p.x + p.width;
      const platformTop = p.y;
      const platformBottom = p.y + p.height;
      
      // Check horizontal overlap
      if (vikingRight > platformLeft && vikingLeft < platformRight) {
        // Low platform collision - must duck or jump over
        if (p.isLow) {
          // Check if landing ON TOP of low platform (safe - like regular platform)
          if (vikingBottom <= platformTop + 10 && vikingBottom + viking.vy * dt >= platformTop && viking.vy >= 0) {
            // Landing on top is safe - treat like regular platform
            viking.y = platformTop;
            viking.vy = 0;
            viking.onGround = true;
            viking.jumpsUsed = 0;
            return true;
          }
          
          // If viking hits low platform from SIDE or BELOW while standing, lose life
          // Only damage if NOT landing from above and NOT ducking
          if (!viking.ducking && vikingBottom > platformTop && vikingTop < platformBottom) {
            // Check if hitting from side (not landing from above)
            if (vikingBottom > platformTop + 10 || viking.vy < 0) {
              if (!world.powerups.invincibility.active && !world.powerups.vikingShip.active) {
                world.lives--;
                addParticle(viking.x, viking.y, "#ef4444", 15);
                playSFX('damage');
                updateHUD();
                
                if (world.lives <= 0) {
                  // Check for respawn powerup
                  if (activateRespawn()) {
                    playSFX('powerup');
                    updateHUD();
                    if (statePill) statePill.textContent = "Playing";
                  } else {
                    // Stop all powerup sounds on game over
                    for (const key in powerupSounds) {
                      stopPowerupSound(key);
                    }
                    world.over = true;
                    viking.faceplant = 1.5;
                    if (statePill) statePill.textContent = "Game Over";
                    engagement.sessionDeaths++;
                    if (world.score > engagement.personalBest) {
                      engagement.personalBest = Math.floor(world.score);
                      localStorage.setItem('personalBest', engagement.personalBest.toString());
                    }
                    
                    // Check for prestige opportunity
                    if (PrestigeSystem.canPrestige(world.score)) {
                      setTimeout(() => {
                        const prestige = confirm(`‚≠ê You've reached Prestige ${PrestigeSystem.level + 1} threshold!\n\nPrestige to gain ${PrestigeSystem.calculatePoints(world.score).toLocaleString()} Prestige Points and permanent bonuses!\n\n(You'll keep your prestige level and points, but reset your current run)`);
                        if (prestige) {
                          PrestigeSystem.prestige(world.score);
                          // Track weekly challenge: prestige
                          WeeklyChallenges.updateProgress('prestige', 1);
                        }
                      }, 1500);
                    }
                    
                    HighScoreManager.saveScore(world.score);
                    playSFX('gameover');
                    setTimeout(() => { 
                      if (overlay) {
                        overlay.style.display = "grid";
                        overlay.style.visibility = "visible";
                        overlay.style.opacity = "1";
                      }
                      const overlayTitle = $("overlayTitle");
                      const overlayText = $("overlayText");
                      if (overlayTitle) overlayTitle.textContent = "Game Over";
                      if (overlayText) overlayText.textContent = `Hit a low platform!\nFinal Score: ${Math.floor(world.score).toLocaleString()}\nMead Collected: ${world.mead}`;
                      const startBtn = $("startBtn");
                      if (startBtn) startBtn.textContent = "Play Again";
                    }, 1200);
                  }
                } else {
                  world.powerups.invincibility.active = true;
                  world.powerups.invincibility.timeLeft = 2;
                }
              }
              return false; // Don't land on low platform from side
            }
          }
          // Can pass under if ducking
          return false;
        }
        
        // Regular platform - landing from above
        if (vikingBottom <= platformTop + 10 && vikingBottom + viking.vy * dt >= platformTop && viking.vy >= 0) {
          viking.y = platformTop;
          viking.vy = 0;
          viking.onGround = true;
          viking.jumpsUsed = 0;
          return true;
        }
        // Hitting platform from below
        if (vikingTop + viking.vy * dt <= platformBottom && vikingTop >= platformBottom - 10 && viking.vy < 0) {
          viking.vy = 0;
          viking.y = platformBottom + vikingHeight;
          return true;
        }
      }
    }
    return false;
    */
  };

  const update = (dt) => {
    try {
      if (!dt || dt <= 0 || dt > 1) return; // Safety check
      if (!world.started || world.paused || world.over) {
        Input.jumpJustPressed = false;
        return;
      }
      if (!H || H === 0) {
        console.warn("H is not set, cannot update");
        return;
      }

    world.t += dt;
    Achievements.sessionStats.timeSurvived = world.t;
    
    // Progressive difficulty scaling
    const diff = DifficultyModes.getCurrent();
    const baseSpeed = diff.baseSpeed;
    const maxSpeed = diff.maxSpeed;
    
    // Score-based acceleration multiplier
    const scoreAccelMultiplier = 1.0 + (world.score / 100000) * 0.5;
    const speedIncrease = 3 * dt * scoreAccelMultiplier;
    
    world.speed = Math.min(maxSpeed, world.speed + speedIncrease);
    if (world.speed > baseSpeed) {
      world.speed = Math.max(baseSpeed, world.speed - speedIncrease);
    }
    
    // Speed boost: 1.5x movement speed when active
    // Viking ship: 2x speed (faster than speed boost!)
    let speedMultiplier = 1.0;
    if (world.powerups.vikingShip.active) {
      speedMultiplier = 2.0;
    } else if (world.powerups.speedBoost.active) {
      speedMultiplier = 1.5;
    }
    const actualSpeed = world.speed * speedMultiplier;
    viking.x += actualSpeed * dt;
    const scoreMultiplier = world.powerups.scoreMultiplier.active ? world.powerups.scoreMultiplier.multiplier : 1;
    const streakBonus = engagement.streakBonus || 1.0;
    const prestigeMultiplier = PrestigeSystem.getScoreMultiplier();
    const eventMultiplier = EventSystem.getScoreMultiplier();
    world.score += world.speed * 0.015 * dt * scoreMultiplier * streakBonus * prestigeMultiplier * eventMultiplier;
    
    // Combo timer decay
    if (engagement.combo.timer > 0) {
      engagement.combo.timer -= dt;
      if (engagement.combo.timer <= 0) {
        engagement.combo.count = 0;
      }
    }
    
    // Screen shake decay
    if (world.screenShake > 0) {
      world.screenShake -= dt * 2;
    }
    
    // Golden run timer
    if (world.goldenRun) {
      world.goldenRunTimer -= dt;
      if (world.goldenRunTimer <= 0) world.goldenRun = false;
    }
    
    // Track total session score for addiction metrics
    engagement.totalSessionScore = world.score;
    
    // Dynamic streak bonus (increases score multiplier the longer you survive without damage)
    engagement.streakBonus = Math.min(2.0, 1.0 + (world.t / 120)); // Max 2x after 2 minutes
    
    // Check for level unlocks
    LevelSystem.checkUnlocks(world.score);
    
    // Check for unlockables
    Unlockables.checkUnlocks(world.score, world.currentLevel);
    
    // Check "almost there" notifications (throttled)
    if (Math.random() < 0.01) { // 1% chance per frame to check
      checkAlmostThereNotifications();
    }
    
    // Check for active events and apply multipliers
    if (EventSystem.isActive()) {
      const eventMultiplier = EventSystem.getScoreMultiplier();
      if (eventMultiplier > 1.0) {
        // Event score multiplier is already applied in score calculation above
        // This is just for checking if event is active
      }
    }
    
    // Update world.currentLevel based on score (for level progression)
    const scoreBasedLevel = LevelSystem.levels.slice().reverse().find(l => world.score >= l.unlockScore) || LevelSystem.levels[0];
    if (scoreBasedLevel.id !== world.currentLevel) {
      const oldLevel = world.currentLevel;
      world.currentLevel = scoreBasedLevel.id;
      LevelSystem.currentLevel = scoreBasedLevel.id;
      LevelSystem.save();
      // Reset time in level when level changes
      world.timeInCurrentLevel = 0;
      world.previousLevel = oldLevel;
      // Show level change notification
      if (scoreBasedLevel.id > oldLevel) {
        showStickinessNotification(`üéØ LEVEL ${scoreBasedLevel.id}: ${scoreBasedLevel.name}`, 'info');
        // Play level-up sound (war horn fanfare)
        try {
          if (!AC) AC = new (window.AudioContext || window.webkitAudioContext)();
          const now = AC.currentTime;
          const fanfareNotes = [196, 247, 294, 349, 440]; // G3, B3, D4, F4, A4 - viking horn progression
          fanfareNotes.forEach((freq, i) => {
            try {
              const osc = AC.createOscillator();
              const gain = AC.createGain();
              osc.type = 'sawtooth'; // Warmer, more horn-like
              osc.frequency.setValueAtTime(freq, now + i * 0.1);
              // Add vibrato for horn effect
              const vibrato = AC.createOscillator();
              const vibGain = AC.createGain();
              vibrato.frequency.value = 5;
              vibGain.gain.value = 3;
              vibrato.connect(vibGain);
              vibGain.connect(osc.frequency);
              vibrato.start(now);
              vibrato.stop(now + 1);
              gain.gain.setValueAtTime(0, now + i * 0.1);
              gain.gain.linearRampToValueAtTime(0.3, now + i * 0.1 + 0.05);
              gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.4);
              osc.connect(gain);
              gain.connect(AC.destination);
              osc.start(now + i * 0.1);
              osc.stop(now + i * 0.1 + 0.5);
            } catch (e) {
              console.warn("Error creating fanfare note:", e);
            }
          });
        } catch (e) {
          console.warn("Error playing level-up sound:", e);
        }
      }
    }
    
    // Check for boss spawn - multiple times per level
    const theme = LevelThemes.getCurrent();
    if (theme.boss) {
      const bossKey = theme.boss;
      const hasBoss = Bosses.some(b => b.active && !b.defeated);
      
      if (!hasBoss) {
        // Get current level info
        const currentLevel = LevelSystem.levels.slice().reverse().find(l => world.score >= l.unlockScore) || LevelSystem.levels[0];
        const nextLevel = LevelSystem.levels.find(l => l.unlockScore > world.score);
        const levelStart = currentLevel.unlockScore;
        const levelEnd = nextLevel ? nextLevel.unlockScore : Infinity;
        const levelRange = levelEnd - levelStart;
        
        // Update time in current level
        if (!world.timeInCurrentLevel) world.timeInCurrentLevel = 0;
        world.timeInCurrentLevel += dt;
        
        // Calculate spawns per level based on level number
        // Level 1-3: 1 boss each, Level 4: 2, Level 5: 3, Level 6: 4, Level 7: 5, Level 8: 6
        const spawnsPerLevel = currentLevel.id <= 3 ? 1 : currentLevel.id - 2;
        // Apply event multiplier to boss spawn frequency
        const bossSpawnMultiplier = EventSystem.getBossSpawnMultiplier();
        const spawnInterval = (levelRange / (spawnsPerLevel + 1)) / bossSpawnMultiplier;
        
        // Check each spawn point
        for (let i = 1; i <= spawnsPerLevel; i++) {
          const spawnScore = levelStart + (spawnInterval * i);
          const spawnKey = `${currentLevel.id}_${i}`;
          
          // Only spawn if we haven't spawned this boss at this point yet
          if (!world.bossSpawnsThisLevel[spawnKey]) {
            // Spawn when score reaches or exceeds spawn point (much wider window for reliability)
            // Level 1-2 need very wide window since score starts at 0, others can be wider too
            // For Level 1, spawn boss much earlier (at lower score threshold)
            let windowSize;
            let spawnThreshold;
            if (currentLevel.id === 1) {
              // Level 1: Spawn boss at score 2000-6000 (very wide window) OR after 30 seconds
              spawnThreshold = 2000;
              windowSize = 4000;
            } else if (currentLevel.id === 2) {
              windowSize = 3000;
              spawnThreshold = spawnScore - windowSize;
            } else if (currentLevel.id <= 4) {
              windowSize = 2000;
              spawnThreshold = spawnScore - windowSize;
            } else {
              windowSize = 1500;
              spawnThreshold = spawnScore - windowSize;
            }
            
            // Spawn boss if score threshold reached OR time-based (guarantee spawn within 30 seconds)
            const timeBasedSpawn = world.timeInCurrentLevel >= 30 && i === 1; // First boss guaranteed after 30s
            const scoreBasedSpawn = world.score >= spawnThreshold;
            
            if (timeBasedSpawn || scoreBasedSpawn) {
              const bossData = BossData[bossKey];
              if (bossData) {
                console.log(`Spawning boss: ${bossData.name} at score ${world.score}, time: ${world.timeInCurrentLevel.toFixed(1)}s, level: ${currentLevel.id}`);
                // Only show notification if no active boss exists
                if (!hasBoss) {
                  showStickinessNotification(`üëπ BOSS APPROACHING: ${bossData.name}`, 'danger');
                }
                playSFX('powerup');
                spawnBoss(bossKey);
                world.bossSpawnsThisLevel[spawnKey] = true;
                break; // Only spawn one boss at a time
              } else {
                console.warn(`Boss data not found for key: ${bossKey}, level: ${currentLevel.id}`);
              }
            }
          }
        }
      }
    }
    
    // Save level best score
    if (world.score > 0) {
      LevelSystem.saveBestScore(world.currentLevel, world.score);
    }
    
    // Milestone check - show notification
    if (world.score >= engagement.milestones.nextAt) {
      engagement.milestones.last = engagement.milestones.nextAt;
      engagement.milestones.nextAt += 10000;
      world.score += 500;
      world.powerups.invincibility.active = true;
      world.powerups.invincibility.timeLeft = 2;
      playSFX('powerup');
      showStickinessNotification(`üèÜ MILESTONE: ${engagement.milestones.last.toLocaleString()} Points!`, 'info');
      const flash = document.createElement('div');
      flash.className = 'milestone-flash';
      shell.appendChild(flash);
      setTimeout(() => flash.remove(), 800);
    }
    
    // Personal best approaching - multiple notification stages for max addiction
    const pbAlert = $("pbAlert");
    if (pbAlert) {
      if (!engagement.notifiedApproaching && engagement.personalBest > 0) {
        if (world.score >= engagement.personalBest * 0.9 && world.score < engagement.personalBest) {
          engagement.notifiedApproaching = true;
          pbAlert.textContent = 'üî• NEW RECORD INCOMING!';
          pbAlert.style.display = 'block';
          pbAlert.style.animation = 'pulse 0.5s infinite';
        }
      }
      if (world.score > engagement.personalBest && engagement.personalBest > 0 && !engagement.newRecordShown) {
        engagement.newRecordShown = true;
        pbAlert.textContent = 'üèÜ NEW PERSONAL BEST!';
        pbAlert.style.display = 'block';
        pbAlert.style.background = 'linear-gradient(135deg, #ffd700, #ff6b00)';
        pbAlert.style.animation = 'combo-legendary 0.3s infinite';
        engagement.personalBest = Math.floor(world.score);
        localStorage.setItem('personalBest', engagement.personalBest.toString());
        // Auto-dismiss after 3 seconds
        setTimeout(() => {
          if (pbAlert) pbAlert.style.display = 'none';
        }, 3000);
      }
    }
    
    // Achievement check
    Achievements.check();
    
    for (const key in world.powerups) {
      const p = world.powerups[key];
      if (p.active) {
        p.timeLeft -= dt;
        if (p.timeLeft <= 0) {
          p.active = false;
          if (key === "scoreMultiplier") p.multiplier = 1;
          stopPowerupSound(key); // Stop looping sound when powerup expires
          updateHUD();
        }
      } else {
        // Make sure sound is stopped if powerup is not active
        if (powerupSounds[key]) {
          stopPowerupSound(key);
        }
      }
    }

    // Jump logic
    if (Input.jumpJustPressed && !viking.ducking && viking.jumpsUsed < viking.maxJumps) {
      viking.vy = -680;
      viking.onGround = false;
      viking.jumpsUsed++;
      Achievements.sessionStats.jumps++;
      playSFX('jump');
      Input.jumpJustPressed = false;
    }
    
    viking.vy += 1600 * dt;
    viking.y += viking.vy * dt;

    const onPlatform = checkPlatformCollision(dt);
    
    // Ground collision only if not on platform
    if (!onPlatform) {
    if (viking.y >= world.groundY) {
      viking.y = world.groundY;
      viking.vy = 0;
      viking.onGround = true;
        viking.jumpsUsed = 0;
      } else {
        viking.onGround = false;
      }
    }

    // Ducking works in air or on ground
    const wasDucking = viking.ducking;
    viking.ducking = Input.duck;
    if (!wasDucking && viking.ducking) {
      Achievements.sessionStats.ducks++;
    }

    // Spawn logic - Reduced difficulty
    if (viking.x > world.nextObstacleAt - W) {
      spawnObstacle(world.nextObstacleAt);
      // Obstacle density - even more forgiving, fewer obstacles
      const baseMin = 800, baseMax = 1200; // Further increased spacing
      const scoreFactor = Math.min(world.score / 100000, 1.0); // Even slower scaling
      const minSpawn = baseMin - (baseMin * 0.2 * scoreFactor); // Less aggressive
      const maxSpawn = baseMax - (baseMax * 0.2 * scoreFactor);
      world.nextObstacleAt += rand(Math.max(600, minSpawn), Math.max(800, maxSpawn)); // More spacing
    }
    // Spawn duck obstacles (flying obstacles that require ducking) - Reduced frequency
    if (viking.x > world.nextDuckObstacleAt - W) {
      if (Math.random() < 0.5) { // 50% chance to spawn duck obstacle (reduced from 70%)
        spawnDuckObstacle(world.nextDuckObstacleAt);
      }
      world.nextDuckObstacleAt += rand(500, 900); // Less frequent spawns (was 300-600)
    }
    if (viking.x > world.nextMeadAt - W) {
      spawnMead(world.nextMeadAt);
      world.nextMeadAt += rand(400, 600);
    }
    if (viking.x > world.nextPowerupAt - W) {
      spawnPowerup(world.nextPowerupAt);
      // Powerup frequency scales by level - fewer in early levels, more in later levels
      const currentLevel = world.currentLevel || 1;
      let minDelay, maxDelay;
      if (currentLevel === 1) {
        minDelay = 8000; maxDelay = 12000; // Very few powerups
      } else if (currentLevel === 2) {
        minDelay = 6000; maxDelay = 10000; // Few powerups
      } else if (currentLevel === 3) {
        minDelay = 5000; maxDelay = 8000; // Moderate powerups
      } else if (currentLevel === 4) {
        minDelay = 4000; maxDelay = 7000; // More powerups
      } else if (currentLevel === 5) {
        minDelay = 3000; maxDelay = 6000; // Many powerups
      } else {
        minDelay = 2000; maxDelay = 5000; // Very frequent powerups (level 6+)
      }
      // Apply event multiplier to powerup frequency
      const eventPowerupMultiplier = EventSystem.getPowerupFrequencyMultiplier();
      const prestigePowerupMultiplier = PrestigeSystem.getPowerupFrequencyBonus();
      minDelay = Math.floor(minDelay * eventPowerupMultiplier * prestigePowerupMultiplier);
      maxDelay = Math.floor(maxDelay * eventPowerupMultiplier * prestigePowerupMultiplier);
      world.nextPowerupAt += rand(minDelay, maxDelay);
    }
    // Platforms disabled - removed completely
    // if (viking.x > world.nextPlatformAt - W) {
    //   spawnPlatform(world.nextPlatformAt);
    //   world.nextPlatformAt += rand(350, 600);
    // }
    if (viking.x > world.nextEnemyAt - W) {
      spawnEnemy(world.nextEnemyAt);
      // Use difficulty settings directly for spawn rates
      const diff = DifficultyModes.getCurrent();
      // Score-based scaling: enemies spawn slightly more frequently as score increases
      const scoreFactor = Math.min(world.score / 200000, 0.5); // Max 50% increase in frequency
      const minSpawn = diff.enemySpawnMin * (1.0 - scoreFactor * 0.3); // Slightly more frequent at high scores
      const maxSpawn = diff.enemySpawnMax * (1.0 - scoreFactor * 0.3);
      // Ensure minimum spacing for playability
      world.nextEnemyAt += rand(Math.max(diff.enemySpawnMin * 0.5, minSpawn), Math.max(diff.enemySpawnMax * 0.5, maxSpawn));
    }
    // Spawn bird enemies - level-specific
    if (viking.x > world.nextBirdAt - W) {
      spawnBirdEnemy(world.nextBirdAt);
      // Birds spawn less frequently than ground enemies, more in higher levels
      const birdSpawnRate = 1500 + (world.currentLevel * 200);
      world.nextBirdAt += rand(birdSpawnRate, birdSpawnRate + 500);
    }
    if (viking.x > world.nextHeartAt - W) {
      if (world.lives < 5) { // Only spawn hearts if lives < 5
        spawnHeart(world.nextHeartAt);
      }
      world.nextHeartAt += rand(1400, 2400);
    }
    if (viking.x > world.nextGoldAt - W) {
      spawnGold(world.nextGoldAt);
      // Also spawn rune stones occasionally
      Collectibles.spawnRuneStone(world.nextGoldAt + rand(100, 300), world.groundY - rand(60, 200), world.currentLevel);
      // Apply event multiplier to gold spawn frequency (if goldenRush event is active)
      const goldSpawnDelay = EventSystem.isActive() && EventSystem.currentEvent?.type === 'goldenRush' 
        ? rand(1000, 2000) // More frequent during golden rush
        : rand(2000, 4000); // Normal rare gold spawns
      world.nextGoldAt += goldSpawnDelay;
    }
    
    // Update all objects
    for (const o of Obstacles) o.x -= world.speed * dt;
    // Update duck obstacles (flying obstacles)
    for (const duckObst of DuckObstacles) {
      if (!duckObst.hit) {
        duckObst.x += duckObst.vx * dt;
        // Remove if off screen
        if (duckObst.x < viking.x - W - 200) duckObst.hit = true;
      }
    }
    // Platforms disabled - no movement
    // for (const p of Platforms) p.x -= world.speed * dt;
    
    for (const e of Enemies) {
      if (!e.defeated) {
        // Enemy speed scales with world speed, difficulty, and enemy type speed
        const diff = DifficultyModes.getCurrent();
        const scoreSpeedBoost = 1.0 + (world.score / 100000) * 0.3;
        const prestigeReduction = PrestigeSystem.getEnemySpeedReduction();
        const enemySpeed = (e.speed || 1.0) * diff.enemySpeedMultiplier * scoreSpeedBoost * prestigeReduction;
        e.x -= world.speed * enemySpeed * dt;
        // Birds can move slightly faster and have slight vertical movement
        if (e.isBird) {
          e.y += Math.sin(world.t * 5 + e.x * 0.01) * 0.5; // Slight vertical bob
        }
        if (e.x < viking.x - W - 200) e.defeated = true;
      }
    }
    
    
    for (const h of Hearts) {
      if (!h.taken) {
        h.rotation += dt * 2;
        h.pulse = Math.sin(world.t * 8) * 0.2 + 1;
        h.x -= world.speed * dt;
      }
    }
    
    for (const g of Golds) {
      if (!g.taken) {
        g.rotation += dt * 3;
        g.x -= world.speed * dt;
      }
    }
    
    // Update bosses - bosses stay until killed, never removed automatically
    for (const boss of Bosses) {
      if (boss.active && !boss.defeated) {
        // Dynamic movement patterns based on phase
        const phase = boss.phase || 1;
        const moveSpeed = boss.speed || 1.0;
        const phaseMultiplier = phase === 3 ? 1.5 : phase === 2 ? 1.2 : 1.0;
        
        // Horizontal movement - charge toward player, then back off
        const targetX = viking.x + 150; // Keep boss in front of player
        const distToTarget = boss.x - targetX;
        
        if (Math.abs(distToTarget) > 20) {
          // Move toward target position
          boss.x -= Math.sign(distToTarget) * world.speed * moveSpeed * phaseMultiplier * dt * 0.8;
        } else {
          // Add side-to-side movement when close
          boss.x += Math.sin(world.t * 2 + boss.x * 0.01) * 30 * phaseMultiplier * dt;
        }
        
        // Vertical movement - bobbing and jumping
        const baseY = world.groundY;
        const verticalOffset = Math.sin(world.t * 3 + boss.x * 0.01) * 15 * phaseMultiplier;
        const jumpOffset = phase === 3 ? Math.sin(world.t * 4) * 30 : 0; // Jump in final phase
        boss.y = baseY + verticalOffset + jumpOffset;
        
        // Keep boss on screen
        if (boss.x < viking.x - 100) boss.x = viking.x - 100;
        if (boss.x > viking.x + W + 50) boss.x = viking.x + W + 50;
        
        // Boss attacks
        const now = Date.now();
        if (boss.attacks && boss.attacks.length > 0) {
          if (now - boss.lastAttack > boss.attacks[boss.attackIndex % boss.attacks.length].cooldown) {
            boss.lastAttack = now;
            boss.attackIndex++;
            // Attack logic would go here (spawn projectiles, etc.)
          }
        }
        // Check phase changes
        const healthPercent = boss.currentHealth / boss.maxHealth;
        if (healthPercent <= 0.5 && boss.phase === 1) {
          boss.phase = 2; // Enraged
        } else if (healthPercent <= 0.25 && boss.phase === 2) {
          boss.phase = 3; // Final phase
        }
      }
    }
    
    for (const p of Powerups) {
      if (!p.taken) {
        p.rotation += dt * 4;
        p.pulse = Math.sin(world.t * 10) * 0.25 + 1;
        p.x -= world.speed * dt;
      }
    }
    
    for (const m of Meads) {
      if (!m.taken) {
        // Track mead collection for weekly challenges
        WeeklyChallenges.updateProgress('meadCollect', 1);
        m.rotation += dt * 2;
        m.x -= world.speed * dt;
      }
    }
    
    for (let i = Particles.length - 1; i >= 0; i--) {
      const p = Particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 350 * dt;
      p.life -= dt * 2.5;
      if (p.life <= 0) Particles.splice(i, 1);
    }

    // Collisions - Obstacles
    for (const o of Obstacles) {
      // Near-miss detection
      if (!o.nearMissTriggered && !o.hit) {
        const distX = Math.abs(viking.x - o.x);
        const distY = viking.y - (world.groundY - 45);
        const justPassed = viking.x > o.x + 25 && viking.x < o.x + 50;
        const wasDucking = viking.ducking && distX < 40;
        const wasJumping = viking.y < world.groundY - 50 && distX < 40;
        
        if (justPassed && !wasDucking && !wasJumping && distY < 20 && distY > -20) {
          o.nearMissTriggered = true;
          engagement.nearMiss.count++;
          Achievements.sessionStats.nearMisses++;
          Achievements.totalStats.nearMisses++;
          localStorage.setItem('totalNearMisses', Achievements.totalStats.nearMisses.toString());
          world.score += 25;
          
          const nearMissEl = document.createElement('div');
          nearMissEl.className = 'near-miss';
          nearMissEl.textContent = 'CLOSE CALL! +25';
          nearMissEl.style.left = (o.x - world.camX) + 'px';
          nearMissEl.style.top = (world.groundY - 80) + 'px';
          shell.appendChild(nearMissEl);
          setTimeout(() => nearMissEl.remove(), 1000);
        }
      }
      
      if (!o.hit && viking.x > o.x - 25 && viking.x < o.x + 25 && viking.y > world.groundY - 45 && !viking.ducking) {
        if (world.powerups.vikingShip.active) {
          o.hit = true;
          addParticle(o.x, world.groundY - 20, "#8B4513", 20);
          addParticle(o.x, world.groundY - 30, "#4A90D9", 15);
          playSFX('shipDestroy');
          world.score += 100; // Bonus for destroying
        } else if (!world.powerups.invincibility.active) {
          o.hit = true;
          world.lives--;
          addParticle(o.x, world.groundY - 20, "#ef4444", 15);
          playSFX('damage');
          updateHUD();
          
            if (world.lives <= 0) {
              // Check for respawn powerup
              if (activateRespawn()) {
                world.over = false;
                viking.faceplant = 0;
                viking.vy = 0;
                viking.y = world.groundY;
                viking.onGround = true;
                if (statePill) statePill.textContent = "Playing";
              } else {
              // Stop all powerup sounds on game over
              for (const key in powerupSounds) {
                stopPowerupSound(key);
              }
        world.over = true;
        viking.faceplant = 1.5;
              statePill.textContent = "Game Over";
              engagement.sessionDeaths++;
              if (world.score > engagement.personalBest) {
                engagement.personalBest = Math.floor(world.score);
                localStorage.setItem('personalBest', engagement.personalBest.toString());
              }
              HighScoreManager.saveScore(world.score);
              playSFX('gameover');
              setTimeout(() => { 
                if (overlay) {
                  overlay.style.display = "grid";
                  overlay.style.visibility = "visible";
                  overlay.style.opacity = "1";
                }
                const overlayTitle = $("overlayTitle");
                const overlayText = $("overlayText");
                if (overlayTitle) overlayTitle.textContent = "Game Over";
                if (overlayText) overlayText.textContent = `Final Score: ${Math.floor(world.score).toLocaleString()}\nMead Collected: ${world.mead}`;
                if (startBtn) startBtn.textContent = "Play Again";
              }, 1200);
            }
          } else {
            world.powerups.invincibility.active = true;
            world.powerups.invincibility.timeLeft = 2;
          }
        } else {
          addParticle(o.x, world.groundY - 20, "#4ECDC4", 12);
          // Viking drum beat sound
          if (OPT.sound) {
            if (!AC) AC = new (window.AudioContext || window.webkitAudioContext)();
            const now = AC.currentTime;
            const drum = AC.createBufferSource();
            drum.buffer = createNoiseBuffer(0.1);
            const drumFilter = AC.createBiquadFilter();
            drumFilter.type = 'lowpass';
            drumFilter.frequency.value = 200; // Low, bassy drum
            drumFilter.Q.value = 2;
            const drumGain = AC.createGain();
            drumGain.gain.setValueAtTime(0.3, now);
            drumGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            drum.connect(drumFilter);
            drumFilter.connect(drumGain);
            drumGain.connect(AC.destination);
            drum.start(now);
          }
        }
      }
    }
    
    // Collisions - Duck Obstacles (flying obstacles that require ducking)
    for (const duckObst of DuckObstacles) {
      if (!duckObst.hit) {
        // Collision detection
        const distX = Math.abs(viking.x - duckObst.x);
        const distY = Math.abs((viking.y - 30) - duckObst.y); // Head height
        if (distX < (duckObst.w/2 + 20) && distY < (duckObst.h/2 + 15) && !viking.ducking) {
          if (world.powerups.vikingShip.active) {
            duckObst.hit = true;
            addParticle(duckObst.x, duckObst.y, "#4A90D9", 15);
            playSFX('shipDestroy');
            world.score += 100;
          } else if (!world.powerups.invincibility.active) {
            duckObst.hit = true;
            world.lives--;
            addParticle(duckObst.x, duckObst.y, "#ef4444", 15);
            playSFX('damage');
            updateHUD();
            
            if (world.lives <= 0) {
              // Check for respawn powerup
              if (world.powerups.respawn.active) {
                activateRespawn();
              } else {
                for (const key in powerupSounds) {
                  stopPowerupSound(key);
                }
                world.over = true;
                viking.faceplant = 1.5;
                statePill.textContent = "Game Over";
                engagement.sessionDeaths++;
                if (world.score > engagement.personalBest) {
                  engagement.personalBest = Math.floor(world.score);
                  localStorage.setItem('personalBest', engagement.personalBest.toString());
                }
                HighScoreManager.saveScore(world.score);
                
                // Update level mastery
                LevelMastery.checkLevel(world.currentLevel, world.score, engagement.sessionDeaths);
                
                // Update weekly challenges
                const diff = DifficultyModes.getCurrent();
                if (diff.name.toLowerCase() === 'extreme') {
                  WeeklyChallenges.updateProgress('extremeScore', 0, world.score);
                }
                if (engagement.sessionDeaths === 0 && world.score >= 100000) {
                  WeeklyChallenges.updateProgress('perfectRun', 0, world.score);
                }
                
                // Stop gameplay music and resume menu music
                stopVikingMusic();
                if (!menuMusicMuted && !menuMusicPlaying) {
                  setTimeout(() => {
                    startMenuMusic();
                  }, 1000);
                }
                
                playSFX('gameover');
                setTimeout(() => { 
                  if (overlay) {
                    overlay.style.display = "grid";
                    overlay.style.visibility = "visible";
                    overlay.style.opacity = "1";
                    const overlayTitle = $("overlayTitle");
                    const overlayText = $("overlayText");
                    if (overlayTitle) overlayTitle.textContent = "Game Over";
                    if (overlayText) overlayText.textContent = `Final Score: ${Math.floor(world.score).toLocaleString()}\nMead Collected: ${world.mead}`;
                    if (startBtn) startBtn.textContent = "Play Again";
                  }
                }, 1200);
              }
            } else {
              world.powerups.invincibility.active = true;
              world.powerups.invincibility.timeLeft = 2;
            }
          } else {
            addParticle(duckObst.x, duckObst.y, "#4ECDC4", 12);
            // Viking drum beat sound
          if (OPT.sound) {
            if (!AC) AC = new (window.AudioContext || window.webkitAudioContext)();
            const now = AC.currentTime;
            const drum = AC.createBufferSource();
            drum.buffer = createNoiseBuffer(0.1);
            const drumFilter = AC.createBiquadFilter();
            drumFilter.type = 'lowpass';
            drumFilter.frequency.value = 200; // Low, bassy drum
            drumFilter.Q.value = 2;
            const drumGain = AC.createGain();
            drumGain.gain.setValueAtTime(0.3, now);
            drumGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            drum.connect(drumFilter);
            drumFilter.connect(drumGain);
            drumGain.connect(AC.destination);
            drum.start(now);
          }
          }
        }
      }
    }

    // Collisions - Enemies - MARIO STYLE: Jump on them to kill!
    for (const e of Enemies) {
      if (!e.defeated) { // Removed !e.hit check - allow stomping even if touched from side
        const distX = Math.abs(viking.x - e.x);
        const vikingHeight = viking.ducking ? 42 : 70;
        const vikingTop = viking.y - vikingHeight;
        const vikingBottom = viking.y;
        const enemyTop = e.y - e.h;
        const enemyBottom = e.y;
        
        // Basic overlap check - are they colliding at all?
        // Ship has wider collision area
        const shipWidth = world.powerups.vikingShip.active ? 90 : 45;
        const horizontalOverlap = distX < shipWidth;
        const verticalOverlap = vikingBottom > enemyTop && vikingTop < enemyBottom;
        
        // Viking ship destroys everything on contact!
        if (world.powerups.vikingShip.active && horizontalOverlap) {
          e.defeated = true;
          e.hit = true;
          world.score += 200;
          Achievements.sessionStats.shipKills++;
          addParticle(e.x, e.y - e.h/2, "#8B4513", 25);
          addParticle(e.x, e.y - e.h/2, "#4A90D9", 15);
          playSFX('shipDestroyEnemy');
          continue;
        }
        
        // For birds, check if viking can duck under or jump over
        if (e.isBird) {
          const birdY = e.y;
          const vikingHeadY = viking.y - (viking.ducking ? 42 : 70);
          const canDuckUnder = birdY < world.groundY - 50 && viking.ducking && vikingBottom > birdY + e.h/2;
          const canJumpOver = birdY < world.groundY - 100 && vikingTop < birdY - e.h/2;
          
          // If can duck under or jump over, no collision
          if (horizontalOverlap && (canDuckUnder || canJumpOver)) {
            continue; // Safe - ducked under or jumped over
          }
          
          // Bird side collision - player takes damage if cannot duck/jump
          if (horizontalOverlap && verticalOverlap && !canDuckUnder && !canJumpOver) {
            if (!world.powerups.invincibility.active) {
              e.hit = true;
              world.lives--;
              addParticle(viking.x, viking.y, "#ef4444", 25);
              playSFX('damage');
              updateHUD();
              
              if (world.lives <= 0) {
                // Check for respawn powerup
                if (!activateRespawn()) {
                  // Stop all powerup sounds on game over
                  for (const key in powerupSounds) {
                    stopPowerupSound(key);
                  }
                  world.over = true;
                  viking.faceplant = 1.5;
                  if (statePill) statePill.textContent = "Game Over";
                  engagement.sessionDeaths++;
                  if (world.score > engagement.personalBest) {
                    engagement.personalBest = Math.floor(world.score);
                    localStorage.setItem('personalBest', engagement.personalBest.toString());
                  }
                  HighScoreManager.saveScore(world.score, localStorage.getItem('playerName') || 'Player');
                  playSFX('gameover');
                  setTimeout(() => { 
                    if (overlay) {
                      overlay.style.display = "grid";
                      overlay.style.visibility = "visible";
                      overlay.style.opacity = "1";
                    }
                    const overlayTitle = $("overlayTitle");
                    const overlayText = $("overlayText");
                    if (overlayTitle) overlayTitle.textContent = "Game Over";
                    if (overlayText) overlayText.textContent = `Hit by a bird!\nFinal Score: ${Math.floor(world.score).toLocaleString()}\nMead Collected: ${world.mead}`;
                    if (startBtn) startBtn.textContent = "Play Again";
                  }, 1200);
                }
              } else {
                world.powerups.invincibility.active = true;
                world.powerups.invincibility.timeLeft = 1.5;
              }
            }
            continue; // Bird collision handled, move to next enemy
          }
        }
        
        // Check if viking is coming from above (stomping) - works for both ground enemies and birds
        const comingFromAbove = viking.vy > 0 && 
                               vikingBottom <= enemyTop + 25 &&
                               vikingBottom >= enemyTop - 15;
        
        if (horizontalOverlap && comingFromAbove) {
          e.defeated = true;
          e.hit = true;
          // Update daily challenge progress
          DailyChallenges.updateProgress('enemyKills', 1);
          viking.vy = -750;
          
          // Combo system - timer scales with score and difficulty
          engagement.combo.count++;
          const diff = DifficultyModes.getCurrent();
          const baseComboTimer = diff.comboTimer;
          const scoreBonus = Math.min(world.score / 50000, 1.0) * 2.0; // Up to +2s at 50k score
          engagement.combo.timer = baseComboTimer + scoreBonus;
          engagement.combo.maxCombo = Math.max(engagement.combo.maxCombo, engagement.combo.count);
          Achievements.sessionStats.stomps++;
          
          // Combo multiplier: exponential scaling for peak addiction
          let comboMult = 1;
          if (engagement.combo.count >= 25) comboMult = 15;
          else if (engagement.combo.count >= 20) comboMult = 10;
          else if (engagement.combo.count >= 15) comboMult = 7;
          else if (engagement.combo.count >= 10) comboMult = 5;
          else if (engagement.combo.count >= 5) comboMult = 3;
          else if (engagement.combo.count >= 3) comboMult = 2;
          
          // Track best streak for achievements
          if (engagement.combo.count > engagement.bestStreak) {
            engagement.bestStreak = engagement.combo.count;
            localStorage.setItem('bestStreak', engagement.bestStreak.toString());
          }
          
          // Base points that scale with score and level (2x per level)
          // Birds give bonus points
          const currentLevel = LevelSystem.levels.slice().reverse().find(l => world.score >= l.unlockScore) || LevelSystem.levels[0];
          const birdBonus = e.isBird ? 25 : 0; // Extra points for killing birds
          // 2x scaling per level: Level 1 = 50, Level 2 = 100, Level 3 = 200, etc.
          const basePoints = (50 * Math.pow(2, currentLevel.id - 1)) + Math.floor(world.score / 1000) + birdBonus;
          
          // Apply combo multiplier on top of base points
          world.score += basePoints * comboMult;
          
          // Show combo display
          if (engagement.combo.count >= 2) {
            const comboEl = $("comboDisplay");
            if (comboEl) {
              comboEl.textContent = `COMBO x${engagement.combo.count}!`;
              comboEl.className = 'combo-display show';
              if (engagement.combo.count >= 25) comboEl.classList.add('x25');
              else if (engagement.combo.count >= 20) comboEl.classList.add('x20');
              else if (engagement.combo.count >= 15) comboEl.classList.add('x15');
              else if (engagement.combo.count >= 10) comboEl.classList.add('x10');
              else if (engagement.combo.count >= 5) comboEl.classList.add('x5');
              else if (engagement.combo.count >= 3) comboEl.classList.add('x3');
              setTimeout(() => comboEl.classList.remove('show'), 800);
            }
            world.screenShake = 0.15;
          }
          
          addParticle(e.x, e.y - e.h/2, "#fbbf24", 20 + engagement.combo.count * 3);
          playSFX('stomp');
          updateHUD();
        } else if (horizontalOverlap && verticalOverlap && !e.isBird) {
          // Side/front collision - YOU TAKE DAMAGE (ground enemies only)
          // Birds handled separately - if you hit a bird from the side, you take damage
          if (!world.powerups.invincibility.active) {
            e.hit = true;
            world.lives--;
            addParticle(viking.x, viking.y, "#ef4444", 25);
            playSFX('damage');
            updateHUD();
              
            if (world.lives <= 0) {
              // Check for respawn powerup
              if (!activateRespawn()) {
                // Stop all powerup sounds on game over
                for (const key in powerupSounds) {
                  stopPowerupSound(key);
                }
                world.over = true;
                viking.faceplant = 1.5;
                if (statePill) statePill.textContent = "Game Over";
                engagement.sessionDeaths++;
                if (world.score > engagement.personalBest) {
                  engagement.personalBest = Math.floor(world.score);
                  localStorage.setItem('personalBest', engagement.personalBest.toString());
                }
                HighScoreManager.saveScore(world.score, localStorage.getItem('playerName') || 'Player');
                playSFX('gameover');
                setTimeout(() => { 
                  if (overlay) {
                    overlay.style.display = "grid";
                    overlay.style.visibility = "visible";
                    overlay.style.opacity = "1";
                  }
                  const overlayTitle = $("overlayTitle");
                  const overlayText = $("overlayText");
                  if (overlayTitle) overlayTitle.textContent = "Game Over";
                  if (overlayText) overlayText.textContent = `You were defeated!\nFinal Score: ${Math.floor(world.score).toLocaleString()}\nMead Collected: ${world.mead}`;
                  if (startBtn) startBtn.textContent = "Play Again";
                }, 1200);
              }
            } else {
              world.powerups.invincibility.active = true;
              world.powerups.invincibility.timeLeft = 1.5;
            }
          } else {
            e.hit = true; // Passed while invincible
          }
        }
      }
    }
    
    // Collisions - Bosses
    for (const boss of Bosses) {
      if (boss.active && !boss.defeated) {
        const distX = Math.abs(viking.x - boss.x);
        const vikingHeight = viking.ducking ? 42 : 70;
        const vikingTop = viking.y - vikingHeight;
        const vikingBottom = viking.y;
        const bossTop = boss.y - boss.size.height;
        const bossBottom = boss.y;
        
        const horizontalOverlap = distX < (boss.size.width/2 + 45);
        const verticalOverlap = vikingBottom > bossTop && vikingTop < bossBottom;
        
        // Viking ship destroys boss instantly
        if (world.powerups.vikingShip.active && horizontalOverlap) {
          boss.defeated = true;
          boss.active = false;
          // Boss points scale with level (2x per level), bonus for ship kill
          const currentLevel = LevelSystem.levels.slice().reverse().find(l => world.score >= l.unlockScore) || LevelSystem.levels[0];
          // 2x scaling per level: Level 1 = 1000, Level 2 = 2000, Level 3 = 4000, etc.
          const bossPoints = 1000 * Math.pow(2, currentLevel.id - 1);
          world.score += bossPoints * 10; // Bonus for ship kill
          addParticle(boss.x, boss.y - boss.size.height/2, "#FFD700", 50);
          playSFX('shipDestroyEnemy');
          // Track weekly challenge: boss kills
          WeeklyChallenges.updateProgress('bossKills', 1);
          continue;
        }
        
        // Jump on boss from above = damage boss
        const comingFromAbove = viking.vy > 0 && 
                               vikingBottom <= bossTop + 30 &&
                               vikingBottom >= bossTop - 10;
        
        if (horizontalOverlap && comingFromAbove) {
          try {
            // Decrement health first, then check
            if (boss.currentHealth !== undefined && boss.currentHealth > 0) {
              boss.currentHealth--;
            }
            
            viking.vy = -400; // Bounce off
            addParticle(boss.x, boss.y - boss.size.height/2, boss.color || "#FFD700", 30);
            playSFX('jump');
            
            // Check if boss is defeated after health decrement
            if (boss.currentHealth !== undefined && boss.currentHealth <= 0) {
              boss.defeated = true;
              boss.active = false;
              
              // Boss points scale with level (2x per level)
              const currentLevel = LevelSystem.levels.slice().reverse().find(l => world.score >= l.unlockScore) || LevelSystem.levels[0];
              // 2x scaling per level: Level 1 = 1000, Level 2 = 2000, Level 3 = 4000, etc.
              const bossPoints = 1000 * Math.pow(2, (currentLevel?.id || 1) - 1);
              world.score += bossPoints;
              
              // Add mead reward if available
              if (boss.rewards && boss.rewards.mead) {
                world.mead += boss.rewards.mead;
              }
              
              addParticle(boss.x, boss.y - boss.size.height/2, "#FFD700", 60);
              playSFX('powerup');
              playVictoryFanfare(); // Victory fanfare when boss defeated
              
              // Unlock boss achievement if boss.level exists
              if (boss.level !== undefined) {
                const bossAchievementKey = `boss${boss.level}`;
                if (Achievements.achievements && Achievements.achievements[bossAchievementKey]) {
                  Achievements.unlock(bossAchievementKey);
                }
              }
              
              // Collect artifact from boss if name exists
              if (boss.level !== undefined && boss.name) {
                const artifactId = `artifact_${boss.level}_${boss.name}`;
                Collectibles.collectArtifact(artifactId);
              }
              
              // Track weekly challenge: boss kills
              WeeklyChallenges.updateProgress('bossKills', 1);
              // Track boss kills for achievements
              if (Achievements.sessionStats) {
                Achievements.sessionStats.bossKills = (Achievements.sessionStats.bossKills || 0) + 1;
                // Check achievements after incrementing
                Achievements.check();
              }
              
              // Show boss defeat notification
              const notification = document.createElement('div');
              notification.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.9);color:#FFD700;padding:20px 40px;border-radius:12px;font-size:24px;font-weight:700;z-index:10000;';
              const rewardScore = (boss.rewards && boss.rewards.score) ? boss.rewards.score : bossPoints;
              notification.textContent = `BOSS DEFEATED! +${rewardScore.toLocaleString()} pts`;
              document.body.appendChild(notification);
              setTimeout(() => notification.remove(), 3000);
            }
          } catch (e) {
            console.error("Error in boss defeat logic:", e);
            // Fallback: just mark boss as defeated
            boss.defeated = true;
            boss.active = false;
          }
        } else if (horizontalOverlap && verticalOverlap && !comingFromAbove) {
          // Side collision = player takes damage (boss takes 2 lives)
          if (!world.powerups.invincibility.active) {
            world.lives -= 2; // Boss takes 2 lives instead of 1
            addParticle(viking.x, viking.y, "#ef4444", 25);
            playSFX('damage');
            updateHUD();
            
            if (world.lives <= 0) {
              // Check for respawn powerup
              if (activateRespawn()) {
                world.over = false;
                viking.faceplant = 0;
                viking.vy = 0;
                viking.y = world.groundY;
                viking.onGround = true;
                if (statePill) statePill.textContent = "Playing";
              } else {
                for (const key in powerupSounds) {
                  stopPowerupSound(key);
                }
                world.over = true;
                viking.faceplant = 1.5;
                if (statePill) statePill.textContent = "Game Over";
                engagement.sessionDeaths++;
                if (world.score > engagement.personalBest) {
                  engagement.personalBest = Math.floor(world.score);
                  localStorage.setItem('personalBest', engagement.personalBest.toString());
                }
                HighScoreManager.saveScore(world.score, localStorage.getItem('playerName') || 'Player');
                playSFX('gameover');
                setTimeout(() => { 
                  if (overlay) {
                    overlay.style.display = "grid";
                    overlay.style.visibility = "visible";
                    overlay.style.opacity = "1";
                  }
                  const overlayTitle = $("overlayTitle");
                  const overlayText = $("overlayText");
                  if (overlayTitle) overlayTitle.textContent = "Game Over";
                  if (overlayText) overlayText.textContent = `You were defeated!\nFinal Score: ${Math.floor(world.score).toLocaleString()}\nMead Collected: ${world.mead}`;
                  if (startBtn) startBtn.textContent = "Play Again";
                }, 1200);
              }
            } else {
              world.powerups.invincibility.active = true;
              world.powerups.invincibility.timeLeft = 1.5;
            }
          }
        }
      }
    }
    
    // Duck warning removed - obstacles are placed so ducking is needed

    // Collisions - Meads
    for (const m of Meads) {
      if (!m.taken && Math.hypot(viking.x - m.x, (viking.y-30) - m.y) < 45) {
        m.taken = true;
        world.mead++;
        Achievements.sessionStats.meadCollected++;
        Achievements.totalStats.mead++;
        localStorage.setItem('totalMead', Achievements.totalStats.mead.toString());
        // Update daily challenge
        DailyChallenges.updateProgress('meadCollect', 1);
        world.score += 75 * scoreMultiplier;
        addParticle(m.x, m.y, "#FFD700", 8);
        playSFX('mead');
        updateHUD();
      }
    }

    
    // Collisions - Powerups
    for (const p of Powerups) {
      if (!p.taken && Math.hypot(viking.x - p.x, (viking.y-30) - p.y) < 40) {
        p.taken = true;
        activatePowerup(p.type, p.value);
        addParticle(p.x, p.y, getPowerupColor(p.type), 15);
        playSFX('powerup');
        Achievements.sessionStats.powerupsCollected++;
      }
    }

    // Collisions - Hearts
    for (const h of Hearts) {
      if (!h.taken && Math.hypot(viking.x - h.x, (viking.y-30) - h.y) < 40) {
        h.taken = true;
        world.lives++; // No max cap - unlimited storage
        addParticle(h.x, h.y, "#ef4444", 20);
        playSFX('heart');
        updateHUD();
      }
    }
    
    // Collisions - Gold
    for (const g of Golds) {
      if (!g.taken && Math.hypot(viking.x - g.x, (viking.y-30) - g.y) < 45) {
        g.taken = true;
        if (g.isRuneStone) {
          // Collect rune stone
          Collectibles.collectRuneStone(g.runeId, g.levelId);
          world.score += 1000; // Bonus for rune stone
          addParticle(g.x, g.y, "#9370DB", 30);
          playSFX('powerup');
        } else {
          const streakBonus = engagement.streakBonus || 1.0;
          world.score += g.value * scoreMultiplier * streakBonus;
          Achievements.sessionStats.gold++;
          Achievements.totalStats.gold++;
          localStorage.setItem('totalGold', Achievements.totalStats.gold.toString());
          addParticle(g.x, g.y, "#ffd700", 25);
          playSFX('gold');
        }
        updateHUD();
      }
    }

    // Update camera to follow Viking - ensure it's always valid
    world.camX = Math.max(0, viking.x - 150);
    updateHUD();
    updateProgressVisualization();
    updatePowerupCountdowns();
    updateLevelMusic();
    
    // Boss music
    try {
      if (Bosses.length > 0 && !bossMusicActive) {
        startBossMusic();
      } else if (Bosses.length === 0 && bossMusicActive) {
        stopBossMusic();
      }
    } catch (e) {
      console.warn("Error in boss music update:", e);
    }
    } catch (e) {
      console.error("Error in update function:", e);
      // Continue game even on error - don't let it get stuck
    }
  };

  const draw = () => {
    ctx.clearRect(0, 0, W, H);
    
    // Screen shake effect
    if (world.screenShake > 0) {
      const shakeX = (Math.random() - 0.5) * world.screenShake * 20;
      const shakeY = (Math.random() - 0.5) * world.screenShake * 20;
      ctx.translate(shakeX, shakeY);
    }
    
    // Apply level theme background - enhanced with multiple gradient stops
    const theme = LevelThemes.getCurrent();
    const bgGradient = ctx.createLinearGradient(0, 0, 0, H);
    if (theme.bgGradient && theme.bgGradient.length > 0) {
      // Support multiple gradient colors for richer visuals
      const numStops = theme.bgGradient.length;
      theme.bgGradient.forEach((color, i) => {
        bgGradient.addColorStop(i / (numStops - 1), color);
      });
    } else {
      // Rainbow gradient for level 8
      const stops = theme.bgGradient.length;
      theme.bgGradient.forEach((color, i) => {
        bgGradient.addColorStop(i / (stops - 1), color);
      });
    }
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, W, H);
    
    // Parallax background layers
    if (theme.parallaxLayers) {
      ctx.save();
      theme.parallaxLayers.forEach((layer, i) => {
        const offsetX = (world.camX * layer.speed) % W;
        ctx.fillStyle = layer.color;
        ctx.globalAlpha = 0.3 - (i * 0.1);
        ctx.fillRect(-offsetX, 0, W, H);
        if (offsetX > 0) ctx.fillRect(W - offsetX, 0, W, H);
      });
      ctx.restore();
    }
    
    ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
    ctx.lineWidth = 2;
    for (let i = 0; i < 5; i++) {
      const y = world.groundY + (H - world.groundY) * (i / 5) + Math.sin(world.t * 2 + i) * 3;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(W, y);
      ctx.stroke();
    }

    // Ground with theme color
    ctx.strokeStyle = theme.groundColor || "rgba(255, 255, 255, 0.15)"; 
    ctx.lineWidth = 3; 
    ctx.beginPath(); 
    ctx.moveTo(0, world.groundY); 
    ctx.lineTo(W, world.groundY); 
    ctx.stroke();
    
    // Draw ground fill
    ctx.fillStyle = theme.groundColor || "#1a1a1a";
    ctx.fillRect(0, world.groundY, W, H - world.groundY);

    // Weather effects based on level theme
    if (theme.weather === 'rain') {
      ctx.save();
      ctx.strokeStyle = "rgba(173, 216, 230, 0.6)";
      ctx.lineWidth = 2;
      for (let i = 0; i < 30; i++) {
        const x = (world.camX * 0.5 + i * 60) % W;
        const y = (world.t * 300 + i * 20) % H;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + 2, y + 10);
        ctx.stroke();
      }
      ctx.restore();
    } else if (theme.weather === 'snow') {
      ctx.save();
      ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
      for (let i = 0; i < 50; i++) {
        const x = (world.camX * 0.3 + i * 40) % W;
        const y = (world.t * 100 + i * 15) % H;
        ctx.beginPath();
        ctx.arc(x, y, 2 + Math.sin(world.t + i) * 1, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    } else if (theme.weather === 'fire') {
      // Removed ball-like particles - keep only subtle glow effect
      ctx.save();
      ctx.globalAlpha = 0.1;
      ctx.fillStyle = "rgba(255, 69, 0, 0.3)";
      ctx.fillRect(0, world.groundY - 30, W, 30);
      ctx.restore();
    } else if (theme.weather === 'lightning') {
      if (Math.random() < 0.01) {
        ctx.save();
        ctx.fillStyle = "rgba(255, 255, 0, 0.5)";
        ctx.fillRect(0, 0, W, H);
        ctx.restore();
      }
    } else if (theme.weather === 'cosmic') {
      // Removed ball-like particles - keep only subtle star-like lines
      ctx.save();
      ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
      ctx.lineWidth = 1;
      for (let i = 0; i < 20; i++) {
        const x = (world.camX * 0.1 + i * 100) % W;
        const y = (i * 50) % H;
        ctx.beginPath();
        ctx.moveTo(x - 5, y);
        ctx.lineTo(x + 5, y);
        ctx.moveTo(x, y - 5);
        ctx.lineTo(x, y + 5);
        ctx.stroke();
      }
      ctx.restore();
    } else if (theme.weather === 'rainbow') {
      // Removed ball-like particles - keep only subtle gradient overlay
      ctx.save();
      ctx.globalAlpha = 0.15;
      const rainbowGradient = ctx.createLinearGradient(0, 0, W, 0);
      rainbowGradient.addColorStop(0, '#FF0000');
      rainbowGradient.addColorStop(0.17, '#FF7F00');
      rainbowGradient.addColorStop(0.33, '#FFFF00');
      rainbowGradient.addColorStop(0.5, '#00FF00');
      rainbowGradient.addColorStop(0.67, '#0000FF');
      rainbowGradient.addColorStop(0.83, '#4B0082');
      rainbowGradient.addColorStop(1, '#9400D3');
      ctx.fillStyle = rainbowGradient;
      ctx.fillRect(0, 0, W, H * 0.3);
      ctx.restore();
    }
    
    // Speed lines effect at high speeds
    if (world.speed > 320 || world.powerups.speedBoost.active) {
      const intensity = world.powerups.speedBoost.active ? 0.4 : (world.speed - 320) / 100;
      ctx.save();
      ctx.strokeStyle = `rgba(255, 255, 255, ${intensity * 0.3})`;
      ctx.lineWidth = 2;
      for (let i = 0; i < 8; i++) {
        const y = 50 + (i * H / 8);
        const offsetX = (world.t * 500 + i * 100) % W;
        ctx.beginPath();
        ctx.moveTo(W - offsetX, y);
        ctx.lineTo(W - offsetX + 60 + Math.random() * 40, y);
        ctx.stroke();
      }
      ctx.restore();
    }

    ctx.save();
    ctx.translate(-world.camX, 0);

    // Platforms disabled - removed completely
    // for (const p of Platforms) {
    //   if (p.x > viking.x - W - 100 && p.x < viking.x + W + 100) {
    //     drawPlatform(p);
    //   }
    // }


    for (const h of Hearts) {
      if (!h.taken && h.x > viking.x - W - 100 && h.x < viking.x + W + 100) {
        drawHeart(h.x, h.y, h.pulse, h.rotation);
      }
    }

    for (const g of Golds) {
      if (!g.taken && g.x > viking.x - W - 100 && g.x < viking.x + W + 100) {
        drawGold(g);
      }
    }

    for (const e of Enemies) {
      if (!e.defeated && e.x > viking.x - W - 100 && e.x < viking.x + W + 100) {
        drawEnemy(e);
      }
    }

    for (const m of Meads) if (!m.taken && m.x > viking.x - W - 100 && m.x < viking.x + W + 100) drawMead(m.x, m.y);
    for (const p of Powerups) if (!p.taken && p.x > viking.x - W - 100 && p.x < viking.x + W + 100) drawPowerup(p.x, p.y, p.type, p.rotation, p.pulse);
    for (const o of Obstacles) {
      if (o.x > viking.x - W - 100 && o.x < viking.x + W + 100) {
      if (o.type === "shield") drawShield(o.x, o.y);
      else drawRock(o.x, o.y);
      }
    }
    
    // Draw duck obstacles (flying obstacles) - Enhanced visibility with glow
    for (const duckObst of DuckObstacles) {
      if (!duckObst.hit && duckObst.x > viking.x - W - 100 && duckObst.x < viking.x + W + 100) {
        ctx.save();
        ctx.translate(duckObst.x, duckObst.y);
        
        // Add warning glow effect for visibility
        const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
        glowGradient.addColorStop(0, 'rgba(255, 200, 0, 0.4)');
        glowGradient.addColorStop(0.5, 'rgba(255, 150, 0, 0.2)');
        glowGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
        ctx.fillStyle = glowGradient;
        ctx.beginPath();
        ctx.arc(0, 0, 30, 0, Math.PI * 2);
        ctx.fill();
        
        // Main obstacle color - brighter for visibility
        ctx.fillStyle = duckObst.type === 'raven' ? '#000000' : 
                       duckObst.type === 'arrow' ? '#8B4513' :
                       duckObst.type === 'branch' ? '#8B4513' :
                       duckObst.type === 'axe' ? '#FFD700' :
                       duckObst.type === 'spear' ? '#C0C0C0' : '#FF4500';
        
        // Add shadow for depth
        ctx.shadowBlur = 10;
        ctx.shadowColor = 'rgba(255, 0, 0, 0.5)';
        
        if (duckObst.type === 'raven') {
          // Draw raven - larger and more visible
          ctx.beginPath();
          ctx.arc(0, 0, 20, 0, Math.PI * 2); // Increased from 15 to 20
          ctx.fill();
          ctx.fillStyle = '#FFD700';
          ctx.beginPath();
          ctx.arc(-6, -4, 4, 0, Math.PI * 2);
          ctx.fill(); // Eye - brighter
        } else if (duckObst.type === 'arrow') {
          // Draw arrow
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(duckObst.w, 0);
          ctx.lineTo(duckObst.w - 5, -3);
          ctx.lineTo(duckObst.w, 0);
          ctx.lineTo(duckObst.w - 5, 3);
          ctx.closePath();
          ctx.fill();
        } else if (duckObst.type === 'branch') {
          // Draw branch
          ctx.fillRect(0, -duckObst.h/2, duckObst.w, duckObst.h);
        } else if (duckObst.type === 'axe') {
          // Draw axe
          ctx.beginPath();
          ctx.arc(0, 0, 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillRect(0, -duckObst.h/2, 3, duckObst.h);
        } else if (duckObst.type === 'spear') {
          // Draw spear
          ctx.fillRect(0, -duckObst.h/2, duckObst.w, 3);
          ctx.beginPath();
          ctx.moveTo(duckObst.w, 0);
          ctx.lineTo(duckObst.w - 5, -3);
          ctx.lineTo(duckObst.w - 5, 3);
          ctx.closePath();
          ctx.fill();
        }
        ctx.shadowBlur = 0; // Reset shadow
        ctx.restore();
      }
    }

    if (world.powerups.invincibility.active) {
      ctx.save();
      ctx.globalAlpha = 0.4 + Math.sin(world.t * 25) * 0.2;
      ctx.strokeStyle = "#4ECDC4";
      ctx.lineWidth = 5;
      ctx.shadowBlur = 20;
      ctx.shadowColor = "#4ECDC4";
      ctx.beginPath();
      ctx.arc(viking.x, viking.y - 30, 45, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
    
    // Viking ship water wake effect
    if (world.powerups.vikingShip.active) {
      ctx.save();
      ctx.globalAlpha = 0.3 + Math.sin(world.t * 10) * 0.1;
      ctx.strokeStyle = "#4A90D9";
      ctx.lineWidth = 3;
      ctx.shadowBlur = 15;
      ctx.shadowColor = "#4A90D9";
      // Draw wake lines behind ship
      ctx.beginPath();
      ctx.moveTo(viking.x - 80, viking.y + 15);
      ctx.quadraticCurveTo(viking.x - 120, viking.y + 25, viking.x - 160, viking.y + 20);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(viking.x - 80, viking.y + 20);
      ctx.quadraticCurveTo(viking.x - 130, viking.y + 35, viking.x - 180, viking.y + 25);
      ctx.stroke();
      ctx.restore();
    }

    // Draw bosses - proper viking/British leader design
    // Bosses stay on screen until killed - draw them if active and not defeated
    for (const boss of Bosses) {
      if (boss.active && !boss.defeated) {
        // Draw boss even if slightly off-screen to ensure visibility
        const drawBoss = boss.x > viking.x - W - 200 && boss.x < viking.x + W + 200;
        if (drawBoss) {
        ctx.save();
        ctx.translate(boss.x, boss.y);
        
        const bossWidth = boss.size.width;
        const bossHeight = boss.size.height;
        const groundOffset = 0; // Boss is at ground level
        
        // Boss body - large British/Saxon leader with armor
        const bodyHeight = bossHeight * 0.65;
        const bodyWidth = bossWidth * 0.75;
        
        // Get boss data for level-specific visuals
        const bossData = BossData[boss.bossKey] || BossData.troll;
        const robeColor = bossData.robeColor || bossData.color || "#8B4513";
        const crownType = bossData.crownType || 'simple';
        
        // Royal robes/tunic - rich colors for nation leader
        ctx.fillStyle = robeColor;
        ctx.beginPath();
        ctx.moveTo(-bodyWidth/2, groundOffset);
        ctx.lineTo(-bodyWidth/2 + 8, -bodyHeight * 0.2);
        ctx.lineTo(bodyWidth/2 - 8, -bodyHeight * 0.2);
        ctx.lineTo(bodyWidth/2, groundOffset);
        ctx.lineTo(bodyWidth/2 - 12, -bodyHeight * 0.4);
        ctx.lineTo(-bodyWidth/2 + 12, -bodyHeight * 0.4);
        ctx.closePath();
        ctx.fill();
        
        // Strong black outline
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 4;
        ctx.stroke();
        
        // Chainmail/armor overlay - larger for boss
        ctx.fillStyle = "#8b8b9a";
        ctx.fillRect(-bodyWidth/2 + 12, -bodyHeight * 0.35, bodyWidth - 24, bodyHeight * 0.3);
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 3;
        ctx.strokeRect(-bodyWidth/2 + 12, -bodyHeight * 0.35, bodyWidth - 24, bodyHeight * 0.3);
        
        // Royal belt with decorative buckle
        ctx.fillStyle = "#3A2C1A";
        ctx.fillRect(-bodyWidth/2 + 8, -bodyHeight * 0.15, bodyWidth - 16, 10);
        ctx.strokeRect(-bodyWidth/2 + 8, -bodyHeight * 0.15, bodyWidth - 16, 10);
        // Ornate buckle
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(-10, -bodyHeight * 0.15, 20, 10);
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 2;
        ctx.strokeRect(-10, -bodyHeight * 0.15, 20, 10);
        
        // Head - nation leader head
        ctx.fillStyle = "#d4a574";
        ctx.beginPath();
        ctx.arc(0, -bodyHeight - 10, 28, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 4;
        ctx.stroke();
        
        // Royal Crown instead of helmet - level-specific
        ctx.fillStyle = "#FFD700";
        if (crownType === 'simple') {
          // Simple crown - basic band
          ctx.fillRect(-18, -bodyHeight - 40, 36, 12);
          // 3 points
          for (let i = -1; i <= 1; i++) {
            ctx.beginPath();
            ctx.moveTo(i * 12, -bodyHeight - 40);
            ctx.lineTo(i * 12 - 4, -bodyHeight - 50);
            ctx.lineTo(i * 12 + 4, -bodyHeight - 50);
            ctx.closePath();
            ctx.fill();
          }
        } else if (crownType === 'decorative') {
          // Decorative crown - more points
          ctx.fillRect(-20, -bodyHeight - 42, 40, 14);
          for (let i = -2; i <= 2; i++) {
            ctx.beginPath();
            ctx.moveTo(i * 8, -bodyHeight - 42);
            ctx.lineTo(i * 8 - 3, -bodyHeight - 52);
            ctx.lineTo(i * 8 + 3, -bodyHeight - 52);
            ctx.closePath();
            ctx.fill();
          }
        } else if (crownType === 'royal') {
          // Royal crown - ornate with jewels
          ctx.fillRect(-22, -bodyHeight - 44, 44, 16);
          for (let i = -2; i <= 2; i++) {
            ctx.beginPath();
            ctx.moveTo(i * 9, -bodyHeight - 44);
            ctx.lineTo(i * 9 - 4, -bodyHeight - 56);
            ctx.lineTo(i * 9 + 4, -bodyHeight - 56);
            ctx.closePath();
            ctx.fill();
            // Jewel on each point
            ctx.fillStyle = i === 0 ? "#FF0000" : "#00FF00";
            ctx.beginPath();
            ctx.arc(i * 9, -bodyHeight - 50, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#FFD700";
          }
        } else if (crownType === 'ornate') {
          // Ornate crown - very decorative
          ctx.fillRect(-24, -bodyHeight - 46, 48, 18);
          for (let i = -3; i <= 3; i++) {
            ctx.beginPath();
            ctx.moveTo(i * 7, -bodyHeight - 46);
            ctx.lineTo(i * 7 - 5, -bodyHeight - 60);
            ctx.lineTo(i * 7 + 5, -bodyHeight - 60);
            ctx.closePath();
            ctx.fill();
          }
        } else if (crownType === 'imperial') {
          // Imperial crown - most ornate
          ctx.fillRect(-26, -bodyHeight - 48, 52, 20);
          for (let i = -3; i <= 3; i++) {
            ctx.beginPath();
            ctx.moveTo(i * 7, -bodyHeight - 48);
            ctx.lineTo(i * 7 - 6, -bodyHeight - 64);
            ctx.lineTo(i * 7 + 6, -bodyHeight - 64);
            ctx.closePath();
            ctx.fill();
            // Large jewel on center
            if (i === 0) {
              ctx.fillStyle = "#FF0000";
              ctx.beginPath();
              ctx.arc(0, -bodyHeight - 58, 5, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = "#FFD700";
            }
          }
        } else {
          // Divine crown - ultimate
          ctx.fillRect(-28, -bodyHeight - 50, 56, 22);
          for (let i = -4; i <= 4; i++) {
            ctx.beginPath();
            ctx.moveTo(i * 6, -bodyHeight - 50);
            ctx.lineTo(i * 6 - 7, -bodyHeight - 68);
            ctx.lineTo(i * 6 + 7, -bodyHeight - 68);
            ctx.closePath();
            ctx.fill();
          }
        }
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Eyes - normal human eyes (not red/monster)
        ctx.fillStyle = "#1E40AF";
        ctx.fillRect(-12, -bodyHeight - 10, 6, 6);
        ctx.fillRect(6, -bodyHeight - 10, 6, 6);
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 2;
        ctx.strokeRect(-12, -bodyHeight - 10, 6, 6);
        ctx.strokeRect(6, -bodyHeight - 10, 6, 6);
        
        // Beard - regal beard for leader
        ctx.fillStyle = "#2A1C0A";
        ctx.beginPath();
        ctx.moveTo(-16, -bodyHeight + 8);
        ctx.quadraticCurveTo(0, -bodyHeight + 20, 16, -bodyHeight + 8);
        ctx.lineTo(14, -bodyHeight + 4);
        ctx.quadraticCurveTo(0, -bodyHeight + 12, -14, -bodyHeight + 4);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Shield - large boss shield with British/Saxon design
        ctx.fillStyle = "#dc2626";
        ctx.beginPath();
        ctx.arc(-bodyWidth/2 - 15, -bodyHeight * 0.3, 32, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 4;
        ctx.stroke();
        // Shield boss (center metal)
        ctx.fillStyle = "#C0C0C0";
        ctx.beginPath();
        ctx.arc(-bodyWidth/2 - 15, -bodyHeight * 0.3, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        // Cross on shield (British/Saxon design)
        ctx.strokeStyle = "#fbbf24";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(-bodyWidth/2 - 15, -bodyHeight * 0.3 - 20);
        ctx.lineTo(-bodyWidth/2 - 15, -bodyHeight * 0.3 + 20);
        ctx.moveTo(-bodyWidth/2 - 35, -bodyHeight * 0.3);
        ctx.lineTo(-bodyWidth/2 + 5, -bodyHeight * 0.3);
        ctx.stroke();
        
        // Weapon - large boss sword
        ctx.fillStyle = "#78350f";
        ctx.fillRect(bodyWidth/2, -bodyHeight * 0.2, 6, 70);
        ctx.strokeRect(bodyWidth/2, -bodyHeight * 0.2, 6, 70);
        // Sword blade - larger
        ctx.fillStyle = "#C0C0C0";
        ctx.beginPath();
        ctx.moveTo(bodyWidth/2 + 3, -bodyHeight * 0.2);
        ctx.lineTo(bodyWidth/2 + 12, -bodyHeight * 0.2 - 18);
        ctx.lineTo(bodyWidth/2 - 3, -bodyHeight * 0.2 - 18);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Legs - larger
        ctx.fillStyle = "#4A3B1A";
        ctx.fillRect(-bodyWidth/2 + 8, groundOffset, 12, 25);
        ctx.fillRect(bodyWidth/2 - 20, groundOffset, 12, 25);
        ctx.strokeRect(-bodyWidth/2 + 8, groundOffset, 12, 25);
        ctx.strokeRect(bodyWidth/2 - 20, groundOffset, 12, 25);
        
        // Boss glow effect based on phase
        if (boss.phase >= 2) {
          ctx.shadowBlur = 30;
          ctx.shadowColor = boss.phase === 3 ? "#FF0000" : "#FFD700";
          ctx.strokeStyle = boss.phase === 3 ? "#FF0000" : "#FFD700";
          ctx.lineWidth = 5;
          ctx.stroke();
        }
        
        ctx.shadowBlur = 0;
        ctx.restore();
        }
      }
    }
    
    // Draw Viking player character INSIDE the camera transform (before restore)
    // Pass world coordinates - the camera transform will handle screen positioning
    // CRITICAL: Draw Viking here, inside the camera transform block
    if (typeof viking !== 'undefined' && viking.x !== undefined && viking.y !== undefined && !isNaN(viking.x) && !isNaN(viking.y)) {
      // Calculate screen position for debugging
      const screenX = viking.x - world.camX;
      const screenY = viking.y;
      
      // Draw Viking at world coordinates (camera transform handles screen positioning)
    drawViking(viking.x, viking.y);
      
      // Debug rectangle removed - no red stuff around viking
    } else {
      console.error("Viking object or position is invalid!", viking);
    }
    
    ctx.restore();
    
    // Boss health bar - only show if boss is active and not defeated (drawn in screen space, not world space)
    for (const boss of Bosses) {
      if (boss.active && !boss.defeated && boss.currentHealth > 0) {
        const barWidth = 300;
        const barHeight = 20;
        const barX = W / 2 - barWidth / 2;
        const barY = 30;
        const healthPercent = Math.max(0, Math.min(1, boss.currentHealth / boss.maxHealth));
        
        // Background
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(barX - 5, barY - 5, barWidth + 10, barHeight + 10);
        
        // Health bar
        ctx.fillStyle = healthPercent > 0.5 ? "#34C759" : healthPercent > 0.25 ? "#FF9500" : "#FF3B30";
        ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
        
        // Border
        ctx.strokeStyle = "#FFFFFF";
        ctx.lineWidth = 2;
        ctx.strokeRect(barX, barY, barWidth, barHeight);
        
        // Boss name
        ctx.fillStyle = "#FFFFFF";
        ctx.font = "700 18px -apple-system";
        ctx.textAlign = "center";
        ctx.fillText(`${boss.name} - ${Math.ceil(boss.currentHealth)}/${boss.maxHealth}`, W / 2, barY - 10);
      }
    }
    
    // Particles disabled - no abstract balls
    // ctx.save();
    // ctx.translate(-world.camX, 0);
    // for (const p of Particles) drawParticle(p);
    // ctx.restore();
    
    if (world.started && !world.paused && !world.over) {
      let yPos = 100;
      for (const key in world.powerups) {
        const p = world.powerups[key];
        if (p.active) {
          ctx.save();
          ctx.fillStyle = getPowerupColor(key);
          ctx.font = "600 16px -apple-system";
          ctx.textAlign = "left";
          ctx.shadowBlur = 8;
          ctx.shadowColor = getPowerupColor(key);
          ctx.fillText(`${getPowerupSymbol(key)} ${Math.ceil(p.timeLeft)}s`, 24, yPos);
          ctx.restore();
          yPos += 26;
        }
      }
    }
  };

  let last = performance.now();
  const tick = (t) => {
    try {
    const dt = Math.min(0.1, (t - last) / 1000);
    last = t;
    update(dt);
    draw();
    } catch (e) {
      console.error("Error in game loop:", e);
      // Continue game loop even on error
    }
    requestAnimationFrame(tick);
  };

  // Level grid renderer
  const renderLevelGrid = () => {
    const grid = $("levelGrid");
    if (!grid) return;
    grid.innerHTML = '';
    LevelSystem.levels.forEach(level => {
      const card = document.createElement('div');
      const isUnlocked = LevelSystem.unlocked.includes(level.id);
      const isActive = world.currentLevel === level.id;
      card.className = `level-card ${!isUnlocked ? 'locked' : ''} ${isActive ? 'active' : ''}`;
      card.onclick = () => {
        if (isUnlocked) {
          world.currentLevel = level.id;
          LevelSystem.currentLevel = level.id;
          LevelSystem.save();
          // Save selected level to localStorage
          localStorage.setItem('selectedLevel', level.id.toString());
          renderLevelGrid();
        }
      };
      const bestScore = LevelSystem.getBestScore(level.id);
      const diffIcon = level.difficulty === 'easy' ? 'üü¢' : level.difficulty === 'normal' ? 'üîµ' : 'üî¥';
      card.innerHTML = `
        <div class="level-icon">${!isUnlocked ? 'üîí' : diffIcon}</div>
        <div class="level-info">
          <div class="level-name">${level.name}</div>
          <div class="level-score" style="opacity: 0.7;">${!isUnlocked ? `Unlock at ${level.unlockScore.toLocaleString()} pts` : bestScore > 0 ? `Best: ${bestScore.toLocaleString()}` : 'Not played yet'}</div>
        </div>
      `;
      grid.appendChild(card);
    });
  };
  
  // Button handlers will be set up in DOMContentLoaded
  
  // Load player name on startup
  const nameInput = $("playerNameInput");
  if (nameInput) {
    const savedName = localStorage.getItem('playerName');
    if (savedName) {
      nameInput.value = savedName;
    }
  }
  
  // Button handlers moved to DOMContentLoaded block
  const calibrationStatus = $("calibrationStatus");
  const finishCalibrationBtn = $("finishCalibrationBtn");
  const eyeTrackingIndicator = $("eyeTrackingIndicator");
  const gazeCursor = $("gazeCursor");
  const gazeZoneIndicator = $("gazeZoneIndicator");
  
  let eyeTrackingEnabled = false;
  let calibrationClicks = 0;
  let lastGazeAction = 0;
  
  // MediaPipe Face Landmarker (using global mpFaceLandmarker)
  let videoStream = null;
  let animationFrameId = null;
  
  // Gaze calibration thresholds (learned from calibration)
  const gazeCalibration = {
    upThreshold: 0.35,    // Iris position ratio for "looking up"
    downThreshold: 0.65,  // Iris position ratio for "looking down"
    samples: [],          // Calibration samples
    isCalibrating: false
  };
  
  // rPPG Heart Rate Detection
  const rPPG = {
    signalBuffer: [],      // Green channel samples
    timestamps: [],        // Sample timestamps
    bufferSize: 300,       // ~10 seconds at 30fps
    bpm: 0,
    lastBPMUpdate: 0,
    smoothedBPM: 0
  };
  
  // Dynamic MediaPipe Loader with Fallback CDNs - Reinstalled
  let mediapipeAvailable = false;
  
  const loadMediaPipe = async () => {
    // If already loaded, return immediately
    if (typeof window.tasksVision !== 'undefined') {
      mediapipeAvailable = true;
      return true;
    }
    
    // Remove any existing MediaPipe scripts to ensure clean reload
    const existingScripts = document.querySelectorAll('script[src*="mediapipe"], script[src*="tasks-vision"]');
    existingScripts.forEach(script => script.remove());
    
    const sources = [
      'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js',
      'https://unpkg.com/@mediapipe/tasks-vision@latest/vision_bundle.js',
      'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js',
      'https://unpkg.com/@mediapipe/tasks-vision@0.10.0/vision_bundle.js'
    ];
    
    for (const src of sources) {
      try {
        await new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = src;
          // Try as module first, fallback to regular script
          script.type = 'module';
          script.async = true;
          
          // Handle module load errors gracefully
          script.onerror = (error) => {
            // If module fails, try as regular script
            const fallbackScript = document.createElement('script');
            fallbackScript.src = src;
            fallbackScript.type = 'text/javascript';
            fallbackScript.async = true;
            
            fallbackScript.onload = () => {
              let attempts = 0;
              const checkInterval = setInterval(() => {
                attempts++;
                if (typeof window.tasksVision !== 'undefined') {
                  mediapipeAvailable = true;
                  console.log(`MediaPipe loaded successfully from ${src} (fallback)`);
                  clearInterval(checkInterval);
                  resolve(true);
                } else if (attempts >= 20) {
                  clearInterval(checkInterval);
                  reject(new Error('MediaPipe not available after load'));
                }
              }, 100);
            };
            
            fallbackScript.onerror = () => {
              reject(new Error(`Failed to load from ${src}`));
            };
            
            document.head.appendChild(fallbackScript);
          };
          
          script.onload = () => {
            // Wait longer for global to be available
            let attempts = 0;
            const checkInterval = setInterval(() => {
              attempts++;
              if (typeof window.tasksVision !== 'undefined') {
                mediapipeAvailable = true;
                console.log(`MediaPipe loaded successfully from ${src}`);
                clearInterval(checkInterval);
                resolve(true);
              } else if (attempts >= 20) {
                clearInterval(checkInterval);
                reject(new Error('MediaPipe not available after load'));
              }
            }, 100);
          };
          
          document.head.appendChild(script);
        });
        return true;
      } catch (e) {
        // Silently continue to next source - don't log errors that break game
        continue;
      }
    }
    
    // All sources failed - gracefully disable eye tracking without breaking game
    mediapipeAvailable = false;
    return false;
  };
  
  const checkMediaPipeAvailability = () => {
    return new Promise((resolve) => {
      if (typeof window.tasksVision !== 'undefined') {
        mediapipeAvailable = true;
        resolve(true);
        return;
      }
      // Retry up to 10 times (5 seconds total)
      let attempts = 0;
      const interval = setInterval(() => {
        attempts++;
        if (typeof window.tasksVision !== 'undefined') {
          mediapipeAvailable = true;
          clearInterval(interval);
          resolve(true);
        } else if (attempts >= 10) {
          clearInterval(interval);
          resolve(false);
        }
      }, 500);
    });
  };
  
  // Load MediaPipe on page load
  loadMediaPipe().then(loaded => {
    if (!loaded) {
      console.warn("MediaPipe not loaded - eye tracking disabled");
      if (eyeTrackBtn) {
        eyeTrackBtn.textContent = "üëÅÔ∏è Eye Tracking Unavailable";
        eyeTrackBtn.disabled = true;
        eyeTrackBtn.style.opacity = "0.5";
      }
    } else {
      console.log("MediaPipe loaded successfully");
      if (eyeTrackBtn) {
        eyeTrackBtn.textContent = "üëÅÔ∏è Eye Tracking";
        eyeTrackBtn.disabled = false;
        eyeTrackBtn.style.opacity = "1";
      }
    }
  });
  
  // FIXED: Initialization logic with a "Panic Mode"
  // If this fails, it unlocks the screen so buttons work.
  const initFaceLandmarker = async () => {
    if (mpFaceLandmarker) return true;
    
    const overlay = document.getElementById("calibrationOverlay");
    const status = document.getElementById("calibrationStatus");

    try {
      // Ensure MediaPipe is available
      if (typeof window.tasksVision === 'undefined') {
        await loadMediaPipe();
      }
      const { FaceLandmarker, FilesetResolver } = window.tasksVision;
      
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
      );
      
      mpFaceLandmarker = await FaceLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
          delegate: "GPU"
        },
        outputFaceBlendshapes: true,
        runningMode: "VIDEO",
        numFaces: 1
      });
      
      console.log("‚úÖ AI Tracking Ready");
      return true;
    } catch (error) {
      console.error("‚ùå AI Setup Failed. Unlocking buttons for manual play.", error);
      // PANIC MODE: Hide overlay so user can still click buttons
      if (overlay) overlay.classList.remove("active");
      if (status) status.textContent = "AI Tracking failed. Keyboard mode active.";
      return false;
    }
  };
  
  // Start camera - Reinstalled with better error handling
  const startCamera = async () => {
    try {
      // Remove existing video element if present
      if (videoElement && videoElement.parentNode) {
        videoElement.parentNode.removeChild(videoElement);
      }
      if (videoStream) {
        videoStream.getTracks().forEach(track => track.stop());
      }
      
      // Create video element
      videoElement = document.createElement('video');
      videoElement.setAttribute('autoplay', '');
      videoElement.setAttribute('playsinline', '');
      videoElement.setAttribute('muted', '');
      videoElement.style.position = 'fixed';
      videoElement.style.top = '10px';
      videoElement.style.right = '10px';
      videoElement.style.width = '160px';
      videoElement.style.height = '120px';
      videoElement.style.borderRadius = '8px';
      videoElement.style.border = '2px solid #4ade80';
      videoElement.style.zIndex = '9999';
      videoElement.style.transform = 'scaleX(-1)'; // Mirror
      videoElement.style.display = 'block';
      document.body.appendChild(videoElement);
      
      // Request camera access
      videoStream = await navigator.mediaDevices.getUserMedia({
        video: { 
          width: { ideal: 640, min: 320 },
          height: { ideal: 480, min: 240 },
          facingMode: "user"
        }
      });
      
      videoElement.srcObject = videoStream;
      
      // Wait for video to be ready
      await new Promise((resolve, reject) => {
        videoElement.onloadedmetadata = () => {
          videoElement.play().then(() => {
            console.log("Camera started successfully");
            resolve();
          }).catch(reject);
        };
        videoElement.onerror = reject;
        setTimeout(() => reject(new Error("Video metadata timeout")), 5000);
      });
      
      return true;
    } catch (e) {
      console.error("Error starting camera:", e);
      if (videoElement && videoElement.parentNode) {
        videoElement.parentNode.removeChild(videoElement);
      }
      if (videoStream) {
        videoStream.getTracks().forEach(track => track.stop());
      }
      alert("Could not access camera. Please allow camera access and ensure your camera is connected.");
      return false;
    }
  };
  
  // Calculate gaze direction from iris landmarks
  const calculateGaze = (landmarks) => {
    if (!landmarks || landmarks.length < 478) return { vertical: 0.5, horizontal: 0.5 };
    
    // Key landmarks for iris and eye corners
    // Left eye: corners 33 (outer), 133 (inner), iris center 468
    // Right eye: corners 362 (outer), 263 (inner), iris center 473
    
    const leftIris = landmarks[468];
    const leftOuter = landmarks[33];
    const leftInner = landmarks[133];
    const leftTop = landmarks[159];
    const leftBottom = landmarks[145];
    
    const rightIris = landmarks[473];
    const rightOuter = landmarks[362];
    const rightInner = landmarks[263];
    const rightTop = landmarks[386];
    const rightBottom = landmarks[374];
    
    // Calculate horizontal position (0 = left, 1 = right)
    const leftEyeWidth = Math.abs(leftInner.x - leftOuter.x);
    const leftIrisHoriz = (leftIris.x - leftOuter.x) / leftEyeWidth;
    
    const rightEyeWidth = Math.abs(rightInner.x - rightOuter.x);
    const rightIrisHoriz = (rightIris.x - rightOuter.x) / rightEyeWidth;
    
    const horizontal = (leftIrisHoriz + rightIrisHoriz) / 2;
    
    // Calculate vertical position (0 = up, 1 = down)
    const leftEyeHeight = Math.abs(leftBottom.y - leftTop.y);
    const leftIrisVert = (leftIris.y - leftTop.y) / leftEyeHeight;
    
    const rightEyeHeight = Math.abs(rightBottom.y - rightTop.y);
    const rightIrisVert = (rightIris.y - rightTop.y) / rightEyeHeight;
    
    const vertical = (leftIrisVert + rightIrisVert) / 2;
    
    return { vertical: Math.max(0, Math.min(1, vertical)), horizontal: Math.max(0, Math.min(1, horizontal)) };
  };
  
  // Extract forehead ROI for rPPG
  const extractForeheadROI = (landmarks, videoWidth, videoHeight) => {
    if (!landmarks || landmarks.length < 478) return null;
    
    // Forehead landmarks: 10 (center top), 67 (left), 109 (center), 338 (right)
    const forehead = [landmarks[10], landmarks[67], landmarks[109], landmarks[338]];
    
    // Calculate bounding box
    const xs = forehead.map(p => p.x * videoWidth);
    const ys = forehead.map(p => p.y * videoHeight);
    
    return {
      x: Math.min(...xs),
      y: Math.min(...ys),
      width: Math.max(...xs) - Math.min(...xs),
      height: Math.max(...ys) - Math.min(...ys)
    };
  };
  
  // Process rPPG signal and calculate heart rate
  const processRPPG = (greenValue, timestamp) => {
    rPPG.signalBuffer.push(greenValue);
    rPPG.timestamps.push(timestamp);
    
    // Keep buffer at fixed size
    while (rPPG.signalBuffer.length > rPPG.bufferSize) {
      rPPG.signalBuffer.shift();
      rPPG.timestamps.shift();
    }
    
    // Need at least 5 seconds of data
    if (rPPG.signalBuffer.length < 150) return;
    
    // Update BPM every 2 seconds
    if (timestamp - rPPG.lastBPMUpdate < 2000) return;
    rPPG.lastBPMUpdate = timestamp;
    
    // Simple peak detection using zero-crossing of derivative
    const signal = [...rPPG.signalBuffer];
    
    // Detrend (remove DC component)
    const mean = signal.reduce((a, b) => a + b, 0) / signal.length;
    const detrended = signal.map(v => v - mean);
    
    // Simple moving average filter
    const windowSize = 5;
    const filtered = [];
    for (let i = 0; i < detrended.length; i++) {
      let sum = 0;
      let count = 0;
      for (let j = Math.max(0, i - windowSize); j <= Math.min(detrended.length - 1, i + windowSize); j++) {
        sum += detrended[j];
        count++;
      }
      filtered.push(sum / count);
    }
    
    // Count peaks (zero crossings from negative to positive)
    let peaks = 0;
    for (let i = 1; i < filtered.length; i++) {
      if (filtered[i - 1] < 0 && filtered[i] >= 0) {
        peaks++;
      }
    }
    
    // Calculate BPM
    const duration = (rPPG.timestamps[rPPG.timestamps.length - 1] - rPPG.timestamps[0]) / 1000; // seconds
    const rawBPM = (peaks / duration) * 60;
    
    // Clamp to realistic range (40-200 BPM)
    const clampedBPM = Math.max(40, Math.min(200, rawBPM));
    
    // Smooth with exponential moving average
    rPPG.smoothedBPM = rPPG.smoothedBPM === 0 
      ? clampedBPM 
      : rPPG.smoothedBPM * 0.7 + clampedBPM * 0.3;
    
    rPPG.bpm = Math.round(rPPG.smoothedBPM);
    
    // Update BPM display
    const bpmValue = $("bpmValue");
    if (bpmValue) {
      bpmValue.textContent = rPPG.bpm;
    }
  };
  
  // FIXED: Loop logic with a Safety Guard 
  // If mpFaceLandmarker is missing, the game idles instead of crashing.
  const processFrame = () => {
    // If calibration was turned off or AI isn't ready, stop the loop safely
    if (!gazeCalibration.isCalibrating) return;

    if (!mpFaceLandmarker || !videoElement) {
      requestAnimationFrame(processFrame);
      return;
    }

    let startTimeMs = performance.now();
    if (videoElement.currentTime !== lastVideoTime) {
      lastVideoTime = videoElement.currentTime;
      
      // This variable is now globally defined at the top
      const results = mpFaceLandmarker.detectForVideo(videoElement, startTimeMs);
      
      if (results.faceLandmarks && results.faceLandmarks.length > 0) {
        handleGazeAndHeartRate(results.faceLandmarks[0]);
      }
    }
    
    requestAnimationFrame(processFrame);
  };

  // Handle gaze and heart rate from face landmarks
  const handleGazeAndHeartRate = (landmarks) => {
    // Calculate gaze
    const gaze = calculateGaze(landmarks);
      
      // During calibration, collect samples
      if (gazeCalibration.isCalibrating) {
        gazeCalibration.samples.push(gaze.vertical);
      }
      
      // Update gaze cursor position
      if (gazeCursor && eyeTrackingEnabled) {
        const x = gaze.horizontal * window.innerWidth;
        const y = gaze.vertical * window.innerHeight;
        gazeCursor.style.left = x + 'px';
        gazeCursor.style.top = y + 'px';
        gazeCursor.classList.add("active");
      }
      
      // Determine gaze direction
      const isLookingUp = gaze.vertical < gazeCalibration.upThreshold;
      const isLookingDown = gaze.vertical > gazeCalibration.downThreshold;
      
      // Show gaze zone indicator
      if (eyeTrackingEnabled && gazeZoneIndicator) {
        if (isLookingUp) {
          gazeZoneIndicator.style.display = 'block';
          gazeZoneIndicator.style.background = 'rgba(74, 222, 128, 0.9)';
          gazeZoneIndicator.textContent = 'üëÜ JUMP ZONE';
        } else if (isLookingDown) {
          gazeZoneIndicator.style.display = 'block';
          gazeZoneIndicator.style.background = 'rgba(251, 191, 36, 0.9)';
          gazeZoneIndicator.textContent = 'üëá DUCK ZONE';
        } else {
          gazeZoneIndicator.style.display = 'block';
          gazeZoneIndicator.style.background = 'rgba(100, 100, 100, 0.7)';
          gazeZoneIndicator.textContent = 'üëÄ CENTER';
        }
      }
      
      // Control game
      const now = Date.now();
      if (eyeTrackingEnabled && world.started && !world.paused && !world.over) {
        if (isLookingUp && now - lastGazeAction > 200) {
          Input.jumpJustPressed = true;
          Input.jump = true;
          Input.duck = false;
          lastGazeAction = now;
          if (gazeCursor) gazeCursor.style.background = 'rgba(74, 222, 128, 0.8)';
        } else if (isLookingDown) {
          Input.duck = true;
          Input.jump = false;
          Input.jumpJustPressed = false;
          if (gazeCursor) gazeCursor.style.background = 'rgba(251, 191, 36, 0.8)';
        } else {
          Input.duck = false;
          if (now - lastGazeAction > 150) {
            Input.jump = false;
            Input.jumpJustPressed = false;
          }
          if (gazeCursor) gazeCursor.style.background = 'rgba(255, 107, 107, 0.6)';
        }
      }
      
      // rPPG: Extract green channel from forehead
      if (eyeTrackingEnabled) {
        try {
          const roi = extractForeheadROI(landmarks, videoElement.videoWidth, videoElement.videoHeight);
          if (roi && roi.width > 10 && roi.height > 10) {
            // Create canvas to extract pixel data
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = roi.width;
            tempCanvas.height = roi.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(
              videoElement,
              roi.x, roi.y, roi.width, roi.height,
              0, 0, roi.width, roi.height
            );
            
            const imageData = tempCtx.getImageData(0, 0, roi.width, roi.height);
            const pixels = imageData.data;
            
            // Calculate average green channel value
            let greenSum = 0;
            let count = 0;
            for (let i = 1; i < pixels.length; i += 4) {
              greenSum += pixels[i]; // Green channel
              count++;
            }
            const avgGreen = greenSum / count;
            
            processRPPG(avgGreen, startTimeMs);
          }
        } catch (e) {
          // Ignore rPPG errors
        }
      }
  };
  
  // Eye tracking button handler moved to DOMContentLoaded block

  // Daily Bonus System Initialization
  const showDailyBonus = () => {
    const { streak, claimed } = DailyBonus.getStreak();
    if (claimed) return;
    
    const modal = document.getElementById('dailyBonusModal');
    const streakDisplay = document.getElementById('streakDisplay');
    const rewardDisplay = document.getElementById('rewardDisplay');
    const claimBtn = document.getElementById('claimBonusBtn');
    
    if (!modal || !streakDisplay || !rewardDisplay || !claimBtn) return;
    
    const reward = DailyBonus.rewards[(streak - 1) % 7];
    streakDisplay.textContent = `üî• ${streak}`;
    rewardDisplay.textContent = reward.label;
    modal.classList.add('show');
    
    claimBtn.onclick = () => {
      const claimed = DailyBonus.claim();
      if (claimed) {
        playSFX('powerup');
        modal.classList.remove('show');
        
        // Apply reward on next game start
        const applyReward = () => {
          if (claimed.type === 'life') {
            world.lives += claimed.value;
            updateHUD();
          } else if (claimed.type === 'gold') {
            world.score += claimed.value;
            updateHUD();
          } else if (claimed.type === 'powerup') {
            world.powerups[claimed.value].active = true;
            world.powerups[claimed.value].timeLeft = 10;
          } else if (claimed.type === 'mega') {
            world.lives += 3;
            world.score += 2000;
            world.powerups.invincibility.active = true;
            world.powerups.invincibility.timeLeft = 15;
            updateHUD();
          }
        };
        
        // Store for next game
        localStorage.setItem('pendingReward', JSON.stringify(claimed));
      }
    };
  };
  
  // Apply pending reward when game starts
  const applyPendingReward = () => {
    const pending = localStorage.getItem('pendingReward');
    if (pending) {
      const reward = JSON.parse(pending);
      if (reward.type === 'life') {
        world.lives += reward.value;
      } else if (reward.type === 'gold') {
        world.score += reward.value;
      } else if (reward.type === 'powerup') {
        world.powerups[reward.value].active = true;
        world.powerups[reward.value].timeLeft = 10;
      } else if (reward.type === 'mega') {
        world.lives += 3;
        world.score += 2000;
        world.powerups.invincibility.active = true;
        world.powerups.invincibility.timeLeft = 15;
      }
      localStorage.removeItem('pendingReward');
      updateHUD();
    }
  };

  // Initialize after DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      LevelSystem.init();
      LevelSystem.loadExternal();
      DifficultyModes.loadSaved();
      DailyChallenges.init();
      WeeklyChallenges.init();
      EventSystem.init();
      resize();
  resetWorld();
      // Ensure level grid is rendered after initialization
      if (typeof renderLevelGrid === 'function') {
        renderLevelGrid();
      }
      
      // Difficulty selector handlers - must be after DOM is ready
      const difficultyBtns = document.querySelectorAll('.difficulty-btn');
      difficultyBtns.forEach(btn => {
        btn.onclick = () => {
          difficultyBtns.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          const difficulty = btn.dataset.difficulty;
          DifficultyModes.apply(difficulty);
          // Re-render level grid to reflect any difficulty changes
          if (typeof renderLevelGrid === 'function') {
            renderLevelGrid();
          }
        };
      });
      
      // Set initial active state based on saved difficulty
      const savedDifficulty = world.difficulty || 'normal';
      difficultyBtns.forEach(btn => {
        if (btn.dataset.difficulty === savedDifficulty) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
      
      // Set up all button handlers after DOM is ready
      const startBtn = $("startBtn");
      const pauseBtn = $("pauseBtn");
      const restartBtn = $("restartBtn");
      const soundBtn = $("soundBtn");
      const musicBtn = $("musicBtn");
      const highscoreBtn = $("highscoreBtn");
      const highscoreModal = $("highscoreModal");
      const highscoreTabs = document.querySelectorAll(".highscore-tab");
      const closeHighscoreBtn = $("closeHighscoreBtn");
      const shareBtn = $("shareBtn");
      const eyeTrackBtn = $("eyeTrackBtn");
      const eyeTrackingIndicator = $("eyeTrackingIndicator");
      const calibrationOverlay = $("calibrationOverlay");
      const calibrationStatus = $("calibrationStatus");
      const calibrationPoints = document.querySelectorAll(".calibration-point");
      
      if (startBtn) {
        startBtn.onclick = () => {
          try {
            // Save player name
            const nameInput = $("playerNameInput");
            if (nameInput && nameInput.value.trim()) {
              localStorage.setItem('playerName', nameInput.value.trim());
            }
            
            // If game is over, reset and start immediately
            if (world.over) {
              resetWorld();
              setTimeout(() => {
                start();
              }, 100);
            } else {
              start();
            }
          } catch (e) {
            console.error("Error in startBtn click:", e);
            resetWorld();
            setTimeout(() => {
              start();
            }, 100);
          }
        };
      }
      
      if (restartBtn) {
        restartBtn.onclick = () => { 
          resetWorld();
          setTimeout(() => {
            start();
          }, 100);
        };
      }
      
      if (pauseBtn) {
        pauseBtn.onclick = () => { 
          if (!world.started || world.over) return;
          world.paused = !world.paused; 
          pauseBtn.textContent = world.paused ? "Resume" : "Pause";
          const statePill = $("statePill");
          if (statePill) statePill.textContent = world.paused ? "Paused" : "Playing";
          
          // Hide/show gaze zone indicator when paused
          const gazeZoneIndicator = $("gazeZoneIndicator");
          if (gazeZoneIndicator && eyeTrackingEnabled) {
            gazeZoneIndicator.style.display = world.paused ? 'none' : 'block';
          }
        };
      }
      
      // Music button handler
      if (musicBtn) {
        musicBtn.onclick = () => {
          menuMusicMuted = !menuMusicMuted;
          setMenuMusicVolume(menuMusicMuted);
          musicBtn.textContent = menuMusicMuted ? "üîá Music: Off" : "üéµ Music: On";
        };
        // Set initial state
        if (menuMusicMuted) {
          musicBtn.textContent = "üîá Music: Off";
        }
      }
      
      if (soundBtn) {
        soundBtn.onclick = () => { 
          OPT.sound = !OPT.sound; 
          soundBtn.textContent = OPT.sound ? "Sound: On" : "Sound: Off";
          
          // Control Viking music
          if (OPT.sound) {
            if (!musicPlaying) {
              startVikingMusic();
            } else {
              setMusicVolume(false);
            }
          } else {
            setMusicVolume(true);
          }
        };
      }
      
      if (highscoreBtn && highscoreModal) {
        highscoreBtn.onclick = () => {
          highscoreModal.classList.add("active");
          // Display scores for current difficulty
          const currentDifficulty = world.difficulty || 'normal';
          HighScoreManager.displayScores('alltime', currentDifficulty);
        };
      }
      
      if (highscoreTabs && highscoreTabs.length > 0) {
        highscoreTabs.forEach(tab => {
          tab.onclick = () => {
            highscoreTabs.forEach(t => t.classList.remove("active"));
            tab.classList.add("active");
            const period = tab.dataset.period || 'alltime';
            const currentDifficulty = world.difficulty || 'normal';
            HighScoreManager.displayScores(period, currentDifficulty);
          };
        });
      }
      
      if (closeHighscoreBtn && highscoreModal) {
        closeHighscoreBtn.onclick = () => {
          highscoreModal.classList.remove("active");
        };
      }
      
      if (highscoreModal) {
        highscoreModal.onclick = (e) => {
          if (e.target === highscoreModal) {
            highscoreModal.classList.remove("active");
          }
        };
      }
      
      // Social/Sharing Features
      const shareAchievement = () => {
        const score = world.score || engagement.personalBest || 0;
        const level = world.currentLevel || LevelSystem.currentLevel || 1;
        const diff = DifficultyModes.getCurrent();
        const prestige = PrestigeSystem.level;
        const titles = Unlockables.getUnlockedByType('title');
        const titleName = titles.length > 0 ? Unlockables.definitions[titles[titles.length - 1]]?.name : 'Viking Warrior';
        
        const shareText = `‚öîÔ∏è Viking Run Achievement! ‚öîÔ∏è\n\n` +
          `Score: ${Math.floor(score).toLocaleString()}\n` +
          `Level: ${level}\n` +
          `Difficulty: ${diff.name}\n` +
          `Prestige: ${prestige}\n` +
          `Title: ${titleName}\n\n` +
          `Can you beat my score? üèÜ`;
        
        // Try Web Share API first
        if (navigator.share) {
          navigator.share({
            title: 'Viking Run Achievement',
            text: shareText,
            url: window.location.href
          }).catch(() => {
            // Fallback to clipboard
            copyToClipboard(shareText);
          });
        } else {
          // Fallback to clipboard
          copyToClipboard(shareText);
        }
      };
      
      const copyToClipboard = (text) => {
        if (navigator.clipboard) {
          navigator.clipboard.writeText(text).then(() => {
            showStickinessNotification('üìã Copied to clipboard!', 'info');
          }).catch(() => {
            // Fallback for older browsers
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            try {
              document.execCommand('copy');
              showStickinessNotification('üìã Copied to clipboard!', 'info');
            } catch (e) {
              showStickinessNotification('‚ùå Could not copy to clipboard', 'warning');
            }
            document.body.removeChild(textarea);
          });
        }
      };
      
      if (shareBtn) {
        shareBtn.onclick = shareAchievement;
      }
      
      // Eye tracking button - start calibration
      if (eyeTrackBtn) {
        eyeTrackBtn.onclick = async () => {
          // Ensure MediaPipe is loaded
          if (typeof window.tasksVision === 'undefined') {
            const loaded = await loadMediaPipe();
            if (!loaded) {
              alert("Eye tracking is not available. Please ensure you have a stable internet connection and try refreshing the page.");
              return;
            }
          }
          // Show calibration overlay
          if (calibrationOverlay) {
            calibrationOverlay.classList.add("active");
          }
          
          // Reset calibration
          calibrationClicks = 0;
          gazeCalibration.samples = [];
          if (calibrationPoints && calibrationPoints.length > 0) {
            calibrationPoints.forEach(p => {
              p.classList.remove("clicked");
              p.textContent = "";
              p.style.transform = "";
            });
          }
          if (calibrationStatus) {
            calibrationStatus.textContent = "Initializing camera and face tracking...";
          }
          
          // Initialize MediaPipe and camera
          const mpInit = await initFaceLandmarker();
          if (!mpInit) {
            if (calibrationOverlay) {
              calibrationOverlay.classList.remove("active");
            }
            alert("Could not initialize face tracking.");
            return;
          }
          
          const camInit = await startCamera();
          if (!camInit) {
            if (calibrationOverlay) {
              calibrationOverlay.classList.remove("active");
            }
            return;
          }
          
          // Start processing
          gazeCalibration.isCalibrating = true;
          processFrame();
          
          if (calibrationStatus) {
            calibrationStatus.textContent = "Look at each point and click it 5 times (0/9)";
          }
        };
      }
      
  requestAnimationFrame(tick);
      setTimeout(showDailyBonus, 500);
    });
  }
  
  // Handle case when DOM is already loaded
  if (document.readyState !== 'loading') {
    // DOM already loaded - set up everything immediately
    LevelSystem.init();
    LevelSystem.loadExternal();
    DifficultyModes.loadSaved();
    DailyChallenges.init();
    WeeklyChallenges.init();
    EventSystem.init();
    resize();
    resetWorld();
    // Ensure level grid is rendered after initialization
    if (typeof renderLevelGrid === 'function') {
      renderLevelGrid();
    }
    
    // Difficulty selector handlers - must be after DOM is ready
    const difficultyBtns = document.querySelectorAll('.difficulty-btn');
    difficultyBtns.forEach(btn => {
      btn.onclick = () => {
        difficultyBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        const difficulty = btn.dataset.difficulty;
        DifficultyModes.apply(difficulty);
        // Re-render level grid to reflect any difficulty changes
        if (typeof renderLevelGrid === 'function') {
          renderLevelGrid();
        }
      };
    });
    
    // Set initial active state based on saved difficulty
    const savedDifficulty = world.difficulty || 'normal';
    difficultyBtns.forEach(btn => {
      if (btn.dataset.difficulty === savedDifficulty) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });
    
    // Set up all button handlers after DOM is ready
    const startBtn = $("startBtn");
    const pauseBtn = $("pauseBtn");
    const restartBtn = $("restartBtn");
    const soundBtn = $("soundBtn");
    const musicBtn = $("musicBtn");
    const highscoreBtn = $("highscoreBtn");
    const highscoreModal = $("highscoreModal");
    const highscoreTabs = document.querySelectorAll(".highscore-tab");
    const closeHighscoreBtn = $("closeHighscoreBtn");
    const shareBtn = $("shareBtn");
    const eyeTrackBtn = $("eyeTrackBtn");
    const eyeTrackingIndicator = $("eyeTrackingIndicator");
    const calibrationOverlay = $("calibrationOverlay");
    const calibrationStatus = $("calibrationStatus");
    const calibrationPoints = document.querySelectorAll(".calibration-point");
    
    if (startBtn) {
      startBtn.onclick = () => {
        try {
          // Save player name
          const nameInput = $("playerNameInput");
          if (nameInput && nameInput.value.trim()) {
            localStorage.setItem('playerName', nameInput.value.trim());
          }
          
          // If game is over, reset and start immediately
          if (world.over) {
            resetWorld();
            // Start the game immediately after reset
            setTimeout(() => {
              start();
            }, 100);
          } else {
            start();
          }
        } catch (e) {
          console.error("Error in startBtn click:", e);
          resetWorld();
          setTimeout(() => {
            start();
          }, 100);
        }
      };
    }
    
    if (restartBtn) {
      restartBtn.onclick = () => { 
        resetWorld();
        setTimeout(() => {
          start();
        }, 100);
      };
    }
    
    if (pauseBtn) {
      pauseBtn.onclick = () => { 
        if (!world.started || world.over) return;
        world.paused = !world.paused; 
        pauseBtn.textContent = world.paused ? "Resume" : "Pause";
        const statePill = $("statePill");
        if (statePill) statePill.textContent = world.paused ? "Paused" : "Playing";
        
        // Hide/show gaze zone indicator when paused
        const gazeZoneIndicator = $("gazeZoneIndicator");
        if (gazeZoneIndicator && eyeTrackingEnabled) {
          gazeZoneIndicator.style.display = world.paused ? 'none' : 'block';
        }
      };
    }
    
    // Music button handler
    if (musicBtn) {
      musicBtn.onclick = () => {
        menuMusicMuted = !menuMusicMuted;
        setMenuMusicVolume(menuMusicMuted);
        musicBtn.textContent = menuMusicMuted ? "üîá Music: Off" : "üéµ Music: On";
      };
      // Set initial state
      if (menuMusicMuted) {
        musicBtn.textContent = "üîá Music: Off";
      }
    }
    
    if (soundBtn) {
      soundBtn.onclick = () => { 
        OPT.sound = !OPT.sound; 
        soundBtn.textContent = OPT.sound ? "Sound: On" : "Sound: Off";
        
        // Control Viking music
        if (OPT.sound) {
          if (!musicPlaying) {
            startVikingMusic();
          } else {
            setMusicVolume(false);
          }
        } else {
          setMusicVolume(true);
        }
      };
    }
    
    if (highscoreBtn && highscoreModal) {
      highscoreBtn.onclick = () => {
        highscoreModal.classList.add("active");
        // Display scores for current difficulty
        const currentDifficulty = world.difficulty || 'normal';
        HighScoreManager.displayScores('alltime', currentDifficulty);
      };
    }
    
    if (highscoreTabs && highscoreTabs.length > 0) {
      highscoreTabs.forEach(tab => {
        tab.onclick = () => {
          highscoreTabs.forEach(t => t.classList.remove("active"));
          tab.classList.add("active");
          const period = tab.dataset.period || 'alltime';
          const currentDifficulty = world.difficulty || 'normal';
          HighScoreManager.displayScores(period, currentDifficulty);
        };
      });
    }
    
    if (closeHighscoreBtn && highscoreModal) {
      closeHighscoreBtn.onclick = () => {
        highscoreModal.classList.remove("active");
      };
    }
    
    if (highscoreModal) {
      highscoreModal.onclick = (e) => {
        if (e.target === highscoreModal) {
          highscoreModal.classList.remove("active");
        }
      };
    }
    
    // Social/Sharing Features
    const shareAchievement = () => {
      const score = world.score || engagement.personalBest || 0;
      const level = world.currentLevel || LevelSystem.currentLevel || 1;
      const diff = DifficultyModes.getCurrent();
      const prestige = PrestigeSystem.level;
      const titles = Unlockables.getUnlockedByType('title');
      const titleName = titles.length > 0 ? Unlockables.definitions[titles[titles.length - 1]]?.name : 'Viking Warrior';
      
      const shareText = `‚öîÔ∏è Viking Run Achievement! ‚öîÔ∏è\n\n` +
        `Score: ${Math.floor(score).toLocaleString()}\n` +
        `Level: ${level}\n` +
        `Difficulty: ${diff.name}\n` +
        `Prestige: ${prestige}\n` +
        `Title: ${titleName}\n\n` +
        `Can you beat my score? üèÜ`;
      
      // Try Web Share API first
      if (navigator.share) {
        navigator.share({
          title: 'Viking Run Achievement',
          text: shareText,
          url: window.location.href
        }).catch(() => {
          // Fallback to clipboard
          copyToClipboard(shareText);
        });
      } else {
        // Fallback to clipboard
        copyToClipboard(shareText);
      }
    };
    
    const copyToClipboard = (text) => {
      if (navigator.clipboard) {
        navigator.clipboard.writeText(text).then(() => {
          showStickinessNotification('üìã Copied to clipboard!', 'info');
        }).catch(() => {
          // Fallback for older browsers
          const textarea = document.createElement('textarea');
          textarea.value = text;
          textarea.style.position = 'fixed';
          textarea.style.opacity = '0';
          document.body.appendChild(textarea);
          textarea.select();
          try {
            document.execCommand('copy');
            showStickinessNotification('üìã Copied to clipboard!', 'info');
          } catch (e) {
            showStickinessNotification('‚ùå Could not copy to clipboard', 'warning');
          }
          document.body.removeChild(textarea);
        });
      }
    };
    
      if (shareBtn) {
        shareBtn.onclick = shareAchievement;
      }
      
      // Calibration point clicks
      if (calibrationPoints && calibrationPoints.length > 0) {
        calibrationPoints.forEach(point => {
          let clickCount = 0;
          point.onclick = () => {
            clickCount++;
            
            // Need 5 clicks per point
            if (clickCount >= 5 && !point.classList.contains("clicked")) {
              point.classList.add("clicked");
              calibrationClicks++;
              
              if (calibrationStatus) {
                if (calibrationClicks >= 9) {
                  calibrationStatus.textContent = "‚úì Calibration complete! Click the button below to start.";
                  
                  // Calculate thresholds from samples
                  if (gazeCalibration.samples.length > 50) {
                    gazeCalibration.samples.sort((a, b) => a - b);
                    const len = gazeCalibration.samples.length;
                    gazeCalibration.upThreshold = gazeCalibration.samples[Math.floor(len * 0.25)];
                    gazeCalibration.downThreshold = gazeCalibration.samples[Math.floor(len * 0.75)];
                  }
                  gazeCalibration.isCalibrating = false;
                } else {
                  calibrationStatus.textContent = `Look at each point and click it 5 times (${calibrationClicks}/9)`;
                }
              }
            } else if (!point.classList.contains("clicked")) {
              point.style.transform = `scale(${1 + clickCount * 0.1})`;
              point.textContent = `${clickCount}/5`;
            }
          };
        });
      }
      
      // Finish calibration and start game
      if (finishCalibrationBtn) {
        finishCalibrationBtn.onclick = () => {
          if (calibrationClicks < 5) {
            alert("Please click at least 5 calibration points for better accuracy.");
            return;
          }
          
          // Hide calibration overlay
          if (calibrationOverlay) {
            calibrationOverlay.classList.remove("active");
          }
          
          // Enable eye tracking
          eyeTrackingEnabled = true;
          gazeCalibration.isCalibrating = false;
          
          // Show indicators
          if (eyeTrackingIndicator) {
            eyeTrackingIndicator.classList.add("active");
          }
          
          // Show BPM display
          const bpmDisplay = $("bpmDisplay");
          if (bpmDisplay) {
            bpmDisplay.classList.add("active");
          }
          
          // Update button text
          if (eyeTrackBtn) {
            eyeTrackBtn.textContent = "üëÅÔ∏è Eye Tracking ON";
            eyeTrackBtn.classList.add('active');
          }
          
          // Show gaze cursor
          if (gazeCursor) {
            gazeCursor.classList.add("active");
          }
          
          // Hide video preview (minimize it)
          if (videoElement) {
            videoElement.style.width = '80px';
            videoElement.style.height = '60px';
            videoElement.style.opacity = '0.5';
          }
          
          // Update hint
          const hint = $("hint");
          if (hint) {
            hint.innerHTML = '<span style="color:#4ade80;font-weight:700;">üëÅÔ∏è EYE TRACKING ACTIVE</span> | Look <kbd>UP</kbd> = Jump | Look <kbd>DOWN</kbd> = Duck | Press <kbd>E</kbd> to toggle';
          }
          
          // Start the game
          if (!world.started) {
            start();
          }
        };
      }
      
      // Toggle eye tracking on/off
      window.addEventListener("keydown", (e) => {
        if (e.code === "KeyE" && mediapipeAvailable && mpFaceLandmarker) {
          const hint = $("hint");
          const bpmDisplay = $("bpmDisplay");
          if (eyeTrackingEnabled) {
            eyeTrackingEnabled = false;
            if (eyeTrackingIndicator) eyeTrackingIndicator.classList.remove("active");
            if (gazeCursor) gazeCursor.classList.remove("active");
            if (gazeZoneIndicator) gazeZoneIndicator.style.display = 'none';
            if (bpmDisplay) bpmDisplay.classList.remove("active");
            if (eyeTrackBtn) {
              eyeTrackBtn.textContent = "üëÅÔ∏è Enable Eye Tracking";
              eyeTrackBtn.classList.remove('active');
            }
            if (hint) {
              hint.innerHTML = '<kbd>Space</kbd> Jump | <kbd>Down</kbd> Duck | Press <kbd>E</kbd> for Eye Tracking';
            }
          } else {
            eyeTrackingEnabled = true;
            if (eyeTrackingIndicator) eyeTrackingIndicator.classList.add("active");
            if (gazeCursor) gazeCursor.classList.add("active");
            if (bpmDisplay) bpmDisplay.classList.add("active");
            if (eyeTrackBtn) {
              eyeTrackBtn.textContent = "üëÅÔ∏è Eye Tracking ON";
              eyeTrackBtn.classList.add('active');
            }
            if (hint) {
              hint.innerHTML = '<span style="color:#4ade80;font-weight:700;">üëÅÔ∏è EYE TRACKING ACTIVE</span> | Look <kbd>UP</kbd> = Jump | Look <kbd>DOWN</kbd> = Duck | Press <kbd>E</kbd> to toggle';
            }
          }
        }
      });
      
      // Eye tracking button - start calibration (variables already declared above)
      if (eyeTrackBtn) {
        eyeTrackBtn.onclick = async () => {
          // Ensure MediaPipe is loaded
          if (typeof window.tasksVision === 'undefined') {
            const loaded = await loadMediaPipe();
            if (!loaded) {
              alert("Eye tracking is not available. Please ensure you have a stable internet connection and try refreshing the page.");
              return;
            }
          }
          // Show calibration overlay
          if (calibrationOverlay) {
            calibrationOverlay.classList.add("active");
          }
          
          // Reset calibration
          calibrationClicks = 0;
          gazeCalibration.samples = [];
          if (calibrationPoints && calibrationPoints.length > 0) {
            calibrationPoints.forEach(p => {
              p.classList.remove("clicked");
              p.textContent = "";
              p.style.transform = "";
            });
          }
          if (calibrationStatus) {
            calibrationStatus.textContent = "Initializing camera and face tracking...";
          }
          
          // Initialize MediaPipe and camera
          const mpInit = await initFaceLandmarker();
          if (!mpInit) {
            if (calibrationOverlay) {
              calibrationOverlay.classList.remove("active");
            }
            alert("Could not initialize face tracking.");
            return;
          }
          
          const camInit = await startCamera();
          if (!camInit) {
            if (calibrationOverlay) {
              calibrationOverlay.classList.remove("active");
            }
            return;
          }
          
          // Start processing
          gazeCalibration.isCalibrating = true;
          processFrame();
          
          if (calibrationStatus) {
            calibrationStatus.textContent = "Look at each point and click it 5 times (0/9)";
          }
        };
      }
      
      requestAnimationFrame(tick);
      setTimeout(showDailyBonus, 500);
    }
  }
  }
  }
  }
})();
</script>

<!-- Daily Bonus Modal -->
<div class="daily-bonus-modal" id="dailyBonusModal">
  <div class="daily-bonus-card">
    <h2>‚öîÔ∏è DAILY BONUS ‚öîÔ∏è</h2>
    <p>Welcome back, Viking!</p>
    <div class="streak" id="streakDisplay">üî• 1</div>
    <p>Day Streak</p>
    <div class="reward" id="rewardDisplay">+1 Life</div>
    <button id="claimBonusBtn">CLAIM REWARD</button>
  </div>
</div>
</body>
</html>
