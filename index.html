<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Viking Run</title>
  <style>
    :root{
      /* Apple Design System Colors - HIGH CONTRAST & READABLE */
      --bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --bg-dark: #1a1a2e;
      --surface: #ffffff;
      --surface-elevated: #ffffff;
      --surface-dark: rgba(30, 30, 46, 0.95);
      --text: #000000;
      --text-secondary: #333333;
      --text-tertiary: #666666;
      --text-light: #ffffff;
      --separator: rgba(0, 0, 0, 0.2);
      --accent: #007aff;
      --accent-hover: #0051d5;
      --accent-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --shadow: rgba(0, 0, 0, 0.2);
      --shadow-lg: rgba(0, 0, 0, 0.3);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      background-attachment: fixed;
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
      overflow: hidden;
      user-select: none;
      -webkit-font-smoothing: antialiased;
    }

    .wrap{ 
      height: 100%; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      padding: 24px; 
    }
    
    .shell{
      width: min(1200px, calc(100vw - 48px));
      height: min(800px, calc(100vh - 48px));
      border-radius: 24px;
      background: var(--surface);
      border: none;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(0, 0, 0, 0.05);
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(40px);
    }

    .topbar{ 
      position: absolute; 
      left: 20px; 
      right: 20px; 
      top: 16px; 
      height: 56px; 
      display: flex; 
      align-items: center; 
      justify-content: space-between; 
      z-index: 100; 
      pointer-events: none; 
    }
    
    .leftpack, .rightpack{ 
      display: flex; 
      align-items: center; 
      gap: 12px; 
      pointer-events: auto; 
    }
    
    .title{ 
      padding: 6px 12px; 
      border-radius: 8px; 
      background: transparent;
    }
    
    .title strong{ 
      font-weight: 600; 
      font-size: 17px;
      letter-spacing: -0.4px;
      color: var(--text);
    }
    
    .pill{ 
      font-size: 11px; 
      padding: 4px 8px; 
      border-radius: 6px; 
      background: var(--surface-elevated);
      color: var(--text-secondary);
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }
    
    .scorecard{ 
      display: flex; 
      align-items: center; 
      gap: 24px; 
      padding: 0;
      background: transparent;
      border: none;
    }
    
    .stat{ 
      display: flex;
      flex-direction: column;
      gap: 2px; 
      min-width: 70px; 
    }
    
    .stat .k{ 
      font-size: 10px; 
      color: var(--text-secondary); 
      text-transform: uppercase; 
      font-weight: 500; 
      letter-spacing: 0.5px;
    }
    
    .stat .v{ 
      font-size: 22px; 
      font-weight: 700; 
      line-height: 1; 
      color: #007aff;
      letter-spacing: -0.5px;
    }

    .btn{ 
      border: none; 
      background: var(--surface-elevated);
      color: var(--accent); 
      padding: 8px 16px; 
      border-radius: 8px; 
      cursor: pointer; 
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); 
      font-weight: 500; 
      font-size: 13px; 
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;
    }
    
    .btn:hover{ 
      background: var(--surface-elevated);
      opacity: 0.8;
    }
    
    .btn.primary{ 
      background: var(--accent);
      color: #ffffff;
      font-weight: 600;
    }
    
    .btn.primary:hover {
      background: var(--accent-hover);
    }

    .hudline{ 
      position: absolute; 
      left: 20px; 
      right: 20px; 
      bottom: 20px; 
      display: flex; 
      justify-content: center; 
      z-index: 100; 
      pointer-events: none; 
    }
    
    .hint{ 
      max-width: 700px; 
      padding: 14px 24px; 
      border-radius: 12px; 
      background: #ffffff;
      border: 2px solid rgba(0, 0, 0, 0.2);
      color: #000000; 
      font-size: 13px; 
      font-weight: 600;
      text-align: center; 
      pointer-events: auto;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
    }
    
    kbd{ 
      background: #000000; 
      border-radius: 4px; 
      padding: 3px 8px; 
      color: #ffffff; 
      border: 1px solid #000000; 
      margin: 0 3px; 
      font-weight: 700;
      font-size: 12px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .canvas{ 
      position: absolute; 
      inset: 0; 
      width: 100%; 
      height: 100%; 
      display: block; 
      cursor: crosshair; 
    }
    
    .overlay{ 
      position: absolute; 
      inset: 0; 
      display: grid; 
      place-items: center; 
      pointer-events: none; 
      z-index: 200; 
      background: rgba(0, 0, 0, 0.7); 
      backdrop-filter: blur(20px);
      visibility: visible;
      opacity: 1;
    }
    
    .card{ 
      pointer-events: auto; 
      width: min(480px, 90%); 
      border-radius: 24px; 
      padding: 40px; 
      background: #ffffff;
      backdrop-filter: blur(40px);
      border: 1px solid rgba(0, 0, 0, 0.1);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
      text-align: center;
    }
    
    .card h1{ 
      font-size: 36px; 
      margin: 0 0 16px; 
      font-weight: 800;
      letter-spacing: -1px;
      color: #000000;
    }
    
    .card p{ 
      margin: 0 0 28px; 
      color: #333333; 
      line-height: 1.5; 
      font-size: 15px;
    }
    
    .powerup-list {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      margin: 20px 0;
    }
    
    .powerup-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .powerup-item .icon {
      font-size: 24px;
    }
    
    .powerup-item .name {
      font-size: 10px;
      color: var(--text-secondary);
      text-transform: uppercase;
      font-weight: 500;
    }

    .weapon-indicator {
      position: absolute;
      top: 90px;
      left: 20px;
      padding: 10px 16px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: none;
      align-items: center;
      gap: 10px;
      z-index: 50;
      font-size: 12px;
      color: var(--accent);
    }

    .weapon-indicator.active {
      display: flex;
    }

    .lives-display {
      position: absolute;
      top: 90px;
      right: 20px;
      display: flex;
      gap: 6px;
      align-items: center;
      padding: 10px 16px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.08);
      z-index: 150;
      pointer-events: none;
    }

    .life-heart {
      font-size: 20px;
      transition: opacity 0.2s;
    }

    .life-heart.lost {
      opacity: 0.2;
    }

    .highscore-modal {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 300;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(20px);
      place-items: center;
    }

    .highscore-modal.active {
      display: grid;
    }

    .highscore-card {
      width: min(600px, 90%);
      max-height: 80vh;
      overflow-y: auto;
      padding: 32px;
      border-radius: 18px;
      background: var(--surface);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .highscore-tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 24px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .highscore-tab {
      padding: 10px 16px;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-weight: 500;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.15s;
      font-size: 13px;
    }

    .highscore-tab.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }

    .highscore-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .highscore-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .highscore-item.rank-1 {
      background: var(--accent-subtle);
      border-color: rgba(255, 215, 0, 0.2);
    }

    .highscore-rank {
      font-size: 18px;
      font-weight: 600;
      color: var(--accent);
      min-width: 35px;
    }

    .highscore-score {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
    }

    .highscore-date {
      font-size: 11px;
      color: var(--text-secondary);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="shell" id="shell">
      <canvas class="canvas" id="c"></canvas>

      <div class="topbar">
        <div class="leftpack">
          <div class="title"><strong>Viking Run</strong> <span class="pill" id="statePill">Ready</span></div>
          <div class="scorecard">
            <div class="stat"><div class="k">Score</div><div class="v" id="scoreV">0</div></div>
            <div class="stat"><div class="k">Mead</div><div class="v" id="meadV">0</div></div>
            <div class="stat" id="multiplierStat" style="display: none;"><div class="k">Multiplier</div><div class="v" id="multiplierV">1x</div></div>
          </div>
        </div>
        <div class="rightpack">
          <button class="btn" id="pauseBtn">Pause</button>
          <button class="btn" id="soundBtn">Sound: Off</button>
          <button class="btn primary" id="restartBtn">Restart</button>
        </div>
        <div class="lives-display" id="livesDisplay">
          <span class="life-heart" id="life1">‚ù§Ô∏è</span>
          <span class="life-heart" id="life2">‚ù§Ô∏è</span>
          <span class="life-heart" id="life3">‚ù§Ô∏è</span>
        </div>
      </div>

      <div class="weapon-indicator" id="weaponIndicator">
        <span>‚öîÔ∏è</span>
        <span>Press SPACE to attack</span>
      </div>

      <div class="hudline">
        <div class="hint" id="hint">
          <kbd>Space</kbd> Jump/Attack | <kbd>‚Üì</kbd> Duck | Collect items, jump on platforms, defeat enemies
        </div>
      </div>

      <div class="overlay" id="overlay">
        <div class="card">
          <h1 id="overlayTitle">Viking Run</h1>
          <p id="overlayText" style="white-space: pre-line;">Jump on platforms, defeat enemies with weapons, collect powerups, and survive.</p>
          <div class="powerup-list">
            <div class="powerup-item"><div class="icon">‚ö°</div><div class="name">Speed</div></div>
            <div class="powerup-item"><div class="icon">üõ°</div><div class="name">Shield</div></div>
            <div class="powerup-item"><div class="icon">ü¶ò</div><div class="name">Double Jump</div></div>
            <div class="powerup-item"><div class="icon">‚≠ê</div><div class="name">2x Score</div></div>
          </div>
          <div style="display: flex; flex-direction: column; align-items: center; gap: 8px; width: 100%;">
            <button class="btn primary" id="startBtn" style="padding: 12px 32px; font-size: 14px; width: 100%;">Start Game</button>
            <button class="btn" id="highscoreBtn" style="padding: 10px 24px; font-size: 12px; width: 100%;">High Scores</button>
          </div>
        </div>
      </div>

      <div class="highscore-modal" id="highscoreModal">
        <div class="highscore-card">
          <h2 style="margin-bottom: 24px; font-size: 24px; font-weight: 600; color: var(--text);">High Scores</h2>
          <div class="highscore-tabs">
            <button class="highscore-tab active" data-period="alltime">All Time</button>
            <button class="highscore-tab" data-period="yearly">Yearly</button>
            <button class="highscore-tab" data-period="monthly">Monthly</button>
            <button class="highscore-tab" data-period="weekly">Weekly</button>
            <button class="highscore-tab" data-period="daily">Daily</button>
          </div>
          <div class="highscore-list" id="highscoreList"></div>
          <button class="btn" id="closeHighscoreBtn" style="margin-top: 24px; width: 100%;">Close</button>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  const $ = (id) => document.getElementById(id);
  const rand = (a, b) => a + Math.random() * (b - a);
  const pick = (arr) => arr[(Math.random() * arr.length) | 0];

  const canvas = $("c");
  const shell = $("shell");
  const scoreV = $("scoreV");
  const meadV = $("meadV");
  const statePill = $("statePill");
  const overlay = $("overlay");
  const startBtn = $("startBtn");
  const pauseBtn = $("pauseBtn");
  const restartBtn = $("restartBtn");
  const soundBtn = $("soundBtn");
  const weaponIndicator = $("weaponIndicator");

  let W, H, DPR, ctx;
  const resize = () => {
    const rect = shell.getBoundingClientRect();
    DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    W = Math.floor(rect.width); H = Math.floor(rect.height);
    canvas.width = Math.floor(W * DPR); canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + "px"; canvas.style.height = H + "px";
    ctx = canvas.getContext("2d");
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  };
  window.addEventListener("resize", resize);
  resize(); // Initialize immediately

  let AC = null;
  const beep = (type, freq, dur, gain = 0.2) => {
    if (!OPT.sound) return;
    if (!AC) AC = new (window.AudioContext || window.webkitAudioContext)();
    const o = AC.createOscillator(), g = AC.createGain();
    o.type = type; o.frequency.setValueAtTime(freq, AC.currentTime);
    g.gain.setValueAtTime(gain, AC.currentTime); g.gain.exponentialRampToValueAtTime(0.01, AC.currentTime + dur);
    o.connect(g); g.connect(AC.destination);
    o.start(); o.stop(AC.currentTime + dur);
  };

  const OPT = { sound: false };
  const world = { 
    started: false, paused: false, over: false, 
    score: 0, mead: 0, speed: 200, t: 0, groundY: 0, camX: 0,
    lives: 3, maxLives: 3,
    nextObstacleAt: 0, nextMeadAt: 0, nextPowerupAt: 0, nextPlatformAt: 0, nextEnemyAt: 0, nextWeaponAt: 0, nextHeartAt: 0,
    powerups: {
      speedBoost: { active: false, timeLeft: 0 },
      invincibility: { active: false, timeLeft: 0 },
      doubleJump: { active: false, timeLeft: 0 },
      scoreMultiplier: { active: false, timeLeft: 0, multiplier: 1 }
    }
  };

  const viking = {
    x: 100, y: 0, vy: 0, w: 50, h: 70, 
    onGround: false, ducking: false, faceplant: 0,
    jumpsUsed: 0, maxJumps: 1,
    hasWeapon: false, weaponType: null, attacking: false, attackCooldown: 0
  };

  const Obstacles = [];
  const Meads = [];
  const Powerups = [];
  const Particles = [];
  const Platforms = [];
  const Enemies = [];
  const Weapons = [];
  const Hearts = [];

  const spawnObstacle = (x) => {
    const type = Math.random() > 0.4 ? "shield" : "rock";
    Obstacles.push({ x, type, w: 45, h: 45, hit: false });
  };

  const spawnMead = (x) => {
    Meads.push({ x, y: world.groundY - rand(40, 160), taken: false, rotation: 0 });
  };

  const spawnPowerup = (x) => {
    const types = ["speedBoost", "invincibility", "doubleJump", "scoreMultiplier"];
    const type = pick(types);
    Powerups.push({ 
      x, 
      y: world.groundY - rand(60, 180), 
      type, 
      taken: false,
      rotation: 0,
      pulse: 0
    });
  };

  const spawnPlatform = (x) => {
    const width = rand(80, 150);
    const height = 20;
    // Sometimes spawn low platforms that require ducking (at ground level or slightly above)
    const isLowPlatform = Math.random() < 0.3; // 30% chance
    const y = isLowPlatform ? world.groundY - rand(30, 50) : world.groundY - rand(100, 250);
    Platforms.push({ x, y, width, height, isLow: isLowPlatform });
  };

  const spawnEnemy = (x) => {
    Enemies.push({
      x,
      y: world.groundY,
      w: 50,
      h: 60,
      defeated: false,
      hit: false
    });
  };

  const spawnWeapon = (x) => {
    const types = ["axe", "sword"];
    const type = pick(types);
    Weapons.push({
      x,
      y: world.groundY - rand(80, 180),
      type,
      taken: false,
      rotation: 0,
      size: 30
    });
  };

  const spawnHeart = (x) => {
    Hearts.push({
      x,
      y: world.groundY - rand(50, 150),
      taken: false,
      pulse: 0,
      rotation: 0
    });
  };

  const addParticle = (x, y, color, count = 5) => {
    for (let i = 0; i < count; i++) {
      Particles.push({
        x, y,
        vx: rand(-120, 120),
        vy: rand(-180, -60),
        life: 1,
        color,
        size: rand(4, 10)
      });
    }
  };

  const resetWorld = () => {
    try {
      resize(); // Always resize to ensure H is set
      if (!H || H === 0) {
        setTimeout(resetWorld, 10);
        return;
      }
      
      world.started = false;
      world.paused = false;
      world.over = false;
      world.score = 0; 
      world.mead = 0; 
      world.speed = 200; 
      world.t = 0;
      world.groundY = H * 0.8;
      world.camX = 0;
      viking.x = 100;
      viking.y = world.groundY; 
      viking.vy = 0; 
      viking.faceplant = 0;
      viking.ducking = false;
      viking.onGround = true;
      viking.hasWeapon = false;
      viking.weaponType = null;
      viking.attacking = false;
      viking.attackCooldown = 0;
      Obstacles.length = 0; 
      Meads.length = 0; 
      Powerups.length = 0;
      Particles.length = 0;
      Platforms.length = 0;
      Enemies.length = 0;
      Weapons.length = 0;
      Hearts.length = 0;
      world.nextObstacleAt = viking.x + 600;
      world.nextMeadAt = viking.x + 400;
      world.nextPowerupAt = viking.x + 6000;
      world.nextPlatformAt = viking.x + 500;
      world.nextEnemyAt = viking.x + 800;
      world.nextWeaponAt = viking.x + 600;
      world.nextHeartAt = viking.x + 1200;
      world.lives = 3;
      world.maxLives = 3;
      world.powerups = {
        speedBoost: { active: false, timeLeft: 0 },
        invincibility: { active: false, timeLeft: 0 },
        doubleJump: { active: false, timeLeft: 0 },
        scoreMultiplier: { active: false, timeLeft: 0, multiplier: 1 }
      };
      viking.jumpsUsed = 0;
      viking.maxJumps = 1;
      Input.jump = false;
      Input.duck = false;
      Input.jumpJustPressed = false;
      Input.attackPressed = false;
      
      // Force overlay to show
      if (overlay) {
        overlay.style.display = "grid";
        overlay.style.visibility = "visible";
        overlay.style.opacity = "1";
      }
      if (weaponIndicator) {
        weaponIndicator.classList.remove("active");
        weaponIndicator.style.display = "none";
      }
      const overlayTitle = $("overlayTitle");
      const overlayText = $("overlayText");
      if (overlayTitle) overlayTitle.textContent = "Viking Run";
      if (overlayText) overlayText.textContent = "Jump on platforms, defeat enemies with weapons, collect powerups, and survive.";
      if (startBtn) {
        startBtn.textContent = "Start Game";
        startBtn.style.display = "block";
      }
      if (statePill) statePill.textContent = "Ready";
      if (pauseBtn) pauseBtn.textContent = "Pause";
      updateHUD();
      
      // Force a redraw
      draw();
    } catch (e) {
      console.error("Error in resetWorld:", e);
    }
  };

  const updateHUD = () => {
    try {
      if (scoreV) scoreV.textContent = Math.floor(world.score).toLocaleString();
      if (meadV) meadV.textContent = world.mead;
      const multStat = $("multiplierStat");
      const multV = $("multiplierV");
      if (multStat && multV) {
        if (world.powerups.scoreMultiplier.active) {
          multStat.style.display = "flex";
          multV.textContent = world.powerups.scoreMultiplier.multiplier + "x";
        } else {
          multStat.style.display = "none";
        }
      }
      
      if (weaponIndicator) {
        if (viking.hasWeapon) {
          weaponIndicator.classList.add("active");
        } else {
          weaponIndicator.classList.remove("active");
        }
      }

      for (let i = 1; i <= 3; i++) {
        const lifeEl = $(`life${i}`);
        if (lifeEl) {
          if (i <= world.lives) {
            lifeEl.classList.remove("lost");
          } else {
            lifeEl.classList.add("lost");
          }
        }
      }
    } catch (e) {
      console.error("Error in updateHUD:", e);
    }
  };

  const HighScoreManager = {
    apiUrl: 'https://api.jsonbin.io/v3/b', // Platform-wide leaderboard API
    apiKey: '$2a$10$YourAPIKeyHere', // Replace with actual API key for production
    useLocalStorage: true, // Fallback to localStorage if API fails
    
    getPeriodKey: (period) => {
      const now = new Date();
      const year = now.getFullYear();
      const month = now.getMonth();
      const weekStart = new Date(now.setDate(now.getDate() - now.getDay()));
      const week = Math.floor(weekStart.getDate() / 7);
      const day = now.toDateString();
      
      switch(period) {
        case 'daily': return `highscore_daily_${day}`;
        case 'weekly': return `highscore_weekly_${year}_W${Math.floor((now.getDate() + weekStart.getDay()) / 7)}`;
        case 'monthly': return `highscore_monthly_${year}_${month}`;
        case 'yearly': return `highscore_yearly_${year}`;
        case 'alltime': return 'highscore_alltime';
        default: return 'highscore_alltime';
      }
    },

    async saveScore(score, playerName = null) {
      const now = new Date();
      const playerId = localStorage.getItem('playerId') || `player_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const name = playerName || localStorage.getItem('playerName') || `Player${playerId.substring(7, 11)}`;
      
      const scoreEntry = { 
        score, 
        date: now.toISOString(),
        playerId: playerId,
        playerName: name
      };
      
      // Generate player ID if not exists
      if (!localStorage.getItem('playerId')) {
        localStorage.setItem('playerId', playerId);
      }
      
      // Save player name if provided
      if (playerName) {
        localStorage.setItem('playerName', playerName);
      }
      
      // Save to all periods
      for (const period of ['daily', 'weekly', 'monthly', 'yearly', 'alltime']) {
        const key = HighScoreManager.getPeriodKey(period);
        let scores = HighScoreManager.getScoresLocal(period);
        scores.push(scoreEntry);
        scores.sort((a, b) => b.score - a.score);
        scores = scores.slice(0, 10);
        localStorage.setItem(key, JSON.stringify(scores));
      }
      
      // Try to sync to platform-wide API (if configured)
      try {
        // This would sync to a backend API for platform-wide leaderboards
        // For now, uses localStorage but structured for easy API integration
        if (!HighScoreManager.useLocalStorage) {
          // await fetch(`${HighScoreManager.apiUrl}/viking-game-leaderboard`, {
          //   method: 'PUT',
          //   headers: { 'Content-Type': 'application/json', 'X-API-Key': HighScoreManager.apiKey },
          //   body: JSON.stringify({ scores: allScores })
          // });
        }
      } catch (e) {
        console.log('API sync failed, using localStorage');
      }
    },

    getScoresLocal(period = 'alltime') {
      const key = HighScoreManager.getPeriodKey(period);
      return JSON.parse(localStorage.getItem(key) || '[]');
    },

    async getScores(period = 'alltime') {
      // Try API first, fallback to localStorage
      try {
        if (!HighScoreManager.useLocalStorage) {
          // const response = await fetch(`${HighScoreManager.apiUrl}/viking-game-leaderboard`);
          // const data = await response.json();
          // return data.scores || [];
        }
      } catch (e) {
        console.log('API fetch failed, using localStorage');
      }
      return HighScoreManager.getScoresLocal(period);
    },

    async displayScores(period = 'alltime') {
      const scores = await HighScoreManager.getScores(period);
      const list = $("highscoreList");
      if (!list) return;
      
      list.innerHTML = '';
      
      if (scores.length === 0) {
        list.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">No scores yet</div>';
        return;
      }
      
      const currentPlayerId = localStorage.getItem('playerId');
      const currentPlayerName = localStorage.getItem('playerName') || 'You';
      
      scores.forEach((item, index) => {
        const div = document.createElement('div');
        const isCurrentPlayer = item.playerId === currentPlayerId;
        div.className = `highscore-item ${index === 0 ? 'rank-1' : ''} ${isCurrentPlayer ? 'current-player' : ''}`;
        const date = new Date(item.date);
        const playerName = item.playerName || item.playerId?.substring(0, 8) || 'Player';
        const displayName = isCurrentPlayer ? `${playerName} (You)` : playerName;
        div.innerHTML = `
          <div>
            <div class="highscore-rank">#${index + 1}</div>
            <div class="highscore-date">${displayName} ‚Ä¢ ${date.toLocaleDateString()}</div>
          </div>
          <div class="highscore-score">${Math.floor(item.score).toLocaleString()}</div>
        `;
        list.appendChild(div);
      });
    }
  };

  // Input - SIMPLIFIED ATTACK SYSTEM
  const Input = { jump: false, duck: false, jumpJustPressed: false, attackPressed: false };
  
  window.addEventListener("keydown", (e) => {
    if (e.code === "Space") { 
      if (!Input.jump) {
        Input.jumpJustPressed = true;
      }
      Input.jump = true;
      // Attack when you have weapon - ALWAYS SET
      if (viking.hasWeapon) {
        Input.attackPressed = true;
        console.log("‚úì SPACE PRESSED - Attack set! hasWeapon:", viking.hasWeapon, "cooldown:", viking.attackCooldown.toFixed(2));
      }
      if(!world.started && !world.over) start(); 
    }
    if (e.code === "ArrowDown") Input.duck = true;
    e.preventDefault();
  });
  
  window.addEventListener("keyup", (e) => {
    if (e.code === "Space") {
      Input.jump = false;
      Input.jumpJustPressed = false;
    }
    if (e.code === "ArrowDown") Input.duck = false;
    e.preventDefault();
  });
  
  canvas.addEventListener("pointerdown", (e) => { 
    if (!Input.jump) {
      Input.jumpJustPressed = true;
    }
    Input.jump = true;
    // Attack when you have weapon - ALWAYS SET
    if (viking.hasWeapon) {
      Input.attackPressed = true;
      console.log("‚úì TOUCH PRESSED - Attack set! hasWeapon:", viking.hasWeapon);
    }
    if(!world.started && !world.over) start(); 
    e.preventDefault();
  });
  
  window.addEventListener("pointerup", () => {
    Input.jump = false;
    Input.jumpJustPressed = false;
  });

  const start = () => {
    if (world.started) return;
    try {
      world.started = true;
      world.over = false;
      world.paused = false;
      if (overlay) {
        overlay.style.display = "none";
        overlay.style.visibility = "hidden";
      }
      if (statePill) statePill.textContent = "Playing";
      if (pauseBtn) pauseBtn.textContent = "Pause";
      beep("square", 300, 0.2);
    } catch (e) {
      console.error("Error in start:", e);
    }
  };

  const drawViking = (x, y) => {
    ctx.save();
    ctx.translate(x, y);
    if (viking.faceplant > 0) ctx.rotate(viking.faceplant * -1);

    const bob = viking.onGround ? Math.sin(world.t * 12) * 4 : 0;
    const duckH = viking.ducking ? 0.6 : 1;

    if (viking.hasWeapon && !viking.ducking) {
      ctx.save();
      ctx.translate(15, -40);
      ctx.rotate(viking.attacking ? -Math.PI / 3 : 0);
      if (viking.weaponType === "axe") {
        ctx.fillStyle = "#8b5cf6";
        ctx.fillRect(-3, -20, 6, 25);
        ctx.fillStyle = "#6366f1";
        ctx.beginPath();
        ctx.moveTo(-8, -20);
        ctx.lineTo(8, -20);
        ctx.lineTo(0, -35);
        ctx.fill();
      } else {
        ctx.fillStyle = "#6366f1";
        ctx.fillRect(-2, -25, 4, 30);
        ctx.fillStyle = "#8b5cf6";
        ctx.fillRect(-4, -30, 8, 8);
      }
      ctx.restore();
    }

    ctx.fillStyle = "#556677";
    ctx.fillRect(-20, -50 * duckH + bob, 40, 50 * duckH);

    ctx.fillStyle = "#ffdbac";
    ctx.beginPath(); ctx.arc(0, -65 * duckH + bob, 15, 0, Math.PI * 2); ctx.fill();

    ctx.fillStyle = "#e67e22";
    ctx.beginPath(); ctx.moveTo(-12, -60 * duckH + bob); ctx.lineTo(12, -60 * duckH + bob); ctx.lineTo(0, -35 * duckH + bob); ctx.fill();

    ctx.fillStyle = "#7f8c8d";
    ctx.beginPath(); ctx.arc(0, -70 * duckH + bob, 16, Math.PI, 0); ctx.fill();
    ctx.fillStyle = "#ecf0f1";
    ctx.beginPath(); ctx.moveTo(-15, -75 * duckH + bob); ctx.lineTo(-25, -90 * duckH + bob); ctx.lineTo(-10, -80 * duckH + bob); ctx.fill();
    ctx.beginPath(); ctx.moveTo(15, -75 * duckH + bob); ctx.lineTo(25, -90 * duckH + bob); ctx.lineTo(10, -80 * duckH + bob); ctx.fill();

    ctx.restore();
  };

  const drawPlatform = (p) => {
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
    ctx.fillRect(0, p.height, p.width, 5);
    const gradient = ctx.createLinearGradient(0, 0, 0, p.height);
    gradient.addColorStop(0, "#64748b");
    gradient.addColorStop(1, "#475569");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, p.width, p.height);
    ctx.strokeStyle = "#334155";
    ctx.lineWidth = 2;
    ctx.strokeRect(0, 0, p.width, p.height);
    ctx.restore();
  };

  const drawEnemy = (e) => {
    if (e.defeated) return;
    ctx.save();
    ctx.translate(e.x, e.y);
    ctx.fillStyle = "#dc2626";
    ctx.fillRect(-e.w/2, -e.h, e.w, e.h);
    ctx.fillStyle = "#991b1b";
    ctx.beginPath();
    ctx.arc(0, -e.h - 12, 15, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#ff0000";
    ctx.beginPath();
    ctx.arc(-6, -e.h - 10, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(6, -e.h - 10, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#888";
    ctx.fillRect(e.w/2 - 2, -e.h + 10, 4, 20);
    ctx.restore();
  };

  const drawWeapon = (w) => {
    ctx.save();
    ctx.translate(w.x, w.y);
    ctx.rotate(w.rotation);
    
    const size = w.size || 25;
    const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 2);
    glowGradient.addColorStop(0, (w.type === "axe" ? "#8b5cf6" : "#6366f1") + "80");
    glowGradient.addColorStop(0.5, (w.type === "axe" ? "#8b5cf6" : "#6366f1") + "40");
    glowGradient.addColorStop(1, (w.type === "axe" ? "#8b5cf6" : "#6366f1") + "00");
    ctx.fillStyle = glowGradient;
    ctx.beginPath();
    ctx.arc(0, 0, size * 2, 0, Math.PI * 2);
    ctx.fill();
    
    if (w.type === "axe") {
      ctx.fillStyle = "#8b5cf6";
      ctx.fillRect(-4, -size * 0.6, 8, size * 0.8);
      ctx.fillStyle = "#6366f1";
      ctx.beginPath();
      ctx.moveTo(-size * 0.4, -size * 0.6);
      ctx.lineTo(size * 0.4, -size * 0.6);
      ctx.lineTo(0, -size);
      ctx.fill();
    } else {
      ctx.fillStyle = "#6366f1";
      ctx.fillRect(-3, -size * 0.8, 6, size);
      ctx.fillStyle = "#8b5cf6";
      ctx.fillRect(-5, -size, 10, size * 0.3);
    }
    
    ctx.strokeStyle = "#FFF";
    ctx.lineWidth = 2;
    ctx.shadowBlur = 20;
    ctx.shadowColor = w.type === "axe" ? "#8b5cf6" : "#6366f1";
    ctx.restore();
  };

  const drawHeart = (x, y, pulse, rotation) => {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    const size = 20 * pulse;
    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 2);
    gradient.addColorStop(0, "#ef4444AA");
    gradient.addColorStop(0.5, "#ef444460");
    gradient.addColorStop(1, "#ef444400");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(0, 0, size * 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#ef4444";
    ctx.shadowBlur = 20;
    ctx.shadowColor = "#ef4444";
    ctx.beginPath();
    ctx.moveTo(0, size * 0.3);
    ctx.bezierCurveTo(-size * 0.5, -size * 0.2, -size, size * 0.1, 0, size * 0.8);
    ctx.bezierCurveTo(size, size * 0.1, size * 0.5, -size * 0.2, 0, size * 0.3);
    ctx.fill();
    ctx.restore();
  };

  const drawShield = (x, y) => {
    ctx.save();
    ctx.translate(x, world.groundY);
    ctx.fillStyle = "#5d4037";
    ctx.beginPath(); ctx.arc(0, -22, 22, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = "#bdc3c7"; ctx.lineWidth = 3; ctx.stroke();
    ctx.fillStyle = "#7f8c8d";
    ctx.beginPath(); ctx.arc(0, -22, 6, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
  };

  const drawRock = (x, y) => {
    ctx.fillStyle = "#2c3e50";
    ctx.beginPath(); ctx.moveTo(x-25, world.groundY); ctx.lineTo(x, world.groundY-45); ctx.lineTo(x+25, world.groundY); ctx.fill();
  };

  const drawMead = (x, y) => {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = "#f1c40f";
    ctx.fillRect(-10, -15, 20, 25);
    ctx.fillStyle = "#fff";
    ctx.beginPath(); ctx.arc(-5, -15, 6, 0, Math.PI*2); ctx.arc(5, -15, 6, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = "#f1c40f"; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.arc(10, -2, 8, -Math.PI/2, Math.PI/2); ctx.stroke();
    ctx.restore();
  };

  const getPowerupColor = (type) => {
    const colors = {
      speedBoost: "#FF6B6B",
      invincibility: "#4ECDC4",
      doubleJump: "#95E1D3",
      scoreMultiplier: "#FFD93D"
    };
    return colors[type] || "#FFF";
  };

  const getPowerupSymbol = (type) => {
    const symbols = {
      speedBoost: "‚ö°",
      invincibility: "üõ°",
      doubleJump: "ü¶ò",
      scoreMultiplier: "‚≠ê"
    };
    return symbols[type] || "?";
  };

  const activatePowerup = (type) => {
    const p = world.powerups[type];
    p.active = true;
    p.timeLeft = 10;
    
    if (type === "doubleJump") {
      viking.maxJumps = 2;
    } else if (type === "scoreMultiplier") {
      p.multiplier = 2;
    }
    updateHUD();
  };

  const drawPowerup = (x, y, type, rotation, pulse) => {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    const size = 22 * pulse;
    const color = getPowerupColor(type);
    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 2);
    gradient.addColorStop(0, color + "AA");
    gradient.addColorStop(0.5, color + "60");
    gradient.addColorStop(1, color + "00");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(0, 0, size * 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(0, 0, size, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#FFF";
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.fillStyle = "#FFF";
    ctx.font = `bold ${size * 0.9}px Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(getPowerupSymbol(type), 0, 0);
    ctx.restore();
  };

  const drawParticle = (p) => {
    ctx.save();
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.shadowBlur = 10;
    ctx.shadowColor = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  };

  const checkPlatformCollision = (dt) => {
    const vikingHeight = viking.ducking ? 42 : 70; // Ducking makes viking shorter
    const vikingWidth = 40;
    const vikingLeft = viking.x - vikingWidth/2;
    const vikingRight = viking.x + vikingWidth/2;
    const vikingTop = viking.y - vikingHeight;
    const vikingBottom = viking.y;
    
    for (const p of Platforms) {
      const platformLeft = p.x;
      const platformRight = p.x + p.width;
      const platformTop = p.y;
      const platformBottom = p.y + p.height;
      
      // Check horizontal overlap
      if (vikingRight > platformLeft && vikingLeft < platformRight) {
        // Low platform collision - must duck or jump over
        if (p.isLow) {
          // If viking hits low platform while standing, lose life
          if (!viking.ducking && vikingBottom > platformTop - 5 && vikingTop < platformBottom + 5) {
            if (!world.powerups.invincibility.active) {
              world.lives--;
              addParticle(viking.x, viking.y, "#ef4444", 15);
              beep("sawtooth", 150, 0.3);
              updateHUD();
              
              if (world.lives <= 0) {
                world.over = true;
                viking.faceplant = 1.5;
                if (statePill) statePill.textContent = "Game Over";
                HighScoreManager.saveScore(world.score);
                beep("sawtooth", 100, 0.4);
                setTimeout(() => { 
                  if (overlay) {
                    overlay.style.display = "grid";
                    overlay.style.visibility = "visible";
                    overlay.style.opacity = "1";
                  }
                  const overlayTitle = $("overlayTitle");
                  const overlayText = $("overlayText");
                  if (overlayTitle) overlayTitle.textContent = "Game Over";
                  if (overlayText) overlayText.textContent = `Hit a low platform!\nFinal Score: ${Math.floor(world.score).toLocaleString()}\nMead Collected: ${world.mead}`;
                  if (startBtn) startBtn.textContent = "Play Again";
                }, 1200);
              } else {
                world.powerups.invincibility.active = true;
                world.powerups.invincibility.timeLeft = 2;
              }
            }
            return false; // Don't land on low platform
          }
          // Can pass under if ducking
          return false;
        }
        
        // Regular platform - landing from above
        if (vikingBottom <= platformTop + 10 && vikingBottom + viking.vy * dt >= platformTop && viking.vy >= 0) {
          viking.y = platformTop;
          viking.vy = 0;
          viking.onGround = true;
          viking.jumpsUsed = 0;
          return true;
        }
        // Hitting platform from below
        if (vikingTop + viking.vy * dt <= platformBottom && vikingTop >= platformBottom - 10 && viking.vy < 0) {
          viking.vy = 0;
          viking.y = platformBottom + vikingHeight;
          return true;
        }
      }
    }
    return false;
  };

  const update = (dt) => {
    if (!dt || dt <= 0 || dt > 1) return; // Safety check
    if (!world.started || world.paused || world.over) {
      Input.jumpJustPressed = false;
      return;
    }
    if (!H || H === 0) return; // Safety check

    world.t += dt;
    
    const baseSpeed = 200;
    const speedMultiplier = world.powerups.speedBoost.active ? 1.5 : 1;
    world.speed = Math.min(400, world.speed + 2 * dt * speedMultiplier);
    if (!world.powerups.speedBoost.active && world.speed > baseSpeed) {
      world.speed = Math.max(baseSpeed, world.speed - 5 * dt);
    }
    
    viking.x += world.speed * dt;
    const scoreMultiplier = world.powerups.scoreMultiplier.active ? world.powerups.scoreMultiplier.multiplier : 1;
    world.score += world.speed * 0.015 * dt * scoreMultiplier;
    
    for (const key in world.powerups) {
      const p = world.powerups[key];
      if (p.active) {
        p.timeLeft -= dt;
        if (p.timeLeft <= 0) {
          p.active = false;
          if (key === "doubleJump") viking.maxJumps = 1;
          if (key === "scoreMultiplier") p.multiplier = 1;
          updateHUD();
        }
      }
    }

    // ATTACK SYSTEM - FIXED AND WORKING
    if (viking.attackCooldown > 0) {
      viking.attackCooldown -= dt;
    }
    
    // Attack system - COMPLETELY REWRITTEN TO WORK
    // Check attack EVERY FRAME when you have weapon
    if (viking.hasWeapon) {
      // If attack is pressed and cooldown is ready
      if (Input.attackPressed && viking.attackCooldown <= 0 && !viking.ducking) {
        console.log("ATTACK TRIGGERED! Enemies:", Enemies.length);
        viking.attacking = true;
        viking.attackCooldown = 0.6;
        
        // Attack ALL enemies in range - MASSIVE RANGE
        let killedAny = false;
        for (let i = Enemies.length - 1; i >= 0; i--) {
          const e = Enemies[i];
          if (!e.defeated) {
            const distX = Math.abs(viking.x - e.x);
            const distY = Math.abs(viking.y - e.y);
            // MASSIVE attack range: 250px horizontal, 200px vertical
            if (distX < 250 && distY < 200) {
              console.log("KILLING ENEMY at distance:", distX, distY);
              e.defeated = true;
              e.hit = true;
              killedAny = true;
              world.score += 100 * scoreMultiplier;
              addParticle(e.x, e.y, "#dc2626", 40);
              beep("square", 900, 0.6);
              updateHUD();
              // Remove enemy immediately
              Enemies.splice(i, 1);
              console.log("‚úì ENEMY KILLED! Remaining:", Enemies.length);
            }
          }
        }
        
        if (killedAny) {
          console.log("‚úì‚úì‚úì ATTACK SUCCESSFUL! ‚úì‚úì‚úì");
        } else {
          console.log("‚úó Attack attempted but no enemy in range. Enemies:", Enemies.length);
          if (Enemies.length > 0) {
            const e = Enemies[0];
            const distX = Math.abs(viking.x - e.x);
            const distY = Math.abs(viking.y - e.y);
            console.log("Closest enemy distance:", distX, distY);
          }
        }
        
        // Reset attack input AFTER processing
        Input.attackPressed = false;
        setTimeout(() => { viking.attacking = false; }, 500);
      }
    }

    // Jump logic
    if (Input.jumpJustPressed && !viking.ducking && viking.jumpsUsed < viking.maxJumps) {
      viking.vy = -680;
      viking.onGround = false;
      viking.jumpsUsed++;
      beep("sine", 200, 0.1);
      Input.jumpJustPressed = false;
    }
    
    viking.vy += 1600 * dt;
    viking.y += viking.vy * dt;

    const onPlatform = checkPlatformCollision(dt);
    
    // Ground collision only if not on platform
    if (!onPlatform) {
      if (viking.y >= world.groundY) {
        viking.y = world.groundY;
        viking.vy = 0;
        viking.onGround = true;
        viking.jumpsUsed = 0;
      } else {
        viking.onGround = false;
      }
    }

    // Ducking works in air or on ground
    viking.ducking = Input.duck;

    // Spawn logic - REDUCED FREQUENCY
    if (viking.x > world.nextObstacleAt - W) {
      spawnObstacle(world.nextObstacleAt);
      world.nextObstacleAt += rand(500, 800);
    }
    if (viking.x > world.nextMeadAt - W) {
      spawnMead(world.nextMeadAt);
      world.nextMeadAt += rand(400, 600);
    }
    if (viking.x > world.nextPowerupAt - W) {
      spawnPowerup(world.nextPowerupAt);
      world.nextPowerupAt += rand(6000, 10000); // MUCH RARER
    }
    if (viking.x > world.nextPlatformAt - W) {
      spawnPlatform(world.nextPlatformAt);
      world.nextPlatformAt += rand(500, 800);
    }
    if (viking.x > world.nextEnemyAt - W) {
      spawnEnemy(world.nextEnemyAt);
      world.nextEnemyAt += rand(700, 1200);
    }
    if (viking.x > world.nextWeaponAt - W && !viking.hasWeapon) {
      spawnWeapon(world.nextWeaponAt);
      world.nextWeaponAt += rand(700, 1200);
    }
    if (viking.x > world.nextHeartAt - W) {
      if (world.lives < world.maxLives) {
        spawnHeart(world.nextHeartAt);
      }
      world.nextHeartAt += rand(1000, 1800);
    }
    
    // Update all objects
    for (const o of Obstacles) o.x -= world.speed * dt;
    for (const p of Platforms) p.x -= world.speed * dt;
    
    for (const e of Enemies) {
      if (!e.defeated) {
        e.x -= world.speed * 0.4 * dt;
        if (e.x < viking.x - W - 200) e.defeated = true;
      }
    }
    
    for (const w of Weapons) {
      if (!w.taken) {
        w.rotation += dt * 3;
        w.x -= world.speed * dt;
      }
    }
    
    for (const h of Hearts) {
      if (!h.taken) {
        h.rotation += dt * 2;
        h.pulse = Math.sin(world.t * 8) * 0.2 + 1;
        h.x -= world.speed * dt;
      }
    }
    
    for (const p of Powerups) {
      if (!p.taken) {
        p.rotation += dt * 4;
        p.pulse = Math.sin(world.t * 10) * 0.25 + 1;
        p.x -= world.speed * dt;
      }
    }
    
    for (const m of Meads) {
      if (!m.taken) {
        m.rotation += dt * 2;
        m.x -= world.speed * dt;
      }
    }
    
    for (let i = Particles.length - 1; i >= 0; i--) {
      const p = Particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 350 * dt;
      p.life -= dt * 2.5;
      if (p.life <= 0) Particles.splice(i, 1);
    }

    // Collisions - Obstacles
    for (const o of Obstacles) {
      if (!o.hit && viking.x > o.x - 25 && viking.x < o.x + 25 && viking.y > world.groundY - 45 && !viking.ducking) {
        if (!world.powerups.invincibility.active) {
          o.hit = true;
          world.lives--;
          addParticle(o.x, world.groundY - 20, "#ef4444", 15);
          beep("sawtooth", 150, 0.3);
          updateHUD();
          
          if (world.lives <= 0) {
            world.over = true;
            viking.faceplant = 1.5;
            statePill.textContent = "Game Over";
            HighScoreManager.saveScore(world.score);
            beep("sawtooth", 100, 0.4);
            setTimeout(() => { 
              if (overlay) {
                overlay.style.display = "grid";
                overlay.style.visibility = "visible";
                overlay.style.opacity = "1";
              }
              const overlayTitle = $("overlayTitle");
              const overlayText = $("overlayText");
              if (overlayTitle) overlayTitle.textContent = "Game Over";
              if (overlayText) overlayText.textContent = `Final Score: ${Math.floor(world.score).toLocaleString()}\nMead Collected: ${world.mead}`;
              if (startBtn) startBtn.textContent = "Play Again";
            }, 1200);
          } else {
            world.powerups.invincibility.active = true;
            world.powerups.invincibility.timeLeft = 2;
          }
        } else {
          addParticle(o.x, world.groundY - 20, "#4ECDC4", 12);
          beep("sine", 400, 0.15);
        }
      }
    }

    // Collisions - Enemies - COMPLETELY FIXED TO KILL YOU
    for (const e of Enemies) {
      if (!e.defeated) {
        const distX = Math.abs(viking.x - e.x);
        const distY = Math.abs(viking.y - e.y);
        // Enemy collision: 50px horizontal, 70px vertical
        if (distX < 50 && distY < 70) {
          // If you're attacking RIGHT NOW, you kill the enemy (handled above)
          if (viking.attacking) {
            continue; // Attack system handles killing
          }
          
          // Otherwise, enemy hits you - YOU TAKE DAMAGE
          if (!world.powerups.invincibility.active) {
            // Mark enemy as hit so it doesn't hit multiple times
            if (!e.hit) {
              e.hit = true;
              world.lives--;
              addParticle(viking.x, viking.y, "#ef4444", 25);
              beep("sawtooth", 250, 0.5);
              updateHUD();
              console.log("Hit by enemy! Lives:", world.lives);
              
              if (world.lives <= 0) {
                world.over = true;
                viking.faceplant = 1.5;
                if (statePill) statePill.textContent = "Game Over";
                HighScoreManager.saveScore(world.score, localStorage.getItem('playerName') || 'Player');
                beep("sawtooth", 100, 0.6);
                setTimeout(() => { 
                  if (overlay) {
                    overlay.style.display = "grid";
                    overlay.style.visibility = "visible";
                    overlay.style.opacity = "1";
                  }
                  const overlayTitle = $("overlayTitle");
                  const overlayText = $("overlayText");
                  if (overlayTitle) overlayTitle.textContent = "Game Over";
                  if (overlayText) overlayText.textContent = `You were defeated!\nFinal Score: ${Math.floor(world.score).toLocaleString()}\nMead Collected: ${world.mead}`;
                  if (startBtn) startBtn.textContent = "Play Again";
                }, 1200);
              } else {
                world.powerups.invincibility.active = true;
                world.powerups.invincibility.timeLeft = 1.5;
              }
            }
          }
        }
      }
    }

    // Collisions - Meads
    for (const m of Meads) {
      if (!m.taken && Math.hypot(viking.x - m.x, (viking.y-30) - m.y) < 45) {
        m.taken = true;
        world.mead++;
        world.score += 75 * scoreMultiplier;
        addParticle(m.x, m.y, "#FFD700", 8);
        beep("sine", 800, 0.12);
        updateHUD();
      }
    }
    
    // Collisions - Weapons
    for (const w of Weapons) {
      if (!w.taken && Math.hypot(viking.x - w.x, (viking.y-30) - w.y) < 40) {
        w.taken = true;
        viking.hasWeapon = true;
        viking.weaponType = w.type;
        addParticle(w.x, w.y, "#6366f1", 12);
        beep("square", 500, 0.2);
        updateHUD();
      }
    }
    
    // Collisions - Powerups
    for (const p of Powerups) {
      if (!p.taken && Math.hypot(viking.x - p.x, (viking.y-30) - p.y) < 40) {
        p.taken = true;
        activatePowerup(p.type);
        addParticle(p.x, p.y, getPowerupColor(p.type), 15);
        beep("square", 600, 0.25);
      }
    }

    // Collisions - Hearts
    for (const h of Hearts) {
      if (!h.taken && Math.hypot(viking.x - h.x, (viking.y-30) - h.y) < 40) {
        h.taken = true;
        if (world.lives < world.maxLives) {
          world.lives++;
          addParticle(h.x, h.y, "#ef4444", 20);
          beep("sine", 600, 0.2);
          updateHUD();
        }
      }
    }

    world.camX = viking.x - 150;
    updateHUD();
  };

  const draw = () => {
    ctx.clearRect(0, 0, W, H);
    
    const bgGradient = ctx.createLinearGradient(0, 0, 0, H);
    bgGradient.addColorStop(0, "#0a0a0a");
    bgGradient.addColorStop(1, "#1a1a1a");
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, W, H);
    
    ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
    ctx.lineWidth = 2;
    for (let i = 0; i < 5; i++) {
      const y = world.groundY + (H - world.groundY) * (i / 5) + Math.sin(world.t * 2 + i) * 3;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(W, y);
      ctx.stroke();
    }

    ctx.strokeStyle = "rgba(255, 255, 255, 0.15)"; 
    ctx.lineWidth = 3; 
    ctx.beginPath(); 
    ctx.moveTo(0, world.groundY); 
    ctx.lineTo(W, world.groundY); 
    ctx.stroke();

    ctx.save();
    ctx.translate(-world.camX, 0);

    for (const p of Platforms) {
      if (p.x > viking.x - W - 100 && p.x < viking.x + W + 100) {
        drawPlatform(p);
      }
    }

    for (const w of Weapons) {
      if (!w.taken && w.x > viking.x - W - 100 && w.x < viking.x + W + 100) {
        drawWeapon(w);
      }
    }

    for (const h of Hearts) {
      if (!h.taken && h.x > viking.x - W - 100 && h.x < viking.x + W + 100) {
        drawHeart(h.x, h.y, h.pulse, h.rotation);
      }
    }

    for (const e of Enemies) {
      if (!e.defeated && e.x > viking.x - W - 100 && e.x < viking.x + W + 100) {
        drawEnemy(e);
      }
    }

    for (const m of Meads) if (!m.taken && m.x > viking.x - W - 100 && m.x < viking.x + W + 100) drawMead(m.x, m.y);
    for (const p of Powerups) if (!p.taken && p.x > viking.x - W - 100 && p.x < viking.x + W + 100) drawPowerup(p.x, p.y, p.type, p.rotation, p.pulse);
    for (const o of Obstacles) {
      if (o.x > viking.x - W - 100 && o.x < viking.x + W + 100) {
        if (o.type === "shield") drawShield(o.x, o.y);
        else drawRock(o.x, o.y);
      }
    }

    if (world.powerups.invincibility.active) {
      ctx.save();
      ctx.globalAlpha = 0.4 + Math.sin(world.t * 25) * 0.2;
      ctx.strokeStyle = "#4ECDC4";
      ctx.lineWidth = 5;
      ctx.shadowBlur = 20;
      ctx.shadowColor = "#4ECDC4";
      ctx.beginPath();
      ctx.arc(viking.x, viking.y - 30, 45, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    drawViking(viking.x, viking.y);
    ctx.restore();
    
    ctx.save();
    ctx.translate(-world.camX, 0);
    for (const p of Particles) drawParticle(p);
    ctx.restore();
    
    if (world.started && !world.paused && !world.over) {
      let yPos = 100;
      for (const key in world.powerups) {
        const p = world.powerups[key];
        if (p.active) {
          ctx.save();
          ctx.fillStyle = getPowerupColor(key);
          ctx.font = "600 16px -apple-system";
          ctx.textAlign = "left";
          ctx.shadowBlur = 8;
          ctx.shadowColor = getPowerupColor(key);
          ctx.fillText(`${getPowerupSymbol(key)} ${Math.ceil(p.timeLeft)}s`, 24, yPos);
          ctx.restore();
          yPos += 26;
        }
      }
    }
  };

  let last = performance.now();
  const tick = (t) => {
    const dt = Math.min(0.1, (t - last) / 1000);
    last = t;
    update(dt);
    draw();
    requestAnimationFrame(tick);
  };

  startBtn.onclick = () => {
    try {
      // Save player name
      const nameInput = $("playerNameInput");
      if (nameInput && nameInput.value.trim()) {
        localStorage.setItem('playerName', nameInput.value.trim());
      }
      
      if (world.over) {
        resetWorld();
      } else {
        start();
      }
    } catch (e) {
      console.error("Error in startBtn click:", e);
      resetWorld();
    }
  };
  
  // Load player name on startup
  const nameInput = $("playerNameInput");
  if (nameInput) {
    const savedName = localStorage.getItem('playerName');
    if (savedName) {
      nameInput.value = savedName;
    }
  }
  
  restartBtn.onclick = () => { 
    try {
      resetWorld(); 
    } catch (e) {
      console.error("Error in restartBtn click:", e);
    }
  };
  
  pauseBtn.onclick = () => { 
    if (!world.started || world.over) return;
    world.paused = !world.paused; 
    pauseBtn.textContent = world.paused ? "Resume" : "Pause";
    statePill.textContent = world.paused ? "Paused" : "Playing";
  };
  
  soundBtn.onclick = () => { 
    OPT.sound = !OPT.sound; 
    soundBtn.textContent = OPT.sound ? "Sound: On" : "Sound: Off"; 
  };

  const highscoreBtn = $("highscoreBtn");
  const highscoreModal = $("highscoreModal");
  const highscoreTabs = document.querySelectorAll(".highscore-tab");
  const closeHighscoreBtn = $("closeHighscoreBtn");
  
  highscoreBtn.onclick = () => {
    highscoreModal.classList.add("active");
    HighScoreManager.displayScores('alltime');
  };
  
  highscoreTabs.forEach(tab => {
    tab.onclick = () => {
      highscoreTabs.forEach(t => t.classList.remove("active"));
      tab.classList.add("active");
      const period = tab.dataset.period;
      HighScoreManager.displayScores(period);
    };
  });
  
  if (closeHighscoreBtn) {
    closeHighscoreBtn.onclick = () => {
      highscoreModal.classList.remove("active");
    };
  }
  
  highscoreModal.onclick = (e) => {
    if (e.target === highscoreModal) {
      highscoreModal.classList.remove("active");
    }
  };

  // Initialize after DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      resize();
      resetWorld();
      requestAnimationFrame(tick);
    });
  } else {
    resize();
    resetWorld();
    requestAnimationFrame(tick);
  }
})();
</script>
</body>
</html>
